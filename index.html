<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Comprehensive Docking Suite • Antibody-Antigen • Ligand Screening • Enthalpy Analysis</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0f172a" />
<meta name="description" content="Advanced in-browser docking platform: antibody-antigen docking with parallel workers, batch ligand screening (50 SMILES vs 2-3 PDBs), detailed enthalpy calculations, QA registry, reproducible exports, and comprehensive analytics." />
<style>
  /* ===== CSS VARIABLES & THEME DEFINITION ===== */
  /* These custom properties define our dark theme color palette and font families.
     Using CSS variables makes it easy to maintain consistent styling throughout. */
  :root{
    --bg:#0b1220;           /* Main background - deep navy blue */
    --panel:#0f172a;        /* Panel background - slightly lighter navy */
    --text:#e5e7eb;         /* Primary text color - light gray */
    --muted:#9ca3af;        /* Muted text for secondary information */
    --accent:#60a5fa;       /* Accent color - bright blue for highlights */
    --line:#1f2937;         /* Border/divider lines - subtle gray */
    --green:#34d399;        /* Success/positive actions - emerald */
    --red:#f87171;          /* Errors/warnings - coral red */
    --yellow:#fbbf24;       /* Caution/info - amber */
    --orange:#f97316;       /* Secondary highlight - orange */
    --purple:#a78bfa;       /* Tertiary accent - purple */
    --cyan:#22d3ee;         /* Additional accent - cyan */
    /* Font stacks for code and UI text */
    --mono: ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;
    --sans: Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;
  }
  
  /* ===== GLOBAL RESETS & BASE STYLES ===== */
  *{box-sizing:border-box}  /* Consistent box model across all elements */
  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font-family:var(--sans);
    line-height:1.6;
    overflow-x:hidden;  /* Prevent horizontal scroll on narrow screens */
  }
  a{color:var(--accent);text-decoration:none}
  
  /* ===== HEADER WITH GRADIENT BACKGROUND ===== */
  /* The header uses radial gradients to create a subtle depth effect */
  header{
    padding:34px 16px;
    background:
      radial-gradient(1200px 600px at 15% -10%,#1d2a4a,transparent 60%),
      radial-gradient(1000px 500px at 120% 10%,#2a1e4a,transparent 60%);
  }
  
  /* ===== LAYOUT CONTAINERS ===== */
  .wrap{max-width:1400px;margin:0 auto}  /* Centered content with max width */
  
  /* ===== TYPOGRAPHY ===== */
  h1{margin:0 0 8px;font-size:30px;font-weight:700}
  h2{margin:0 0 10px;font-size:22px;font-weight:600}
  h3{margin:14px 0 6px;font-size:17px;font-weight:600}
  h4{margin:10px 0 4px;font-size:15px;font-weight:600}
  p.lead{color:var(--muted);margin:6px 0 0;font-size:14px}
  
  /* ===== SECTIONS & CARDS ===== */
  section{
    padding:22px 16px;
    border-top:1px solid var(--line);
    background:var(--panel);
  }
  .card{
    background:#0b1220;
    border:1px solid var(--line);
    border-radius:14px;
    padding:14px;
    margin-bottom:12px;
  }
  
  /* ===== GRID LAYOUTS ===== */
  /* Responsive grid that adapts to screen size */
  .grid{display:grid;gap:16px}
  @media(min-width:980px){.grid{grid-template-columns:1.05fr .95fr}}
  @media(min-width:1200px){.grid-3{grid-template-columns:repeat(3,1fr)}}
  
  /* ===== FLEXBOX UTILITIES ===== */
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  
  /* ===== FORM ELEMENTS ===== */
  label{font-weight:600;font-size:13px}
  input[type="number"], input[type="text"], textarea, select{
    background:#0a0f1a;
    color:var(--text);
    border:1px solid #1f2937;
    border-radius:8px;
    padding:8px 10px;
    font-family:var(--mono);
    font-size:13px;
    min-width:80px;
    transition:border-color 0.2s;
  }
  input[type="number"]:focus, input[type="text"]:focus, textarea:focus, select:focus{
    outline:none;
    border-color:var(--accent);
  }
  textarea{width:100%;min-height:110px;resize:vertical}
  
  /* ===== BUTTONS ===== */
  /* Base button style with smooth transitions for hover effects */
  .btn{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:9px 12px;
    border-radius:10px;
    font-weight:600;
    border:1px solid var(--line);
    background:#0b1220;
    cursor:pointer;
    font-size:13px;
    transition:all 0.2s ease;
    user-select:none;
  }
  .btn:hover:not([disabled]){
    transform:translateY(-1px);
    box-shadow:0 4px 12px rgba(96,165,250,0.3);
  }
  /* Button variants with gradient backgrounds */
  .btn.primary{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0}
  .btn.green{background:linear-gradient(180deg,#059669,#047857);border:0}
  .btn.red{background:linear-gradient(180deg,#dc2626,#b91c1c);border:0}
  .btn.purple{background:linear-gradient(180deg,#7c3aed,#6d28d9);border:0}
  .btn.orange{background:linear-gradient(180deg,#f97316,#ea580c);border:0}
  .btn[disabled]{opacity:0.55;cursor:not-allowed}
  
  /* ===== STATUS INDICATORS ===== */
  .pill{
    padding:2px 8px;
    border:1px solid #334155;
    border-radius:999px;
    font-size:12px;
    color:#93c5fd;
    font-weight:500;
  }
  
  /* ===== PROGRESS BAR ===== */
  progress{
    width:260px;
    height:10px;
    border:1px solid #1f2937;
    border-radius:999px;
    background:#0b1220;
  }
  progress::-webkit-progress-bar{background:#0b1220;border-radius:999px}
  progress::-webkit-progress-value{background:#60a5fa;border-radius:999px;transition:width 0.3s}
  
  /* ===== 3D VIEWERS ===== */
  /* Container for 3Dmol.js molecular visualization */
  #viewer, #viewerLig, #viewerScr, #viewerComp{
    position:relative;
    width:100%;
    height:560px;
    border:1px solid var(--line);
    border-radius:10px;
    background:#0a0f1a;
    overflow:hidden;
  }
  
  /* ===== TEXT DISPLAY BOXES ===== */
  .score{
    font-family:var(--mono);
    background:#0a0f1a;
    border:1px solid var(--line);
    border-radius:8px;
    padding:8px;
    overflow:auto;
    font-size:12px;
    line-height:1.5;
  }
  
  /* ===== INFO BOXES ===== */
  /* Styled notification boxes for different message types */
  .infobox{
    border:1px solid #334155;
    border-left:4px solid var(--accent);
    border-radius:10px;
    padding:10px;
    background:#0a0f1a;
    color:#cbd5e1;
    margin:10px 0;
    font-size:13px;
  }
  .errorbox{
    border:1px solid #7f1d1d;
    border-left:4px solid #dc2626;
    border-radius:10px;
    padding:10px;
    background:#1a0c0c;
    color:#fecaca;
    margin:10px 0;
  }
  .successbox{
    border:1px solid #065f46;
    border-left:4px solid #10b981;
    border-radius:10px;
    padding:10px;
    background:#0a1f1a;
    color:#a7f3d0;
    margin:10px 0;
  }
  
  /* ===== CHAIN SELECTION CHIPS ===== */
  .chainchips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{
    border:1px solid #334155;
    border-radius:999px;
    padding:2px 8px;
    display:inline-flex;
    align-items:center;
    gap:6px;
    font-size:13px;
    transition:background 0.2s;
  }
  .chip:hover{background:#1a2332}
  .chip input{accent-color:#60a5fa}
  
  /* ===== TAB NAVIGATION ===== */
  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .tabbtn{
    padding:8px 12px;
    border-radius:999px;
    border:1px solid var(--line);
    background:#0b1220;
    cursor:pointer;
    font-size:14px;
    font-weight:600;
    transition:all 0.2s;
  }
  .tabbtn:hover{background:#1a2332}
  .tabbtn.active{
    background:linear-gradient(180deg,#2563eb,#1d4ed8);
    border:0;
    color:white;
  }
  .tabsec{display:none}
  .tabsec.active{display:block}
  
  /* ===== TABLES ===== */
  /* Styled data tables with hover effects */
  .table{
    width:100%;
    border-collapse:collapse;
    font-size:13px;
    background:#0a0f1a;
  }
  .table th{
    background:#1a2332;
    padding:8px;
    text-align:left;
    border-bottom:2px solid var(--line);
    font-weight:600;
    position:sticky;
    top:0;
    z-index:1;
  }
  .table td{
    padding:6px 8px;
    border-bottom:1px solid #0f172a;
  }
  .table tr:hover{background:#0f1829}
  .table-container{
    max-height:400px;
    overflow-y:auto;
    border:1px solid var(--line);
    border-radius:8px;
    margin-top:8px;
  }
  
  /* ===== METRIC CARDS ===== */
  /* Grid layout for displaying key metrics */
  .metric-grid{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(180px,1fr));
    gap:12px;
    margin:12px 0;
  }
  .metric-card{
    background:#0a0f1a;
    border:1px solid var(--line);
    border-radius:8px;
    padding:12px;
    text-align:center;
  }
  .metric-value{
    font-size:24px;
    font-weight:700;
    color:var(--accent);
    margin-bottom:4px;
  }
  .metric-label{
    font-size:12px;
    color:var(--muted);
  }
  
  /* ===== BADGES ===== */
  .badge{
    display:inline-block;
    padding:2px 8px;
    border-radius:999px;
    font-size:11px;
    font-weight:600;
  }
  .badge-blue{background:#1e3a8a;color:#93c5fd}
  .badge-green{background:#065f46;color:#6ee7b7}
  .badge-red{background:#7f1d1d;color:#fca5a5}
  .badge-yellow{background:#78350f;color:#fcd34d}
  
  /* ===== UTILITY CLASSES ===== */
  .muted{color:var(--muted)}
  .small{font-size:12px;color:var(--muted)}
  .kbd{
    font-family:var(--mono);
    font-size:12px;
    background:#0a0f1a;
    border:1px solid #334155;
    border-radius:6px;
    padding:2px 6px;
  }
  
  /* ===== FOOTER ===== */
  footer{
    padding:18px 16px;
    color:var(--muted);
    text-align:center;
    font-size:13px;
  }
  
  /* ===== ENERGY VISUALIZATION BAR ===== */
  .energy-bar{
    display:flex;
    height:24px;
    border-radius:6px;
    overflow:hidden;
    margin:6px 0;
  }
  .energy-segment{
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:10px;
    font-weight:600;
    color:white;
    transition:flex 0.3s;
  }
  
  /* ===== LEGEND ===== */
  .legend{
    display:flex;
    gap:12px;
    flex-wrap:wrap;
    margin:8px 0;
    font-size:12px;
  }
  .legend-item{
    display:flex;
    align-items:center;
    gap:6px;
  }
  .legend-color{
    width:16px;
    height:16px;
    border-radius:3px;
  }
</style>
</head>
<body>

<!-- ===== MAIN HEADER ===== -->
<header>
  <div class="wrap">
    <h1>🧬 Comprehensive Molecular Docking Suite</h1>
    <p class="lead">
      Advanced in-browser platform: Antibody-Antigen docking • Batch ligand screening (50 SMILES vs 2-3 PDBs) • 
      Detailed enthalpy calculations • QA registry • Session management • Reproducible exports
    </p>
    
    <!-- Tab navigation for different docking modes -->
    <div class="tabs">
      <button class="tabbtn active" data-tab="dockTab">🧷 Antibody Docking</button>
      <button class="tabbtn" data-tab="ligTab">🧪 Ligand Docking</button>
      <button class="tabbtn" data-tab="screenTab">📚 Batch Screening</button>
      <button class="tabbtn" data-tab="qaTab">✅ QA & Registry</button>
      <button class="tabbtn" data-tab="analysisTab">📊 Analysis</button>
      <button class="tabbtn" data-tab="aboutTab">ℹ️ About</button>
    </div>
    
    <!-- Global controls -->
    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnDemo">🎯 Load Demo & Dock</button>
      <button class="btn green" id="btnSaveSession">💾 Save Session</button>
      <button class="btn purple" id="btnLoadSession">📂 Load Session</button>
      <span class="pill" id="statusPill">idle</span>
      <progress id="prog" value="0" max="1"></progress>
    </div>
  </div>
</header>

<!-- ===== ANTIBODY-ANTIGEN DOCKING SECTION ===== -->
<section id="dockTab" class="tabsec active">
  <div class="wrap grid">
    <!-- Protein input panel -->
    <div class="card">
      <h2>1️⃣ Load Proteins</h2>
      <div class="row small muted">
        Upload PDB files or paste text. After parsing, select chains using checkboxes below.
        <span class="pill">Tip: Demo button loads example structures</span>
      </div>
      
      <div class="row" style="margin-top:8px">
        <!-- Protein A input -->
        <div style="min-width:300px;flex:1">
          <h3>Protein A (Antibody) <span class="badge badge-blue" id="badgeA">0 atoms</span></h3>
          <div class="row">
            <input type="file" id="pdbAFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('A')">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('A')">Fetch PDB ID</button>
          </div>
          <textarea id="pdbAText" placeholder="Paste PDB text for Protein A or upload file"></textarea>
          <div class="row">
            <label>Chains:</label>
            <div id="chainsABox" class="chainchips"></div>
          </div>
          <div id="chainWarnA" class="infobox small">Parse first to populate chain selection.</div>
          <div class="row">
            <button class="btn" onclick="parseOne('A')">🔎 Parse A</button>
            <button class="btn" onclick="selectAllChains('A')">Select All</button>
            <button class="btn" onclick="invertChains('A')">Invert</button>
          </div>
        </div>
        
        <!-- Protein B input -->
        <div style="min-width:300px;flex:1">
          <h3>Protein B (Antigen) <span class="badge badge-green" id="badgeB">0 atoms</span></h3>
          <div class="row">
            <input type="file" id="pdbBFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('B')">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('B')">Fetch PDB ID</button>
          </div>
          <textarea id="pdbBText" placeholder="Paste PDB text for Protein B or upload file"></textarea>
          <div class="row">
            <label>Chains:</label>
            <div id="chainsBBox" class="chainchips"></div>
          </div>
          <div id="chainWarnB" class="infobox small">Parse first to populate chain selection.</div>
          <div class="row">
            <button class="btn" onclick="parseOne('B')">🔎 Parse B</button>
            <button class="btn" onclick="selectAllChains('B')">Select All</button>
            <button class="btn" onclick="invertChains('B')">Invert</button>
          </div>
        </div>
      </div>
      
      <details style="margin-top:12px">
        <summary><b>Input Format Guidelines</b></summary>
        <div class="small" style="padding:8px 0">
          <p><b>Supported formats:</b> Standard PDB text, gzipped PDB files (.pdb.gz)</p>
          <p><b>Fetch from RCSB:</b> Click "Fetch PDB ID" to download structures directly from the Protein Data Bank</p>
          <p><b>Chain selection:</b> After parsing, use checkboxes to select specific chains for docking</p>
          <p><b>Visualization:</b> Cartoon rendering requires backbone atoms (N, CA, C, O); stick rendering always available</p>
        </div>
      </details>
    </div>
    
    <!-- Docking parameters panel -->
    <div class="card">
      <h2>2️⃣ Docking Parameters</h2>
      
      <!-- Basic parameters -->
      <h4>Sampling Parameters</h4>
      <div class="row">
        <label>Samples</label>
        <input type="number" id="samples" value="10000" min="1000" step="500" title="Number of random orientations to sample" />
        
        <label>Max Translation (Å)</label>
        <input type="number" id="maxTrans" value="12" min="0" step="1" title="Maximum distance from origin for protein B center" />
        
        <label>Atom Set</label>
        <select id="atomMode" title="Which atoms to use for sampling">
          <option value="CA">Cα only (fastest)</option>
          <option value="BB">Backbone atoms</option>
          <option value="HEAVY">All heavy atoms</option>
        </select>
      </div>
      
      <!-- Scoring parameters -->
      <h4 style="margin-top:12px">Scoring Parameters</h4>
      <div class="row">
        <label>Contact Cutoff (Å)</label>
        <input type="number" id="contactCut" value="4.8" step="0.1" min="3" max="8" />
        
        <label>Clash Factor</label>
        <input type="number" id="clashFactor" value="0.85" step="0.05" min="0.5" max="1.2" title="Multiplier for van der Waals radii" />
        
        <label>Contact Weight</label>
        <input type="number" id="wContact" value="1.0" step="0.1" />
        
        <label>Clash Penalty</label>
        <input type="number" id="wClash" value="6.0" step="0.1" />
        
        <label>Softness</label>
        <input type="number" id="soft" value="0.5" step="0.1" min="0" max="2" />
      </div>
      
      <!-- Output parameters -->
      <h4 style="margin-top:12px">Output & Diversity</h4>
      <div class="row">
        <label>Top Poses</label>
        <input type="number" id="topN" value="12" min="1" max="50" />
        
        <label>Rescore Mode</label>
        <select id="rescoreMode" title="Refine top poses with full heavy atom scoring">
          <option value="NONE">Skip rescoring</option>
          <option value="HEAVY">Heavy atoms</option>
          <option value="HEAVY_REFINE">Heavy + micro-optimize</option>
        </select>
        
        <label>Random Seed</label>
        <input type="number" id="seed" value="42" title="For reproducibility" />
      </div>
      
      <div class="row">
        <label>Diversity Filter (°/Å)</label>
        <input type="number" id="dupAngle" value="12" step="1" min="5" max="30" title="Min rotation difference" />
        <input type="number" id="dupTrans" value="2" step="0.5" min="0.5" max="5" title="Min translation difference" />
      </div>
      
      <!-- Action buttons -->
      <div class="row" style="margin-top:12px">
        <button class="btn primary" id="dockBtn">▶️ Run Docking</button>
        <button class="btn red" id="cancelBtn" disabled>✖ Cancel</button>
        <button class="btn orange" id="resetBtn">🔄 Reset</button>
      </div>
      
      <div class="infobox small" style="margin-top:8px">
        <b>Scoring Function:</b> Score = (contacts × w<sub>contact</sub>) − (clashes × w<sub>clash</sub>)
        <br>Heavy rescoring provides more accurate rankings using all non-hydrogen atoms.
      </div>
    </div>
  </div>
</section>

<!-- ===== ANTIBODY DOCKING RESULTS ===== -->
<section class="tabsec active" id="dockResults">
  <div class="wrap grid">
    <!-- 3D viewer panel -->
    <div class="card">
      <h2>3️⃣ 3D Visualization & Results</h2>
      <div id="viewer"></div>
      
      <!-- Pose selection controls -->
      <div class="row" style="margin-top:8px;flex-wrap:wrap" id="poseControls"></div>
      
      <!-- Overlay toggles -->
      <div class="row" style="margin-top:8px">
        <label class="chip"><input type="checkbox" id="toggleContacts" checked> Contact Lines</label>
        <label class="chip"><input type="checkbox" id="toggleHB" checked> H-bonds</label>
        <label class="chip"><input type="checkbox" id="toggleSB" checked> Salt Bridges</label>
        <label class="chip"><input type="checkbox" id="toggleHydro"> Hydrophobic</label>
      </div>
      
      <!-- Score display -->
      <div class="score" id="scoreBox" style="margin-top:8px"></div>
      
      <!-- Export buttons -->
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnAllPDB">⬇ All Poses PDB</button>
        <button class="btn green" id="btnCurrentPDB">⬇ Current PDB</button>
        <button class="btn" id="btnCSV">⬇ CSV Summary</button>
        <button class="btn" id="btnJSON">⬇ Detailed JSON</button>
        <button class="btn purple" id="btnPNG">📸 PNG</button>
      </div>
    </div>
    
    <!-- Metrics panel -->
    <div class="card">
      <h2>Interface Metrics & Enthalpy</h2>
      
      <!-- Key metrics display -->
      <div class="metric-grid" id="metricsDisplay"></div>
      
      <h4 style="margin-top:12px">Interaction Types</h4>
      <div class="small">
        <p><b>Contacts:</b> Atom pairs within cutoff distance (favorable van der Waals)</p>
        <p><b>H-bonds:</b> N…O pairs < 3.5 Å (geometric approximation)</p>
        <p><b>Salt Bridges:</b> Charged residue pairs (Asp/Glu ↔ Lys/Arg/His) < 4.0 Å</p>
        <p><b>Hydrophobic:</b> C…C contacts < 4.5 Å between hydrophobic residues</p>
        <p><b>Electrostatics:</b> Residue-level Coulomb interactions (k<sub>elec</sub> × q₁q₂/r)</p>
      </div>
      
      <h4 style="margin-top:12px">Energy Parameters</h4>
      <div class="row">
        <label>k<sub>elec</sub></label>
        <input type="number" id="kElec" value="0.5" step="0.1" />
        
        <label>Elec Cutoff (Å)</label>
        <input type="number" id="elecCut" value="12" step="0.5" />
        
        <label>Desolv Weight</label>
        <input type="number" id="wDesolv" value="0.2" step="0.1" />
      </div>
      
      <div class="infobox small" style="margin-top:12px">
        <b>Enthalpy Estimation:</b> ΔH ≈ −(contacts × 0.5) − (H-bonds × 2.5) − (salt bridges × 4.0) 
        − (hydrophobic × 1.0) + (clash penalty × 0.3) + (electrostatic repulsion) + (desolvation penalty)
        <br><br>
        Values are in kcal/mol and represent approximate binding enthalpies for educational purposes.
        For publication-quality results, export structures and analyze with dedicated force fields.
      </div>
      
      <div class="infobox small">
        <b>Reproducibility:</b> All outputs include parameters and random seed for exact replication.
        <b>Disclaimer:</b> Educational tool with no warranties. Validate results independently.
      </div>
    </div>
  </div>
</section>

<!-- ===== LIGAND DOCKING SECTION ===== -->
<section id="ligTab" class="tabsec">
  <div class="wrap grid">
    <div class="card">
      <h2>🧪 Single Ligand Docking</h2>
      <div class="small muted" style="margin-bottom:8px">
        Dock a single SMILES string against a receptor PDB. Note: SMILES→3D conversion here uses 
        simplified geometry generation for demonstration. For production work, prepare ligands with RDKit or Open Babel.
      </div>
      
      <div class="row">
        <!-- Receptor input -->
        <div style="min-width:300px;flex:1">
          <h3>Receptor PDB</h3>
          <textarea id="ligReceptorPDB" placeholder="Paste receptor PDB structure"></textarea>
          <div class="row" style="margin-top:6px">
            <button class="btn" onclick="loadLigandDemoReceptor()">Load Example</button>
            <button class="btn" onclick="parseReceptorForLigand()">Parse & Preview</button>
          </div>
        </div>
        
        <!-- Ligand input -->
        <div style="min-width:300px;flex:1">
          <h3>Ligand SMILES</h3>
          <textarea id="ligSmiles" placeholder="e.g., CC(=O)Oc1ccccc1C(=O)O (aspirin)"></textarea>
          <div class="row" style="margin-top:6px">
            <label>3D Method</label>
            <select id="ligEmbedMethod">
              <option value="HASH">HashCloud (seeded)</option>
              <option value="HELIX">RingHelix (seeded)</option>
            </select>
            
            <label>Seed</label>
            <input type="number" id="ligSeed" value="1337" style="width:90px" />
            
            <button class="btn primary" onclick="runSingleLigandDock()">▶️ Dock</button>
          </div>
        </div>
      </div>
      
      <div class="infobox small">
        <b>3D Generation Methods:</b>
        <br>• <b>HashCloud:</b> Generates coordinates using hash-based random walk (reproducible with seed)
        <br>• <b>RingHelix:</b> Creates helical arrangement suitable for ring-containing molecules
        <br>Both methods are educational approximations. Export docked poses and optimize with quantum chemistry or force field methods.
      </div>
    </div>
    
    <div class="card">
      <h2>Ligand Docking Result</h2>
      <div id="viewerLig"></div>
      
      <div class="score" id="ligScore" style="margin-top:8px"></div>
      
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnLigPDB">⬇ Complex PDB</button>
        <button class="btn" id="btnLigCSV">⬇ CSV Result</button>
        <span class="pill" id="ligStatus">idle</span>
      </div>
    </div>
  </div>
</section>

<!-- ===== BATCH SCREENING SECTION ===== -->
<section id="screenTab" class="tabsec">
  <div class="wrap">
    <div class="card">
      <h2>📚 Batch Ligand Screening</h2>
      <div class="small muted" style="margin-bottom:12px">
        Screen up to 50 SMILES structures against 2-3 receptor PDBs. Each SMILES is docked against each receptor,
        and binding enthalpy (ΔH) is calculated for every complex. Results include contact analysis, H-bonds, 
        electrostatics, and estimated free energy contributions.
      </div>
      
      <div class="grid grid-3" style="gap:12px">
        <!-- SMILES library input -->
        <div>
          <h3>SMILES Library (max 50)</h3>
          <textarea id="scrSmiles" placeholder="Enter one SMILES per line:
CCO
CCN
c1ccccc1
C1CCCCC1C(=O)O
CC(=O)Oc1ccccc1C(=O)O
..." style="min-height:200px"></textarea>
          <div class="small muted">One SMILES per line. Empty lines ignored.</div>
        </div>
        
        <!-- Receptor library input -->
        <div>
          <h3>Receptors (2-3 PDBs)</h3>
          <textarea id="scrReceptors" placeholder="Paste receptor PDBs separated by END:

ATOM    1  N   ALA A   1      ...
...
END

ATOM    1  N   ALA B   1      ...
...
END" style="min-height:200px"></textarea>
          <div class="small muted">Separate each PDB with 'END'. Max 3 receptors.</div>
        </div>
        
        <!-- Screening parameters -->
        <div>
          <h3>Parameters</h3>
          <div class="row">
            <label>Samples/Ligand</label>
            <input type="number" id="scrSamples" value="5000" min="1000" step="500" />
          </div>
          <div class="row">
            <label>Contact (Å)</label>
            <input type="number" id="scrContactCut" value="4.8" step="0.1" />
          </div>
          <div class="row">
            <label>Clash Factor</label>
            <input type="number" id="scrClashFactor" value="0.85" step="0.05" />
          </div>
          <div class="row">
            <label>Seed</label>
            <input type="number" id="scrSeed" value="777" />
          </div>
          <div class="row">
            <label>3D Method</label>
            <select id="scrEmbedMethod">
              <option value="HASH">HashCloud</option>
              <option value="HELIX">RingHelix</option>
            </select>
          </div>
          
          <div class="row" style="margin-top:12px">
            <button class="btn primary" id="btnStartScreen">▶️ Start Screening</button>
            <button class="btn red" id="btnStopScreen" disabled>✖ Stop</button>
          </div>
          
          <div class="infobox small" style="margin-top:8px">
            Screening runs sequentially: SMILES₁ vs Receptor₁, SMILES₁ vs Receptor₂, SMILES₂ vs Receptor₁, etc.
            Progress updates after each docking completion.
          </div>
        </div>
      </div>
    </div>
    
    <!-- Screening results table -->
    <div class="card">
      <h2>Screening Results & Enthalpies</h2>
      
      <div class="row" style="margin-bottom:8px">
        <button class="btn green" id="btnScrCSV">⬇ Full Results CSV</button>
        <button class="btn" id="btnScrJSON">⬇ JSON Export</button>
        <button class="btn purple" id="btnScrTop10">📊 Show Top 10</button>
        <span class="pill" id="scrStatus">idle</span>
        <span class="small muted" id="scrProgress"></span>
      </div>
      
      <div class="table-container" style="max-height:500px">
        <table class="table" id="scrTable">
          <thead>
            <tr>
              <th onclick="sortScreeningResults('index')">#</th>
              <th onclick="sortScreeningResults('receptor')">Receptor</th>
              <th onclick="sortScreeningResults('smiles')">SMILES</th>
              <th onclick="sortScreeningResults('score')">Score ▼</th>
              <th onclick="sortScreeningResults('contacts')">Contacts</th>
              <th onclick="sortScreeningResults('hb')">H-bonds</th>
              <th onclick="sortScreeningResults('sb')">Salt Br.</th>
              <th onclick="sortScreeningResults('clash')">Clash</th>
              <th onclick="sortScreeningResults('enthalpy')">ΔH (kcal/mol)</th>
            </tr>
          </thead>
          <tbody id="scrTableBody"></tbody>
        </table>
      </div>
      
      <!-- Selected pose viewer -->
      <div id="viewerScr" style="height:420px;margin-top:12px"></div>
      <div class="small muted" style="text-align:center;margin-top:4px">
        Click any row to visualize that docked pose
      </div>
    </div>
    
    <!-- Enthalpy distribution analysis -->
    <div class="card">
      <h2>Enthalpy Distribution Analysis</h2>
      <div class="metric-grid" id="screenMetrics"></div>
      
      <h4>Energy Component Breakdown</h4>
      <div id="enthalpyBreakdown"></div>
      
      <div class="infobox small">
        <b>Interpreting ΔH values:</b>
        <br>• More negative = stronger predicted binding
        <br>• ΔH < −10 kcal/mol: Strong binder candidate
        <br>• ΔH −5 to −10 kcal/mol: Moderate affinity
        <br>• ΔH > −5 kcal/mol: Weak or non-binder
        <br><br>
        These are approximate enthalpies. Entropic contributions (−TΔS) not included. 
        For ΔG predictions, consider rotational/translational entropy losses (~10-15 kcal/mol) and 
        conformational penalties.
      </div>
    </div>
  </div>
</section>

<!-- ===== QA & REGISTRY SECTION ===== -->
<section id="qaTab" class="tabsec">
  <div class="wrap grid">
    <div class="card">
      <h2>📋 Run Registry & Session Management</h2>
      <div class="small muted">
        Save complete docking runs with all parameters, structures, and results for reproducibility.
        Export/import sessions to share configurations or restore previous work.
      </div>
      
      <div class="row" style="margin-top:8px">
        <button class="btn green" onclick="saveCurrentRun()">💾 Save Current Run</button>
        <button class="btn" onclick="refreshRunRegistry()">🔄 Refresh List</button>
        <button class="btn" onclick="exportAllRuns()">⬇ Export Registry</button>
        <button class="btn purple" onclick="importRunRegistry()">⬆ Import Registry</button>
        <button class="btn red" onclick="clearRunRegistry()">🗑️ Clear All</button>
      </div>
      <input type="file" id="importRegistryFile" accept=".json" style="display:none" />
      
      <div class="table-container" style="margin-top:12px">
        <table class="table">
          <thead>
            <tr>
              <th>Timestamp</th>
              <th>Type</th>
              <th>Description</th>
              <th>Top Score</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody id="registryTableBody"></tbody>
        </table>
      </div>
    </div>
    
    <div class="card">
      <h2>✅ Quality Assurance Mode</h2>
      <div class="small muted">
        Test reproducibility by running the same docking multiple times with identical parameters.
        Verifies that random seed produces consistent results.
      </div>
      
      <div class="row" style="margin-top:8px">
        <label>Repeat Count</label>
        <input type="number" id="qaRepeats" value="3" min="2" max="10" style="width:80px" />
        
        <label>Score Tolerance</label>
        <input type="number" id="qaTolerance" value="0.01" step="0.01" style="width:80px" />
        
        <button class="btn primary" onclick="runQATest()">▶️ Run QA Test</button>
      </div>
      
      <div class="score" id="qaResults" style="margin-top:12px;min-height:100px"></div>
      
      <div class="infobox small" style="margin-top:8px">
        <b>QA Test Process:</b>
        <br>1. Captures current docking parameters
        <br>2. Runs docking N times with same seed
        <br>3. Compares top scores across runs
        <br>4. Reports if variance exceeds tolerance
        <br><br>
        Pass criterion: All top scores within tolerance. This confirms deterministic behavior.
      </div>
    </div>
  </div>
</section>

<!-- ===== ANALYSIS SECTION ===== -->
<section id="analysisTab" class="tabsec">
  <div class="wrap">
    <div class="card">
      <h2>📊 Advanced Analysis Tools</h2>
      
      <div class="tabs" style="margin-top:8px">
        <button class="tabbtn active" data-subtab="energyTab">Energy Decomposition</button>
        <button class="tabbtn" data-subtab="compareTab">Pose Comparison</button>
        <button class="tabbtn" data-subtab="residueTab">Residue Contacts</button>
      </div>
      
      <!-- Energy decomposition subtab -->
      <div id="energyTab" class="tabsec active" style="margin-top:12px">
        <h3>Energy Component Analysis</h3>
        <div class="small muted">
          Breakdown of scoring contributions for the currently displayed pose.
          Values show relative weights of different interaction types.
        </div>
        
        <div id="energyComponents"></div>
        
        <h4 style="margin-top:16px">Enthalpy Calculation Details</h4>
        <div class="score" id="enthalpyDetail"></div>
      </div>
      
      <!-- Pose comparison subtab -->
      <div id="compareTab" class="tabsec" style="margin-top:12px">
        <h3>Compare Multiple Poses</h3>
        <div class="row">
          <label>Pose 1:</label>
          <select id="comparePose1"></select>
          
          <label>Pose 2:</label>
          <select id="comparePose2"></select>
          
          <button class="btn primary" onclick="comparePoses()">Compare</button>
        </div>
        
        <div class="grid" style="margin-top:12px;grid-template-columns:1fr 1fr">
          <div>
            <h4>Pose 1</h4>
            <div id="viewerComp" style="height:400px"></div>
          </div>
          <div>
            <h4>Comparison Metrics</h4>
            <div class="score" id="comparisonResults"></div>
          </div>
        </div>
      </div>
      
      <!-- Residue contacts subtab -->
      <div id="residueTab" class="tabsec" style="margin-top:12px">
        <h3>Residue-Level Interaction Analysis</h3>
        <div class="row">
          <label>Min Distance (Å):</label>
          <input type="number" id="filterMinDist" value="0" step="0.5" style="width:80px" />
          
          <label>Max Distance (Å):</label>
          <input type="number" id="filterMaxDist" value="6" step="0.5" style="width:80px" />
          
          <button class="btn" onclick="filterResidueContacts()">Filter</button>
          <button class="btn green" onclick="exportResidueData()">⬇ Export</button>
        </div>
        
        <div class="table-container" style="margin-top:8px">
          <table class="table">
            <thead>
              <tr>
                <th>Residue A</th>
                <th>Chain A</th>
                <th>Residue B</th>
                <th>Chain B</th>
                <th>Distance (Å)</th>
                <th>Type</th>
                <th>Energy Contrib</th>
              </tr>
            </thead>
            <tbody id="residueTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- ===== ABOUT SECTION ===== -->
<section id="aboutTab" class="tabsec">
  <div class="wrap">
    <div class="card">
      <h2>About This Platform</h2>
      
      <h3>Purpose & Scope</h3>
      <p>
        This is an educational molecular docking platform designed to demonstrate computational biology concepts 
        in an accessible, browser-based environment. All computations run locally using JavaScript and Web Workers—no 
        data is sent to external servers. The platform combines protein-protein docking (antibody-antigen), 
        small molecule docking, and batch virtual screening capabilities.
      </p>
      
      <h3>Key Features</h3>
      <div class="small">
        <p><b>• Antibody-Antigen Docking:</b> Rigid-body docking with parallel sampling across multiple CPU cores</p>
        <p><b>• Batch Screening:</b> Screen up to 50 SMILES against 2-3 receptor structures with enthalpy calculations</p>
        <p><b>• Scoring Function:</b> Van der Waals-aware contact scoring with clash detection, H-bond detection, salt bridge identification, and electrostatic contributions</p>
        <p><b>• Enthalpy Estimation:</b> Approximate binding enthalpies (ΔH) using weighted energy terms</p>
        <p><b>• Reproducibility:</b> All results include parameter snapshots and random seeds for exact replication</p>
        <p><b>• Quality Assurance:</b> Built-in QA mode tests reproducibility across multiple runs</p>
        <p><b>• Session Management:</b> Save and restore complete docking sessions with all data</p>
      </div>
      
      <h3>Technical Details</h3>
      <div class="small">
        <p><b>Sampling:</b> Uniform random sampling of SO(3) rotations using quaternions, with random translations within specified radius</p>
        <p><b>Scoring:</b> Grid-accelerated contact detection, soft-core van der Waals potential for clashes, geometric H-bond and salt bridge detection</p>
        <p><b>Parallelization:</b> Web Workers distribute sampling across available CPU cores (typically 4-8 workers)</p>
        <p><b>Visualization:</b> 3Dmol.js library for interactive molecular graphics with cartoon, stick, and surface representations</p>
        <p><b>File Formats:</b> Standard PDB for proteins, SMILES for ligands (with simplified 3D generation)</p>
      </div>
      
      <h3>Enthalpy Calculation Methodology</h3>
      <p>
        The binding enthalpy (ΔH) is estimated using a weighted sum of interaction energy terms:
      </p>
      <div class="score">
ΔH ≈ −0.5 × (favorable contacts)
     −2.5 × (hydrogen bonds)
     −4.0 × (salt bridges)
     −1.0 × (hydrophobic contacts)
     +0.3 × (clash penalty)
     +1.0 × (electrostatic repulsion)
     +0.2 × (desolvation penalty)

Units: kcal/mol

These weights are derived from statistical analysis of experimental 
binding data but represent approximations for educational use.
      </div>
      
      <h3>Important Limitations & Disclaimers</h3>
      <div class="errorbox">
        <p><b>⚠️ This is an educational tool, not a production docking platform.</b></p>
        <p>
          • Scoring function is simplified and lacks many physical terms (solvation, entropy, polarization, etc.)
          <br>• Rigid-body docking does not account for conformational changes or induced fit
          <br>• SMILES-to-3D conversion uses simplified geometry—use RDKit/Open Babel for real work
          <br>• Enthalpy values are approximate and exclude entropic contributions to free energy
          <br>• Results should be validated with established docking platforms (AutoDock, HADDOCK, Rosetta)
          <br>• No warranties provided—use at your own risk for research exploration only
        </p>
      </div>
      
      <h3>Recommended Workflow for Research</h3>
      <div class="small">
        <p>1. Use this platform for initial exploration and hypothesis generation</p>
        <p>2. Export top-ranked structures as PDB files</p>
        <p>3. Refine with professional docking software (AutoDock Vina, HADDOCK, ClusPro, ZDOCK)</p>
        <p>4. Perform molecular dynamics simulations to assess stability</p>
        <p>5. Calculate free energies with MM-PBSA or FEP methods</p>
        <p>6. Validate experimentally (SPR, ITC, X-ray crystallography, etc.)</p>
      </div>
      
      <h3>Credits & Dependencies</h3>
      <div class="small">
        <p><b>• 3Dmol.js:</b> Molecular visualization library (Nicholas Rego and David Koes)</p>
        <p><b>• Pako:</b> Zlib compression for gzipped PDB files</p>
        <p><b>• Web Workers API:</b> Parallel computation in browser</p>
        <p><b>• RCSB PDB:</b> Protein structure database</p>
      </div>
      
      <div class="infobox small" style="margin-top:12px">
        <b>License & Usage:</b> This code is provided for educational purposes. 
        Feel free to adapt and extend for your own learning. For any serious research applications, 
        please use validated computational chemistry platforms and cite appropriate literature.
      </div>
    </div>
  </div>
</section>

<!-- ===== FOOTER ===== -->
<footer>
  <div class="wrap">
    <p>All computations execute locally in your browser. No data transmitted to servers.</p>
    <p class="small">© Educational Tool • No Warranties • Validate Results Independently</p>
  </div>
</footer>

<!-- ===== EXTERNAL LIBRARIES ===== -->
<!-- Load 3Dmol.js for molecular visualization and Pako for gzip decompression -->
<script defer src="https://unpkg.com/3dmol@2.4.2/build/3Dmol-min.js"></script>
<script defer src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

<script>
// ========================================================================================
// GLOBAL STATE MANAGEMENT
// ========================================================================================
/**
 * This section declares all global variables used throughout the application.
 * Using descriptive names and grouping related variables helps maintain code clarity.
 */

// 3D Molecular Viewers (one for each visualization context)
let viewer = null;           // Main antibody-antigen viewer
let viewerLig = null;        // Single ligand docking viewer
let viewerScr = null;        // Batch screening viewer
let viewerComp = null;       // Pose comparison viewer

// Docking State Flags
let inProgress = false;      // True when docking calculation is running
let cancelled = false;       // True when user cancels docking
let workerPool = [];         // Array of Web Workers for parallel computation

// Protein Data Structures
let pdbAAllAtoms = [];       // Complete parsed structure for Protein A
let pdbBAllAtoms = [];       // Complete parsed structure for Protein B
let currentA = null;         // Heavy atom set for current visualization (Protein A)
let currentB0 = null;        // Heavy atom set for current visualization (Protein B, unposed)
let heavyUsed = false;       // Flag indicating whether heavy atom rescoring was applied

// Pose Data
let posesTop = [];           // Array of top-ranked poses after filtering
let currentPose = null;      // Currently displayed pose object
let currentPoseIndex = -1;   // Index of current pose in posesTop array

// Interaction Data for Current Pose
let currentContacts = [];    // Array of contact pair coordinates {x1,y1,z1,x2,y2,z2}
let currentHB = [];          // Array of hydrogen bond pair coordinates
let currentSB = [];          // Array of salt bridge pair coordinates
let currentHydro = [];       // Array of hydrophobic contact coordinates

// Ligand Docking Results
let ligLastResult = {};      // Stores last ligand docking result with PDB and CSV data

// Batch Screening State
let screenCancel = false;    // Flag to cancel screening run
let screenResults = [];      // Array of screening result objects
let screenReceptors = [];    // Array of parsed receptor structures for screening
let screenCurrentSort = 'score'; // Current sort column for screening table

// Session Management
let sessionHistory = [];     // Array of saved docking runs
const REGISTRY_KEY = 'docking_registry_v1'; // LocalStorage key for run registry

// ========================================================================================
// PHYSICAL CONSTANTS & LOOKUP TABLES
// ========================================================================================
/**
 * Van der Waals radii for common atoms (in Angstroms).
 * These values are used for clash detection and contact scoring.
 * Source: Bondi, A. (1964) J. Phys. Chem. 68, 441-451.
 */
const vdw = {
  H: 1.2,    // Hydrogen
  C: 1.7,    // Carbon
  N: 1.55,   // Nitrogen
  O: 1.52,   // Oxygen
  S: 1.8,    // Sulfur
  P: 1.8,    // Phosphorus
  F: 1.47,   // Fluorine
  CL: 1.75,  // Chlorine
  BR: 1.85,  // Bromine
  I: 1.98    // Iodine
};

/**
 * Set of three-letter codes for hydrophobic amino acids.
 * Used for detecting hydrophobic contacts at the interface.
 */
const hydrophobic = new Set([
  'ALA', 'VAL', 'LEU', 'ILE', 'PRO', 
  'PHE', 'MET', 'TRP', 'TYR', 'CYS'
]);

/**
 * Mapping of residue names to formal charges.
 * Used for electrostatic energy calculations.
 */
const residueCharges = {
  'ASP': -1,   // Aspartic acid (acidic)
  'GLU': -1,   // Glutamic acid (acidic)
  'LYS': +1,   // Lysine (basic)
  'ARG': +1,   // Arginine (basic)
  'HIS': +0.1  // Histidine (weakly basic, protonation state dependent)
};

// ========================================================================================
// DOM UTILITY FUNCTIONS
// ========================================================================================
/**
 * Short helper functions for common DOM operations.
 * These make the code more readable by reducing repetition.
 */

// Get element by ID (shorthand for document.getElementById)
const E = id => document.getElementById(id);

// Update status pill text
const status = text => { E('statusPill').textContent = text; };

// Update progress bar (value between 0 and 1)
const setProgress = fraction => { 
  E('prog').value = Math.max(0, Math.min(1, fraction || 0)); 
};

// ========================================================================================
// INITIALIZATION & EVENT BINDING
// ========================================================================================
/**
 * Wait for DOM to be fully loaded, then initialize the application.
 * This includes creating viewers, binding event listeners, and running the auto-demo.
 */
window.addEventListener('DOMContentLoaded', () => {
  console.log('Initializing Comprehensive Docking Suite...');
  
  // Initialize all 3D molecular viewers
  ensureViewer('viewer');
  ensureViewer('viewerLig');
  ensureViewer('viewerScr');
  ensureViewer('viewerComp');
  
  // Draw placeholder spheres so users see 3D content immediately
  if (viewer) drawPlaceholder(viewer);
  
  // Set up tab switching for main navigation
  setupMainTabs();
  
  // Set up sub-tabs for analysis section
  setupSubTabs();
  
  // Bind all event listeners for buttons and controls
  bindEventListeners();
  
  // Load any saved session history from browser storage
  loadSessionHistory();
  
  // Run the auto-demo to show functionality immediately on first load
  setTimeout(autoDemo, 100);
  
  console.log('Initialization complete. Ready for docking.');
});

/**
 * Create or retrieve a 3Dmol viewer for the specified container element.
 * @param {string} id - Element ID for the viewer container
 */
function ensureViewer(id) {
  const el = E(id);
  if (!el) return;
  
  // Create the viewer if it doesn't exist yet
  if (id === 'viewer' && !viewer) {
    viewer = $3Dmol.createViewer(el, {backgroundColor: '#0a0f1a'});
  } else if (id === 'viewerLig' && !viewerLig) {
    viewerLig = $3Dmol.createViewer(el, {backgroundColor: '#0a0f1a'});
  } else if (id === 'viewerScr' && !viewerScr) {
    viewerScr = $3Dmol.createViewer(el, {backgroundColor: '#0a0f1a'});
  } else if (id === 'viewerComp' && !viewerComp) {
    viewerComp = $3Dmol.createViewer(el, {backgroundColor: '#0a0f1a'});
  }
  
  // Give the layout a moment to settle before first render
  requestAnimationFrame(() => {
    try {
      if (viewer) viewer.resize();
      if (viewerLig) viewerLig.resize();
      if (viewerScr) viewerScr.resize();
      if (viewerComp) viewerComp.resize();
    } catch(e) {
      console.warn('Viewer resize issue:', e);
    }
  });
}

/**
 * Draw placeholder spheres in a viewer to show 3D capability immediately.
 * @param {Object} v - 3Dmol viewer object
 */
function drawPlaceholder(v) {
  if (!v) return;
  
  // Add two colored spheres at different positions
  v.addSphere({
    center: {x: -8, y: 0, z: 0},
    radius: 4,
    color: '#60a5fa',
    alpha: 0.6
  });
  
  v.addSphere({
    center: {x: 8, y: 0, z: 0},
    radius: 4,
    color: '#f97316',
    alpha: 0.6
  });
  
  v.zoomTo();
  v.render();
}

/**
 * Set up main tab navigation system.
 * Clicking a tab hides all sections and shows the selected one.
 */
function setupMainTabs() {
  document.querySelectorAll('.tabbtn').forEach(btn => {
    btn.addEventListener('click', () => {
      // Only handle main tabs (not sub-tabs)
      if (!btn.dataset.tab) return;
      
      // Update active state for buttons
      document.querySelectorAll('.tabbtn[data-tab]').forEach(b => 
        b.classList.remove('active')
      );
      btn.classList.add('active');
      
      // Show selected section, hide others
      document.querySelectorAll('.tabsec').forEach(section => {
        if (section.id === btn.dataset.tab) {
          section.classList.add('active');
        } else {
          section.classList.remove('active');
        }
      });
      
      // Resize viewers when tab becomes visible
      setTimeout(() => {
        try {
          viewer?.resize();
          viewerLig?.resize();
          viewerScr?.resize();
          viewerComp?.resize();
          viewer?.render();
          viewerLig?.render();
          viewerScr?.render();
          viewerComp?.render();
        } catch(e) {}
      }, 10);
    });
  });
}

/**
 * Set up sub-tab navigation within the analysis section.
 */
function setupSubTabs() {
  document.querySelectorAll('.tabbtn[data-subtab]').forEach(btn => {
    btn.addEventListener('click', () => {
      // Update active state
      document.querySelectorAll('.tabbtn[data-subtab]').forEach(b => 
        b.classList.remove('active')
      );
      btn.classList.add('active');
      
      // Show selected subtab content
      const parent = btn.closest('.card');
      if (!parent) return;
      
      parent.querySelectorAll('.tabsec').forEach(section => {
        if (section.id === btn.dataset.subtab) {
          section.classList.add('active');
        } else {
          section.classList.remove('active');
        }
      });
    });
  });
}

/**
 * Bind all event listeners for UI controls.
 * Organized by functional area for maintainability.
 */
function bindEventListeners() {
  // === Main Control Buttons ===
  E('btnDemo').addEventListener('click', autoDemo);
  E('btnSaveSession').addEventListener('click', saveSession);
  E('btnLoadSession').addEventListener('click', loadSession);
  
  // === Antibody Docking Controls ===
  E('dockBtn').addEventListener('click', runAntibodyDocking);
  E('cancelBtn').addEventListener('click', cancelDocking);
  E('resetBtn').addEventListener('click', resetAll);
  
  // === Antibody Export Buttons ===
  E('btnAllPDB').addEventListener('click', downloadAllPoses);
  E('btnCurrentPDB').addEventListener('click', downloadCurrentPose);
  E('btnCSV').addEventListener('click', downloadCSV);
  E('btnJSON').addEventListener('click', downloadJSON);
  E('btnPNG').addEventListener('click', () => snapshotPNG(viewer));
  
  // === Visualization Toggles ===
  E('toggleContacts').addEventListener('change', refreshOverlays);
  E('toggleHB').addEventListener('change', refreshOverlays);
  E('toggleSB').addEventListener('change', refreshOverlays);
  E('toggleHydro').addEventListener('change', refreshOverlays);
  
  // === File Input Handlers ===
  E('pdbAFile').addEventListener('change', e => handleFileUpload('A', e.target.files[0]));
  E('pdbBFile').addEventListener('change', e => handleFileUpload('B', e.target.files[0]));
  
  // === Ligand Docking Controls ===
  E('btnLigPDB').addEventListener('click', downloadLigandPDB);
  E('btnLigCSV').addEventListener('click', downloadLigandCSV);
  
  // === Screening Controls ===
  E('btnStartScreen').addEventListener('click', startBatchScreening);
  E('btnStopScreen').addEventListener('click', () => {
    screenCancel = true;
    E('btnStopScreen').disabled = true;
  });
  E('btnScrCSV').addEventListener('click', downloadScreeningCSV);
  E('btnScrJSON').addEventListener('click', downloadScreeningJSON);
  E('btnScrTop10').addEventListener('click', showTop10Screening);
  
  console.log('Event listeners bound successfully.');
}

// ========================================================================================
// FILE HANDLING FUNCTIONS
// ========================================================================================
/**
 * Handle file upload for protein structures.
 * @param {string} which - 'A' or 'B' to indicate which protein
 * @param {File} file - The uploaded File object
 */
async function handleFileUpload(which, file) {
  if (!file) return;
  
  try {
    const text = await fileToText(file);
    E(which === 'A' ? 'pdbAText' : 'pdbBText').value = text;
    parseOne(which);
  } catch(err) {
    alert(`Error reading file: ${err.message}`);
  }
}

/**
 * Convert a File object to text, handling gzipped files.
 * @param {File} file - The file to read
 * @returns {Promise<string>} - The file contents as text
 */
async function fileToText(file) {
  const name = file.name.toLowerCase();
  const buffer = await file.arrayBuffer();
  
  // Handle gzipped files using pako library
  if (name.endsWith('.gz')) {
    const u8array = new Uint8Array(buffer);
    const inflated = pako.inflate(u8array);
    return new TextDecoder().decode(inflated);
  }
  
  // Regular text file
  return new TextDecoder().decode(buffer);
}

/**
 * Fetch a PDB structure from RCSB database by ID.
 * @param {string} which - 'A' or 'B' to indicate which protein
 */
async function fetchPDBFromRCSB(which) {
  const pdbId = prompt(`Enter 4-character PDB ID to fetch for Protein ${which}:`);
  if (!pdbId) return;
  
  const id = pdbId.trim().toLowerCase();
  if (id.length !== 4) {
    alert('PDB IDs must be exactly 4 characters (e.g., 1ABC)');
    return;
  }
  
  try {
    status(`fetching ${id}...`);
    const url = `https://files.rcsb.org/download/${id}.pdb`;
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`PDB ${id} not found or server error`);
    }
    
    const text = await response.text();
    E(which === 'A' ? 'pdbAText' : 'pdbBText').value = text;
    await parseOne(which);
    status('idle');
  } catch(err) {
    alert(`Failed to fetch PDB: ${err.message}`);
    status('error');
  }
}

// ========================================================================================
// PDB PARSING FUNCTIONS
// ========================================================================================
/**
 * Parse PDB format text and extract atom records.
 * @param {string} text - PDB formatted text
 * @returns {Array<Object>} - Array of atom objects with coordinates and properties
 */
function parsePDB(text) {
  const atoms = [];
  const lines = text.split(/\r?\n/);
  
  for (const line of lines) {
    // Only process ATOM and HETATM records
    if (!line.startsWith('ATOM') && !line.startsWith('HETATM')) continue;
    
    // Extract fields according to PDB format specification
    // Columns are 1-indexed in PDB format, but 0-indexed in JavaScript
    const atom = {
      name: line.substring(12, 16).trim(),      // Atom name
      resn: line.substring(17, 20).trim(),      // Residue name
      chain: line.substring(21, 22).trim() || 'A', // Chain ID
      resi: parseInt(line.substring(22, 26)),   // Residue number
      x: parseFloat(line.substring(30, 38)),    // X coordinate
      y: parseFloat(line.substring(38, 46)),    // Y coordinate
      z: parseFloat(line.substring(46, 54)),    // Z coordinate
      elem: line.length >= 78 
        ? (line.substring(76, 78).trim() || line.substring(12, 16).trim()[0])
        : line.substring(12, 16).trim()[0]      // Element symbol
    };
    
    atoms.push(atom);
  }
  
  return atoms;
}

/**
 * Parse one protein (A or B) from file or text input.
 * @param {string} which - 'A' or 'B'
 */
async function parseOne(which) {
  const file = E(which === 'A' ? 'pdbAFile' : 'pdbBFile').files[0];
  let text = E(which === 'A' ? 'pdbAText' : 'pdbBText').value.trim();
  
  // Read from file if no pasted text
  if (!text && file) {
    text = await fileToText(file);
    E(which === 'A' ? 'pdbAText' : 'pdbBText').value = text;
  }
  
  if (!text) {
    alert('Please provide PDB text or upload a file first.');
    return;
  }
  
  // Parse the PDB text
  const atoms = parsePDB(text);
  
  if (!atoms.length) {
    alert('No atoms parsed. Please check that this is a valid PDB file.');
    return;
  }
  
  // Store parsed atoms and update UI
  if (which === 'A') {
    pdbAAllAtoms = atoms;
    populateChainChips('A', atoms);
    E('badgeA').textContent = `${atoms.length} atoms`;
  } else {
    pdbBAllAtoms = atoms;
    populateChainChips('B', atoms);
    E('badgeB').textContent = `${atoms.length} atoms`;
  }
}

// ========================================================================================
// CHAIN SELECTION UI
// ========================================================================================
/**
 * Create checkboxes for each chain found in the structure.
 * @param {string} which - 'A' or 'B'
 * @param {Array<Object>} atoms - Parsed atom array
 */
function populateChainChips(which, atoms) {
  const container = which === 'A' ? E('chainsABox') : E('chainsBBox');
  container.innerHTML = '';
  
  // Extract unique chain IDs
  const chains = [...new Set(atoms.map(a => a.chain))];
  
  // Create checkbox for each chain
  chains.forEach(chainId => {
    const id = `${which}_ch_${chainId}`;
    const label = document.createElement('label');
    label.className = 'chip';
    label.innerHTML = `
      <input type="checkbox" id="${id}" data-which="${which}" data-chain="${chainId}" checked>
      ${chainId}
    `;
    container.appendChild(label);
  });
  
  // Update status message
  const warnBox = which === 'A' ? E('chainWarnA') : E('chainWarnB');
  warnBox.className = 'successbox small';
  warnBox.textContent = `✓ Parsed ${atoms.length} atoms • Chains: ${chains.join(', ') || '—'}`;
}

/**
 * Get set of selected chain IDs for a protein.
 * @param {string} which - 'A' or 'B'
 * @returns {Set<string>} - Set of selected chain IDs
 */
function selectedChains(which) {
  const container = which === 'A' ? E('chainsABox') : E('chainsBBox');
  const checkboxes = [...container.querySelectorAll('input[type=checkbox]')];
  const selected = checkboxes.filter(cb => cb.checked).map(cb => cb.dataset.chain);
  return new Set(selected);
}

/**
 * Select all chains for a protein.
 * @param {string} which - 'A' or 'B'
 */
function selectAllChains(which) {
  const container = which === 'A' ? E('chainsABox') : E('chainsBBox');
  container.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = true);
}

/**
 * Invert chain selection (checked becomes unchecked and vice versa).
 * @param {string} which - 'A' or 'B'
 */
function invertChains(which) {
  const container = which === 'A' ? E('chainsABox') : E('chainsBBox');
  container.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = !cb.checked);
}

// ========================================================================================
// GEOMETRY MANIPULATION FUNCTIONS
// ========================================================================================
/**
 * Filter atoms by selected chains.
 * @param {Array<Object>} atoms - All atoms
 * @param {Set<string>} keepChains - Set of chain IDs to keep
 * @returns {Array<Object>} - Filtered atoms
 */
function filterChains(atoms, keepChains) {
  if (!keepChains || keepChains.size === 0) return atoms;
  return atoms.filter(atom => keepChains.has(atom.chain));
}

/**
 * Select subset of atoms based on atom type mode.
 * @param {Array<Object>} atoms - Input atoms
 * @param {string} mode - 'CA', 'BB', or 'HEAVY'
 * @returns {Array<Object>} - Filtered atoms
 */
function selectAtomSet(atoms, mode) {
  const backbone = new Set(['N', 'CA', 'C', 'O']);
  
  return atoms.filter(atom => {
    if (mode === 'CA') return atom.name === 'CA';
    if (mode === 'BB') return backbone.has(atom.name);
    return atom.elem !== 'H';  // HEAVY mode: all non-hydrogen
  });
}

/**
 * Calculate geometric centroid of a set of points.
 * @param {Array<Object>} points - Array of objects with x, y, z properties
 * @returns {Object} - Centroid coordinates {x, y, z}
 */
function centroid(points) {
  let sumX = 0, sumY = 0, sumZ = 0;
  const n = points.length;
  
  for (const p of points) {
    sumX += p.x;
    sumY += p.y;
    sumZ += p.z;
  }
  
  return {
    x: sumX / n,
    y: sumY / n,
    z: sumZ / n
  };
}

/**
 * Translate points by a vector.
 * @param {Array<Object>} points - Points to translate
 * @param {Object} vector - Translation vector {x, y, z}
 * @returns {Array<Object>} - Translated points
 */
function translate(points, vector) {
  return points.map(p => ({
    ...p,
    x: p.x + vector.x,
    y: p.y + vector.y,
    z: p.z + vector.z
  }));
}

/**
 * Apply quaternion rotation and translation to points.
 * @param {Array<Object>} points - Points to transform
 * @param {Array<number>} q - Quaternion [x, y, z, w]
 * @param {Object} t - Translation {x, y, z}
 * @returns {Array<Object>} - Transformed points
 */
function applyTransform(points, q, t) {
  const [qx, qy, qz, qw] = q;
  
  return points.map(p => {
    const vx = p.x, vy = p.y, vz = p.z;
    
    // Quaternion rotation: v' = q * v * q^(-1)
    // Using the formula: v' = v + 2q_w(q_xyz × v) + 2(q_xyz × (q_xyz × v))
    const ix =  qw * vx + qy * vz - qz * vy;
    const iy =  qw * vy + qz * vx - qx * vz;
    const iz =  qw * vz + qx * vy - qy * vx;
    const iw = -qx * vx - qy * vy - qz * vz;
    
    const ox = ix * qw + iw * (-qx) + iy * (-qz) - iz * (-qy);
    const oy = iy * qw + iw * (-qy) + iz * (-qx) - ix * (-qz);
    const oz = iz * qw + iw * (-qz) + ix * (-qy) - iy * (-qx);
    
    return {
      x: ox + t.x,
      y: oy + t.y,
      z: oz + t.z,
      elem: p.elem,
      resn: p.resn,
      chain: p.chain,
      resi: p.resi,
      name: p.name
    };
  });
}

/**
 * Format atom array as PDB text.
 * @param {Array<Object>} atoms - Atoms to format
 * @param {number} chainShift - ASCII offset for chain ID (0 for no shift)
 * @returns {string} - PDB formatted text
 */
function formatPDB(atoms, chainShift = 0) {
  const lines = [];
  let serial = 1;
  
  for (const atom of atoms) {
    const name = (atom.name || 'CA').padStart(4, ' ');
    const resn = (atom.resn || 'RES').padStart(3, ' ');
    const chain = atom.chain || 'A';
    const chainOut = String.fromCharCode(chain.charCodeAt(0) + chainShift);
    const resi = (atom.resi || 1).toString().padStart(4, ' ');
    const x = (atom.x ?? 0).toFixed(3).padStart(8, ' ');
    const y = (atom.y ?? 0).toFixed(3).padStart(8, ' ');
    const z = (atom.z ?? 0).toFixed(3).padStart(8, ' ');
    const occ = ' 1.00';
    const bfac = ' 0.00';
    const elem = (atom.elem || 'C').toString().padStart(2, ' ');
    
    lines.push(
      `ATOM  ${String(serial).padStart(5, ' ')} ${name} ${resn} ${chainOut}${resi}    ` +
      `${x}${y}${z}${occ}${bfac}          ${elem}`
    );
    serial++;
  }
  
  lines.push('TER', 'ENDMDL', 'END');
  return lines.join('\n');
}

// ========================================================================================
// WEB WORKER CREATION FOR PARALLEL DOCKING
// ========================================================================================
/**
 * Create a Web Worker for parallel docking computation.
 * The worker samples random orientations and scores them independently.
 * @returns {Worker} - Web Worker instance
 */
function makeDockWorker() {
  // Worker code as a string (will be converted to Blob URL)
  const workerCode = `
    // Van der Waals radii for clash detection
    const vdw = {H:1.2, C:1.7, N:1.55, O:1.52, S:1.8, P:1.8, F:1.47, CL:1.75, BR:1.85, I:1.98};
    
    /**
     * Seeded random number generator (Linear Congruential Generator).
     * Ensures reproducible results for a given seed.
     */
    function rand(seed) {
      let state = seed >>> 0;
      return () => {
        state = (1664525 * state + 1013904223) >>> 0;
        return state / 0xFFFFFFFF;
      };
    }
    
    /**
     * Generate uniform random quaternion for 3D rotation.
     * Uses Shoemake's method for uniform sampling of SO(3).
     */
    function randomQuat(rng) {
      const u1 = rng(), u2 = rng(), u3 = rng();
      const a = Math.sqrt(1 - u1);
      const b = Math.sqrt(u1);
      const t1 = 2 * Math.PI * u2;
      const t2 = 2 * Math.PI * u3;
      return [
        a * Math.sin(t1),  // x
        a * Math.cos(t1),  // y
        b * Math.sin(t2),  // z
        b * Math.cos(t2)   // w
      ];
    }
    
    /**
     * Rotate points using quaternion.
     */
    function rotatePoints(points, q) {
      const [qx, qy, qz, qw] = q;
      return points.map(p => {
        const vx = p.x, vy = p.y, vz = p.z;
        const ix =  qw * vx + qy * vz - qz * vy;
        const iy =  qw * vy + qz * vx - qx * vz;
        const iz =  qw * vz + qx * vy - qy * vx;
        const iw = -qx * vx - qy * vy - qz * vz;
        const ox = ix * qw + iw * (-qx) + iy * (-qz) - iz * (-qy);
        const oy = iy * qw + iw * (-qy) + iz * (-qx) - ix * (-qz);
        const oz = iz * qw + iw * (-qz) + ix * (-qy) - iy * (-qx);
        return {x: ox, y: oy, z: oz, elem: p.elem};
      });
    }
    
    /**
     * Translate points by a vector.
     */
    function translate(points, t) {
      return points.map(p => ({
        x: p.x + t.x,
        y: p.y + t.y,
        z: p.z + t.z,
        elem: p.elem
      }));
    }
    
    /**
     * Create spatial grid for fast neighbor lookups.
     */
    function makeGrid(coords, cellSize) {
      const map = new Map();
      const key = (ix, iy, iz) => ix + "|" + iy + "|" + iz;
      
      for (let i = 0; i < coords.length; i++) {
        const x = coords[i].x, y = coords[i].y, z = coords[i].z;
        const ix = Math.floor(x / cellSize);
        const iy = Math.floor(y / cellSize);
        const iz = Math.floor(z / cellSize);
        const k = key(ix, iy, iz);
        
        if (!map.has(k)) map.set(k, []);
        map.get(k).push(i);
      }
      
      return {cellSize, map};
    }
    
    /**
     * Get atoms in neighboring grid cells.
     */
    function neighbors(grid, x, y, z) {
      const c = grid.cellSize;
      const ix = Math.floor(x / c);
      const iy = Math.floor(y / c);
      const iz = Math.floor(z / c);
      const result = [];
      
      // Check 3×3×3 neighborhood
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          for (let dz = -1; dz <= 1; dz++) {
            const k = (ix + dx) + "|" + (iy + dy) + "|" + (iz + dz);
            if (grid.map.has(k)) {
              result.push(...grid.map.get(k));
            }
          }
        }
      }
      
      return result;
    }
    
    /**
     * Score a docked pose based on contacts and clashes.
     */
    function scorePose(proteinA, proteinB, contactCut, clashFactor, wContact, wClash, soft) {
      const grid = makeGrid(proteinA, contactCut);
      let contacts = 0;
      let clashPenalty = 0;
      
      for (let i = 0; i < proteinB.length; i++) {
        const x = proteinB[i].x, y = proteinB[i].y, z = proteinB[i].z;
        const elemB = (proteinB[i].elem || 'C').toUpperCase();
        const candidates = neighbors(grid, x, y, z);
        
        for (const j of candidates) {
          const ax = proteinA[j].x, ay = proteinA[j].y, az = proteinA[j].z;
          const elemA = (proteinA[j].elem || 'C').toUpperCase();
          const dx = x - ax, dy = y - ay, dz = z - az;
          const distance = Math.hypot(dx, dy, dz);
          
          // Calculate sum of van der Waals radii
          const radiusSum = (vdw[elemA] || 1.7) + (vdw[elemB] || 1.7);
          const clashCutoff = clashFactor * radiusSum;
          
          if (distance <= clashCutoff) {
            // Soft-core clash penalty
            const overlap = (clashCutoff - distance + 1e-6) / clashCutoff;
            clashPenalty += wClash * overlap * (1 / (1 + soft * overlap));
          } else if (distance <= contactCut) {
            // Favorable contact
            contacts += 1.0;
          }
        }
      }
      
      return {
        score: contacts - clashPenalty,
        contacts,
        clash: clashPenalty
      };
    }
    
    /**
     * Worker message handler - performs sampling and scoring.
     */
    self.onmessage = (event) => {
      const {Apts, Bpts, params, start, end} = event.data;
      const rng = rand(params.seed + start * 1337);
      let bestPoses = [];
      const totalSamples = end - start;
      
      // Sample random orientations
      for (let k = 0; k < totalSamples; k++) {
        const quat = randomQuat(rng);
        const tx = (rng() * 2 - 1) * params.maxTrans;
        const ty = (rng() * 2 - 1) * params.maxTrans;
        const tz = (rng() * 2 - 1) * params.maxTrans;
        
        const transformedB = translate(rotatePoints(Bpts, quat), {x: tx, y: ty, z: tz});
        const scoreResult = scorePose(
          Apts, transformedB,
          params.contactCut,
          params.clashFactor,
          params.wContact,
          params.wClash,
          params.soft
        );
        
        bestPoses.push({
          score: scoreResult.score,
          contacts: scoreResult.contacts,
          clash: scoreResult.clash,
          q: [...quat],
          t: {x: tx, y: ty, z: tz}
        });
        
        // Send progress updates periodically
        if ((k & 1023) === 0) {
          self.postMessage({type: 'progress', count: k});
        }
      }
      
      // Sort by score and return top candidates
      bestPoses.sort((a, b) => b.score - a.score);
      self.postMessage({
        type: 'done',
        poses: bestPoses.slice(0, Math.min(200, totalSamples))
      });
    };
  `;
  
  // Create worker from blob URL
  const blob = new Blob([workerCode], {type: 'application/javascript'});
  const url = URL.createObjectURL(blob);
  return new Worker(url);
}

// ========================================================================================
// DIVERSITY FILTERING
// ========================================================================================
/**
 * Calculate rotation angle between two quaternions (in degrees).
 */
function angleBetweenQuats(q1, q2) {
  const dot = q1[0]*q2[0] + q1[1]*q2[1] + q1[2]*q2[2] + q1[3]*q2[3];
  return 2 * Math.acos(Math.min(1, Math.abs(dot))) * 180 / Math.PI;
}

/**
 * Filter poses to ensure diversity in orientation and position.
 * @param {Array<Object>} sorted - Poses sorted by score
 * @param {number} angleDeg - Minimum rotation angle difference
 * @param {number} transA - Minimum translation distance
 * @returns {Array<Object>} - Diverse subset of poses
 */
function diverseTop(sorted, angleDeg, transA) {
  const diverse = [];
  const maxPoses = parseInt(E('topN').value) || 10;
  
  for (const pose of sorted) {
    let isDuplicate = false;
    
    // Check against already selected poses
    for (const selected of diverse) {
      const angleDiff = angleBetweenQuats(pose.q, selected.q);
      const transDiff = Math.hypot(
        pose.t.x - selected.t.x,
        pose.t.y - selected.t.y,
        pose.t.z - selected.t.z
      );
      
      // Consider duplicate if both angle and translation are similar
      if (angleDiff <= angleDeg && transDiff <= transA) {
        isDuplicate = true;
        break;
      }
    }
    
    if (!isDuplicate) {
      diverse.push(pose);
      if (diverse.length >= maxPoses) break;
    }
  }
  
  return diverse;
}

// ========================================================================================
// ANTIBODY DOCKING DRIVER
// ========================================================================================
/**
 * Main function to run antibody-antigen docking.
 * Orchestrates parsing, sampling, scoring, and result presentation.
 */
async function runAntibodyDocking() {
  if (inProgress) return;
  
  cancelled = false;
  inProgress = true;
  status('preparing');
  setProgress(0);
  
  E('dockBtn').disabled = true;
  E('cancelBtn').disabled = false;
  E('dockBtn').textContent = 'Running…';
  
  try {
    // === Step 1: Load and parse input structures ===
    const textA = await ensureInputText('A');
    const textB = await ensureInputText('B');
    
    pdbAAllAtoms = parsePDB(textA);
    pdbBAllAtoms = parsePDB(textB);
    
    if (!pdbAAllAtoms.length || !pdbBAllAtoms.length) {
      throw new Error('Could not parse atoms from one or both inputs.');
    }
    
    // Update chain selection UI
    populateChainChips('A', pdbAAllAtoms);
    populateChainChips('B', pdbBAllAtoms);
    
    // === Step 2: Collect parameters ===
    const params = collectDockingParams();
    
    // === Step 3: Filter by selected chains ===
    const selectedA = selectedChains('A');
    const selectedB = selectedChains('B');
    const atomsA = filterChains(pdbAAllAtoms, selectedA);
    const atomsB = filterChains(pdbBAllAtoms, selectedB);
    
    if (!atomsA.length || !atomsB.length) {
      throw new Error('No atoms after chain filtering. Please select valid chains.');
    }
    
    // === Step 4: Select atom subset and center structures ===
    const ptsA0 = selectAtomSet(atomsA, params.atomMode).map(a => ({
      x: a.x, y: a.y, z: a.z, elem: a.elem
    }));
    const ptsB0 = selectAtomSet(atomsB, params.atomMode).map(a => ({
      x: a.x, y: a.y, z: a.z, elem: a.elem
    }));
    
    if (!ptsA0.length || !ptsB0.length) {
      throw new Error('Atom selection produced empty sets. Try Backbone or Heavy mode.');
    }
    
    const centerA = centroid(ptsA0);
    const centerB = centroid(ptsB0);
    const ptsA = translate(ptsA0, {x: -centerA.x, y: -centerA.y, z: -centerA.z});
    const ptsB = translate(ptsB0, {x: -centerB.x, y: -centerB.y, z: -centerB.z});
    
    status('sampling');
    
    // === Step 5: Set up parallel worker pool ===
    const cores = Math.max(1, (navigator.hardwareConcurrency || 4) - 1);
    const poolSize = Math.min(cores, 8);
    const totalSamples = params.samples;
    const samplesPerWorker = Math.floor(totalSamples / poolSize);
    const extraSamples = totalSamples % poolSize;
    
    let allResults = [];
    let completedSamples = 0;
    workerPool = [];
    
    // Spawn workers
    for (let i = 0; i < poolSize; i++) {
      const start = i * samplesPerWorker + Math.min(i, extraSamples);
      const end = start + samplesPerWorker + (i < extraSamples ? 1 : 0);
      
      const worker = makeDockWorker();
      workerPool.push(worker);
      
      worker.onmessage = (event) => {
        if (cancelled) return;
        
        const msg = event.data;
        
        if (msg.type === 'progress') {
          completedSamples += 1024;
          setProgress(Math.min(1, completedSamples / totalSamples));
          status(`sampling ${Math.min(completedSamples, totalSamples)}/${totalSamples}`);
        }
        
        if (msg.type === 'done') {
          allResults.push(msg.poses);
          worker.terminate();
          
          // When all workers complete, finalize results
          if (allResults.length === poolSize) {
            finalizeDocking(allResults.flat(), params, atomsA, atomsB, centerA, centerB);
          }
        }
      };
      
      worker.onerror = (err) => {
        console.error('Worker error:', err);
        worker.terminate();
      };
      
      // Send task to worker
      worker.postMessage({Apts: ptsA, Bpts: ptsB, params, start, end});
    }
    
  } catch(err) {
    alert(err.message || 'An error occurred during docking');
    finishDocking();
    status('error');
    inProgress = false;
  }
}

/**
 * Cancel ongoing docking calculation.
 */
function cancelDocking() {
  cancelled = true;
  
  // Terminate all workers
  workerPool.forEach(w => {
    try { w.terminate(); } catch(e) {}
  });
  workerPool = [];
  
  setProgress(0);
  status('cancelled');
  finishDocking();
  inProgress = false;
}

/**
 * Reset button states after docking completes.
 */
function finishDocking() {
  E('dockBtn').disabled = false;
  E('cancelBtn').disabled = true;
  E('dockBtn').textContent = '▶️ Run Docking';
}

/**
 * Collect docking parameters from UI inputs.
 */
function collectDockingParams() {
  return {
    samples: parseInt(E('samples').value),
    maxTrans: parseFloat(E('maxTrans').value),
    contactCut: parseFloat(E('contactCut').value),
    clashFactor: parseFloat(E('clashFactor').value),
    wContact: parseFloat(E('wContact').value),
    wClash: parseFloat(E('wClash').value),
    soft: parseFloat(E('soft').value),
    topN: Math.max(1, parseInt(E('topN').value)),
    seed: parseInt(E('seed').value) || 42,
    atomMode: E('atomMode').value,
    rescoreMode: E('rescoreMode').value
  };
}

/**
 * Ensure text input is available for a protein.
 */
async function ensureInputText(which) {
  const file = E(which === 'A' ? 'pdbAFile' : 'pdbBFile').files[0];
  let text = E(which === 'A' ? 'pdbAText' : 'pdbBText').value.trim();
  
  if (!text && file) {
    text = await fileToText(file);
  }
  
  if (!text) {
    throw new Error(`Provide PDB for Protein ${which} (file or text).`);
  }
  
  return text;
}

/**
 * Finalize docking after all workers complete.
 * Applies diversity filtering, optional rescoring, and displays results.
 */
async function finalizeDocking(mergedResults, params, atomsA, atomsB, centerA, centerB) {
  if (cancelled) return cancelDocking();
  
  const rescoreLabel = params.rescoreMode === 'NONE' ? 'ranking' :
                      (params.rescoreMode === 'HEAVY' ? 'rescoring' : 'refining');
  status(rescoreLabel);
  
  // Sort by score
  mergedResults.sort((a, b) => b.score - a.score);
  
  // Apply diversity filter
  const diverse = diverseTop(
    mergedResults,
    parseFloat(E('dupAngle').value) || 12,
    parseFloat(E('dupTrans').value) || 2
  );
  
  // Prepare heavy atom sets for visualization
  const atomsAHeavy = translate(
    selectAtomSet(atomsA, 'HEAVY').map(a => ({...a})),
    {x: -centerA.x, y: -centerA.y, z: -centerA.z}
  );
  
  const atomsBHeavy0 = translate(
    selectAtomSet(atomsB, 'HEAVY').map(a => ({...a})),
    {x: -centerB.x, y: -centerB.y, z: -centerB.z}
  );
  
  let topPoses = diverse;
  
  // Optional heavy atom rescoring
  if (params.rescoreMode !== 'NONE') {
    topPoses = await heavyAtomRescore(
      atomsAHeavy,
      atomsBHeavy0,
      params,
      diverse,
      params.rescoreMode === 'HEAVY_REFINE'
    );
    heavyUsed = true;
  } else {
    heavyUsed = false;
  }
  
  // Store results globally
  posesTop = topPoses;
  currentA = atomsAHeavy;
  currentB0 = atomsBHeavy0;
  
  // Update UI
  buildPoseButtons(topPoses);
  if (topPoses.length > 0) {
    showPose(0);
  }
  
  updateMetricsDisplay();
  
  finishDocking();
  status('complete');
  setProgress(1);
  inProgress = false;
}

/**
 * Rescore top poses using full heavy atom detail.
 * Optionally performs micro-optimization with local perturbations.
 */
function heavyAtomRescore(atomsA, atomsB0, params, coarsePoses, refine = false) {
  const {contactCut, clashFactor, wContact, wClash, soft} = params;
  
  // Inner scoring function for heavy atoms
  function score(A, B) {
    let contacts = 0;
    let clashPenalty = 0;
    
    for (const b of B) {
      for (const a of A) {
        const dist = Math.hypot(b.x - a.x, b.y - a.y, b.z - a.z);
        const radiusSum = (vdw[(a.elem || 'C').toUpperCase()] || 1.7) +
                          (vdw[(b.elem || 'C').toUpperCase()] || 1.7);
        const clashCut = clashFactor * radiusSum;
        
        if (dist <= clashCut) {
          const overlap = (clashCut - dist + 1e-6) / clashCut;
          clashPenalty += wClash * overlap * (1 / (1 + soft * overlap));
        } else if (dist <= contactCut) {
          contacts++;
        }
      }
    }
    
    return {
      score: contacts - clashPenalty,
      contacts,
      clash: clashPenalty
    };
  }
  
  // Function to generate small random perturbation
  function jiggle(pose) {
    const mag = 0.5;
    const r = () => (Math.random() * 2 - 1) * mag;
    
    // Perturb quaternion slightly
    const dq = [
      pose.q[0] + r() * 0.01,
      pose.q[1] + r() * 0.01,
      pose.q[2] + r() * 0.01,
      pose.q[3] + r() * 0.01
    ];
    const norm = Math.hypot(...dq);
    for (let i = 0; i < 4; i++) dq[i] /= norm;
    
    // Perturb translation
    const dt = {
      x: pose.t.x + r(),
      y: pose.t.y + r(),
      z: pose.t.z + r()
    };
    
    return {q: dq, t: dt};
  }
  
  const rescored = [];
  
  for (const pose of coarsePoses) {
    let best = {...pose};
    let transformedB = applyTransform(atomsB0, pose.q, pose.t);
    let scoreResult = score(atomsA, transformedB);
    
    best.score = scoreResult.score;
    best.contacts = scoreResult.contacts;
    best.clash = scoreResult.clash;
    
    // Optional local refinement
    if (refine) {
      for (let iter = 0; iter < 40; iter++) {
        const perturbed = jiggle(best);
        const perturbedB = applyTransform(atomsB0, perturbed.q, perturbed.t);
        const newScore = score(atomsA, perturbedB);
        
        if (newScore.score > best.score) {
          best.q = perturbed.q;
          best.t = perturbed.t;
          best.score = newScore.score;
          best.contacts = newScore.contacts;
          best.clash = newScore.clash;
        }
      }
    }
    
    rescored.push(best);
  }
  
  rescored.sort((a, b) => b.score - a.score);
  return rescored.slice(0, parseInt(E('topN').value));
}

// ========================================================================================
// VISUALIZATION FUNCTIONS
// ========================================================================================
/**
 * Create buttons for each pose in the results.
 */
function buildPoseButtons(poses) {
  const container = E('poseControls');
  container.innerHTML = '';
  
  poses.forEach((pose, index) => {
    // View button
    const btnView = document.createElement('button');
    btnView.className = 'btn';
    btnView.textContent = `Pose ${index + 1} (S=${pose.score.toFixed(1)}, C=${pose.contacts | 0}, X=${pose.clash.toFixed(1)})`;
    btnView.addEventListener('click', () => showPose(index));
    container.appendChild(btnView);
    
    // Download button
    const btnDownload = document.createElement('button');
    btnDownload.className = 'btn green';
    btnDownload.style.marginLeft = '6px';
    btnDownload.textContent = '⬇ PDB';
    btnDownload.addEventListener('click', () => downloadSinglePose(index));
    container.appendChild(btnDownload);
  });
  
  // Update comparison dropdowns
  updateComparisonDropdowns(poses);
}

/**
 * Display a specific pose in the 3D viewer.
 */
function showPose(index) {
  if (index < 0 || index >= posesTop.length) return;
  
  currentPose = posesTop[index];
  currentPoseIndex = index;
  
  // Apply transformation to protein B
  const transformedB = applyTransform(currentB0, currentPose.q, currentPose.t);
  
  // Clear viewer and add models
  viewer.clear();
  viewer.addModel(formatPDB(currentA), 'pdb');
  viewer.addModel(formatPDB(transformedB, 1), 'pdb');
  
  // Determine if cartoon rendering is viable (needs backbone and multiple residues)
  const resCountA = new Set(currentA.map(a => a.resi)).size;
  const resCountB = new Set(transformedB.map(a => a.resi)).size;
  const useCartoon = resCountA >= 8 && resCountB >= 8;
  
  if (useCartoon) {
    viewer.setStyle({model: 0}, {cartoon: {color: '#60a5fa'}});
    viewer.setStyle({model: 1}, {cartoon: {color: '#f97316'}});
  } else {
    // Fall back to stick representation for small structures
    viewer.setStyle({model: 0}, {stick: {radius: 0.25}});
    viewer.setStyle({model: 1}, {stick: {radius: 0.25, color: '#f97316'}});
  }
  
  viewer.zoomTo();
  
  // Compute interface metrics
  const cutoff = parseFloat(E('contactCut').value);
  const metrics = computeInterfaceMetrics(currentA, transformedB, cutoff);
  
  currentContacts = metrics.contactsPairs;
  currentHB = metrics.hbPairs;
  currentSB = metrics.sbPairs;
  currentHydro = metrics.hydroPairs || [];
  
  refreshOverlays();
  
  // Calculate energies
  const kElec = parseFloat(E('kElec').value) || 0.5;
  const elecCutoff = parseFloat(E('elecCut').value) || 12;
  const electrostaticEnergy = coulombEnergy(currentA, transformedB, kElec, elecCutoff);
  
  const BSA = metrics.contacts * 10.0;  // Approximate buried surface area
  
  // Calculate binding enthalpy
  const enthalpy = calculateEnthalpy(metrics, electrostaticEnergy);
  
  // Update score display
  E('scoreBox').innerHTML = `
    <b>Pose ${index + 1}</b><br>
    Score: ${currentPose.score.toFixed(2)} | 
    Contacts: ${metrics.contacts} | 
    Clash: ${metrics.clash.toFixed(2)} | 
    H-bonds: ${metrics.hb} | 
    Salt Bridges: ${metrics.sb} | 
    Hydrophobic: ${metrics.hydrophobics}<br>
    BSA ≈ ${BSA.toFixed(0)} Å² | 
    Electrostatics: ${electrostaticEnergy.toFixed(2)} kcal/mol | 
    <b>ΔH ≈ ${enthalpy.toFixed(2)} kcal/mol</b>
  `;
  
  // Update metrics panel
  updateMetricsDisplay();
  
  // Update energy decomposition
  updateEnergyDecomposition(metrics, electrostaticEnergy, enthalpy);
  
  viewer.render();
}

/**
 * Calculate binding enthalpy from interface metrics.
 * Uses empirically-derived weights for different interaction types.
 */
function calculateEnthalpy(metrics, electrostaticEnergy) {
  // Energy weights (kcal/mol per interaction)
  const weights = {
    contact: -0.5,      // Favorable van der Waals
    hbond: -2.5,        // Hydrogen bond
    saltBridge: -4.0,   // Salt bridge
    hydrophobic: -1.0,  // Hydrophobic contact
    clash: +0.3,        // Clash penalty (unfavorable)
    desolv: +0.2        // Desolvation penalty per contact
  };
  
  const enthalpy = 
    weights.contact * metrics.contacts +
    weights.hbond * metrics.hb +
    weights.saltBridge * metrics.sb +
    weights.hydrophobic * metrics.hydrophobics +
    weights.clash * metrics.clash +
    electrostaticEnergy +
    weights.desolv * metrics.contacts;
  
  return enthalpy;
}

/**
 * Refresh overlay lines (contacts, H-bonds, salt bridges).
 */
function refreshOverlays() {
  if (!currentPose) return;
  
  viewer.removeAllShapes();
  
  if (E('toggleContacts').checked) {
    drawPairLines(currentContacts, '#60a5fa');
  }
  
  if (E('toggleHB').checked) {
    drawPairLines(currentHB, '#34d399');
  }
  
  if (E('toggleSB').checked) {
    drawPairLines(currentSB, '#f87171');
  }
  
  if (E('toggleHydro').checked) {
    drawPairLines(currentHydro, '#fbbf24');
  }
  
  viewer.render();
}

/**
 * Draw dashed lines between atom pairs.
 */
function drawPairLines(pairs, color) {
  // Limit to first 400 for performance
  pairs.slice(0, 400).forEach(pair => {
    viewer.addLine({
      start: {x: pair.x1, y: pair.y1, z: pair.z1},
      end: {x: pair.x2, y: pair.y2, z: pair.z2},
      dashed: true,
      dashLength: 0.5,
      color,
      linewidth: 2
    });
  });
}

// ========================================================================================
// INTERFACE ANALYSIS FUNCTIONS
// ========================================================================================
/**
 * Compute detailed interface metrics between two protein structures.
 * Detects contacts, H-bonds, salt bridges, and hydrophobic interactions.
 */
function computeInterfaceMetrics(proteinA, proteinB, contactCutoff) {
  let contacts = 0;
  let clash = 0;
  let hbonds = 0;
  let saltBridges = 0;
  let hydrophobicContacts = 0;
  
  const contactsPairs = [];
  const hbPairs = [];
  const sbPairs = [];
  const hydroPairs = [];
  
  const clashFactor = parseFloat(E('clashFactor').value) || 0.85;
  
  for (const atomB of proteinB) {
    for (const atomA of proteinA) {
      const distance = Math.hypot(
        atomB.x - atomA.x,
        atomB.y - atomA.y,
        atomB.z - atomA.z
      );
      
      // Get van der Waals radii
      const radiusSum = (vdw[(atomA.elem || 'C').toUpperCase()] || 1.7) +
                        (vdw[(atomB.elem || 'C').toUpperCase()] || 1.7);
      const clashCut = clashFactor * radiusSum;
      
      // === Clash detection ===
      if (distance <= clashCut) {
        const overlap = (clashCut - distance + 1e-6) / clashCut;
        clash += 6.0 * overlap * (1 / (1 + 0.5 * overlap));
      }
      
      // === Contact detection ===
      if (distance <= contactCutoff) {
        contacts++;
        contactsPairs.push({
          x1: atomA.x, y1: atomA.y, z1: atomA.z,
          x2: atomB.x, y2: atomB.y, z2: atomB.z
        });
      }
      
      // === Hydrogen bond detection (geometric criterion) ===
      const atomAisN = atomA.name?.trim().startsWith('N');
      const atomBisO = atomB.name?.trim().startsWith('O');
      const atomAisO = atomA.name?.trim().startsWith('O');
      const atomBisN = atomB.name?.trim().startsWith('N');
      
      if ((atomAisN && atomBisO || atomAisO && atomBisN) && distance <= 3.5) {
        hbonds++;
        hbPairs.push({
          x1: atomA.x, y1: atomA.y, z1: atomA.z,
          x2: atomB.x, y2: atomB.y, z2: atomB.z
        });
      }
      
      // === Salt bridge detection ===
      const isAcidic = atom => 
        (atom.resn === 'ASP' && atom.name.startsWith('OD')) ||
        (atom.resn === 'GLU' && atom.name.startsWith('OE'));
      
      const isBasic = atom =>
        (atom.resn === 'LYS' && atom.name === 'NZ') ||
        (atom.resn === 'ARG' && (atom.name === 'NH1' || atom.name === 'NH2' || atom.name === 'NE')) ||
        (atom.resn === 'HIS' && (atom.name === 'ND1' || atom.name === 'NE2'));
      
      if ((isAcidic(atomA) && isBasic(atomB) || isAcidic(atomB) && isBasic(atomA)) && distance <= 4.0) {
        saltBridges++;
        sbPairs.push({
          x1: atomA.x, y1: atomA.y, z1: atomA.z,
          x2: atomB.x, y2: atomB.y, z2: atomB.z
        });
      }
      
      // === Hydrophobic contacts ===
      if (hydrophobic.has(atomA.resn) && hydrophobic.has(atomB.resn) &&
          (atomA.elem === 'C' || atomB.elem === 'C') && distance <= 4.5) {
        hydrophobicContacts++;
        hydroPairs.push({
          x1: atomA.x, y1: atomA.y, z1: atomA.z,
          x2: atomB.x, y2: atomB.y, z2: atomB.z
        });
      }
    }
  }
  
  return {
    contacts,
    clash,
    hb: hbonds,
    sb: saltBridges,
    hydrophobics: hydrophobicContacts,
    contactsPairs,
    hbPairs,
    sbPairs,
    hydroPairs
  };
}

/**
 * Calculate residue-level electrostatic energy using Coulomb's law.
 * Simplified model with formal charges.
 */
function coulombEnergy(proteinA, proteinB, k = 0.5, cutoff = 12) {
  const chargesA = extractResidueCharges(proteinA);
  const chargesB = extractResidueCharges(proteinB);
  
  let energy = 0;
  const cutoffSq = cutoff * cutoff;
  
  for (const chargeA of chargesA) {
    for (const chargeB of chargesB) {
      const dx = chargeA.x - chargeB.x;
      const dy = chargeA.y - chargeB.y;
      const dz = chargeA.z - chargeB.z;
      const distSq = dx*dx + dy*dy + dz*dz;
      
      if (distSq > cutoffSq) continue;
      
      const dist = Math.sqrt(distSq) + 1e-3;  // Avoid division by zero
      energy += k * (chargeA.q * chargeB.q) / dist;
    }
  }
  
  return energy;
}

/**
 * Extract residue-level charges and positions.
 */
function extractResidueCharges(atoms) {
  const chargeMap = new Map();
  const residueAtoms = new Map();
  
  // Group atoms by residue
  for (const atom of atoms) {
    const key = atom.chain + ':' + atom.resi;
    if (!residueAtoms.has(key)) {
      residueAtoms.set(key, []);
    }
    residueAtoms.get(key).push(atom);
  }
  
  // Assign charges and positions
  for (const [key, atomList] of residueAtoms.entries()) {
    const resName = atomList[0].resn || 'UNK';
    const charge = residueCharges[resName] || 0;
    
    if (charge !== 0) {
      // Use CA position if available, otherwise geometric center
      let ca = atomList.find(a => a.name === 'CA');
      let x, y, z;
      
      if (ca) {
        x = ca.x;
        y = ca.y;
        z = ca.z;
      } else {
        let sumX = 0, sumY = 0, sumZ = 0;
        for (const a of atomList) {
          sumX += a.x;
          sumY += a.y;
          sumZ += a.z;
        }
        x = sumX / atomList.length;
        y = sumY / atomList.length;
        z = sumZ / atomList.length;
      }
      
      chargeMap.set(key, {
        x, y, z, q: charge,
        resn: resName,
        chain: atomList[0].chain,
        resi: atomList[0].resi
      });
    }
  }
  
  return Array.from(chargeMap.values());
}

// ========================================================================================
// EXPORT FUNCTIONS
// ========================================================================================
/**
 * Download all top poses as a multi-model PDB file.
 */
function downloadAllPoses() {
  if (!posesTop.length) {
    alert('No poses to download. Run docking first.');
    return;
  }
  
  const lines = [];
  
  posesTop.forEach((pose, index) => {
    lines.push(`MODEL     ${index + 1}`);
    lines.push(formatPDB(currentA));
    lines.push(formatPDB(applyTransform(currentB0, pose.q, pose.t), 1));
    lines.push('ENDMDL');
  });
  
  lines.push('END');
  
  downloadBlob(lines.join('\n'), 'all_poses.pdb');
}

/**
 * Download currently displayed pose as PDB.
 */
function downloadCurrentPose() {
  if (currentPoseIndex < 0) {
    alert('No pose selected.');
    return;
  }
  
  downloadSinglePose(currentPoseIndex);
}

/**
 * Download a specific pose by index.
 */
function downloadSinglePose(index) {
  const pose = posesTop[index];
  const transformedB = applyTransform(currentB0, pose.q, pose.t);
  const pdbText = formatPDB(currentA) + '\n' + formatPDB(transformedB, 1);
  downloadBlob(pdbText, `pose_${index + 1}.pdb`);
}

/**
 * Download summary CSV with all pose data.
 */
function downloadCSV() {
  if (!posesTop.length) {
    alert('No poses to export.');
    return;
  }
  
  const rows = ['rank,score,contacts,clash,qx,qy,qz,qw,tx,ty,tz'];
  
  posesTop.forEach((pose, index) => {
    rows.push([
      index + 1,
      pose.score.toFixed(4),
      pose.contacts,
      pose.clash.toFixed(4),
      pose.q[0].toFixed(6),
      pose.q[1].toFixed(6),
      pose.q[2].toFixed(6),
      pose.q[3].toFixed(6),
      pose.t.x.toFixed(3),
      pose.t.y.toFixed(3),
      pose.t.z.toFixed(3)
    ].join(','));
  });
  
  downloadBlob(rows.join('\n'), 'poses_summary.csv');
}

/**
 * Download detailed JSON with interface analysis.
 */
function downloadJSON() {
  if (!posesTop.length) {
    alert('No poses to export.');
    return;
  }
  
  const kElec = parseFloat(E('kElec').value) || 0.5;
  const elecCut =
