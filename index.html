<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Comprehensive Docking Suite â€¢ Student Edition â€¢ Antibodyâ€“Antigen â€¢ CDR â€¢ Ligand Screening â€¢ Enthalpy</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0f172a" />
<meta name="description" content="Student-friendly in-browser docking: antibodyâ€“antigen docking, CDR mapping (Kabat/Chothia/IMGT), ligand docking, batch screening, clustering, consensus scoring, 3D viz, QA & registry â€” all local." />

<script defer src="https://unpkg.com/3dmol@2.4.2/build/3Dmol-min.js"></script>
<script defer src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

<style>
Â  :root{
Â  Â  --bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#9ca3af;--accent:#7dd3fc;--line:#1f2937;
Â  Â  --green:#34d399;--red:#f87171;--yellow:#fbbf24;--orange:#fb923c;--purple:#a78bfa;
Â  Â  --mono:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;--sans:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial
Â  }
Â  *{box-sizing:border-box}
Â  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans);line-height:1.6}
Â  a{color:var(--accent);text-decoration:none}
Â  header{padding:34px 16px;background:radial-gradient(1200px 600px at 15% -10%,#1d2a4a,transparent 60%),radial-gradient(1000px 500px at 120% 10%,#2a1e4a,transparent 60%)}
Â  .wrap{max-width:1400px;margin:0 auto}
Â  h1{margin:0 0 8px;font-size:30px;font-weight:800}
Â  .byline{color:#93c5fd;font-weight:700;margin-top:6px}
Â  h2{margin:0 0 10px;font-size:22px;font-weight:700}
Â  h3{margin:14px 0 6px;font-size:17px;font-weight:700}
Â  p.lead{color:var(--muted);margin:6px 0 0;font-size:14px}
Â  section{padding:22px 16px;border-top:1px solid var(--line);background:var(--panel)}
Â  .card{background:#0b1220;border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:12px}
Â  .grid{display:grid;gap:16px}
Â  @media(min-width:980px){.grid.two{grid-template-columns:1.05fr .95fr}}
Â  @media(min-width:1100px){.grid.three{grid-template-columns:repeat(3,1fr)}}
Â  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
Â  label{font-weight:700;font-size:13px}
Â  input[type=number],input[type=text],textarea,select{background:#0a0f1a;color:var(--text);border:1px solid #1f2937;border-radius:8px;padding:8px 10px;font-family:var(--mono);font-size:13px;min-width:80px}
Â  textarea{width:100%;min-height:110px;resize:vertical}
Â  .btn{display:inline-flex;align-items:center;gap:8px;padding:9px 12px;border-radius:10px;font-weight:700;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:13px;transition:.2s;color:var(--text)}
Â  .btn:hover:not([disabled]){transform:translateY(-1px);box-shadow:0 6px 16px rgba(125,211,252,.25)}
Â  .btn.primary{background:linear-gradient(180deg,#2563eb,#1e40af);border:0;color:#fff}
Â  .btn.green{background:linear-gradient(180deg,#059669,#047857);border:0;color:#fff}
Â  .btn.red{background:linear-gradient(180deg,#dc2626,#b91c1c);border:0;color:#fff}
Â  .btn.purple{background:linear-gradient(180deg,#7c3aed,#6d28d9);border:0;color:#fff}
Â  .btn.orange{background:linear-gradient(180deg,#fb923c,#f97316);border:0;color:#fff}
Â  .btn[disabled]{opacity:.55;cursor:not-allowed}
Â  .pill{padding:2px 8px;border:1px solid #334155;border-radius:999px;font-size:12px;color:#93c5fd;font-weight:800}
Â  progress{width:260px;height:10px;border:1px solid var(--line);border-radius:999px;background:#0b1220}
Â  progress::-webkit-progress-value{background:#7dd3fc;border-radius:999px;transition:width .3s}
Â  .infobox{border:1px solid #334155;border-left:4px solid var(--accent);border-radius:10px;padding:10px;background:#0a0f1a;color:#cbd5e1;margin:10px 0;font-size:13px}
Â  .errorbox{border:1px solid #7f1d1d;border-left:4px solid #dc2626;border-radius:10px;padding:10px;background:#1a0c0c;color:#fecaca;margin:10px 0}
Â  .successbox{border:1px solid #065f46;border-left:4px solid #10b981;border-radius:10px;padding:10px;background:#0a1f1a;color:#a7f3d0;margin:10px 0}
Â  .score{font-family:var(--mono);background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:8px;overflow:auto;font-size:12px;line-height:1.5;white-space:pre-wrap}
Â  .chainchips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
Â  .chip{border:1px solid #334155;border-radius:999px;padding:2px 8px;display:inline-flex;align-items:center;gap:6px;font-size:13px}
Â  .chip input{accent-color:#7dd3fc}
Â  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
Â  .tabbtn{padding:8px 12px;border-radius:999px;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:14px;font-weight:800;transition:.2s;color:var(--text)}
Â  .tabbtn:hover{background:#152034}
Â  .tabbtn.active{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0;color:#fff}
Â  .tabsec{display:none}
Â  .tabsec.active{display:block}
Â  .table{width:100%;border-collapse:collapse;font-size:13px;background:#0a0f1a}
Â  .table th{background:#152034;padding:8px;text-align:left;border-bottom:2px solid var(--line);position:sticky;top:0;z-index:1}
Â  .table td{padding:6px 8px;border-bottom:1px solid #112033}
Â  .table tr:hover{background:#0f1829}
Â  .table-container{max-height:460px;overflow:auto;border:1px solid var(--line);border-radius:8px;margin-top:8px}
Â  #viewer,#viewerLig,#viewerScr,#viewerComp,#viewerCDR{position:relative;width:100%;height:560px;border:1px solid var(--line);border-radius:10px;background:#0a0f1a;overflow:hidden}
Â  .metric-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin:10px 0}
Â  .metric-card{background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:10px;text-align:center}
Â  .metric-value{font-size:20px;font-weight:800;color:var(--accent)}
Â  .metric-label{font-size:12px;color:var(--muted)}
Â  footer{padding:18px 16px;color:#9ca3af;text-align:center;font-size:13px}
Â  .small{font-size:12px}
Â  .guide{display:grid;gap:8px;margin-top:12px}
Â  .step{background:#0a0f1a;border:1px dashed #334155;border-radius:10px;padding:10px}
Â  #nmrMoleculeImage { min-height: 200px; background-size: contain; background-position: center; background-repeat: no-repeat; border-radius: 8px; border: 1px solid var(--line); margin-bottom: 12px; }
Â  .topbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px}
Â  .kbd{font-family:var(--mono);background:#111827;border:1px solid #374151;border-radius:6px;padding:2px 6px;font-size:12px}
Â  [aria-live]{min-width:40px}
Â  /* CDR cards */
Â  .scheme-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;margin-top:10px}
Â  .scheme-card{background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:8px}
Â  .cdr-highlight{background:#1e293b;border-left:3px solid var(--accent);padding:6px 8px;margin:6px 0;border-radius:6px}
Â  .cdr-region{font-family:var(--mono);font-size:11px;color:#fbbf24;background:#1a1a2e;padding:2px 4px;border-radius:4px;margin:2px}
</style>
</head>
<body>

<header>
Â  <div class="wrap">
Â  Â  <h1>ğŸ§¬ Comprehensive Molecular Docking Suite â€” <span style="color:#a7f3d0">Student Edition</span></h1>
Â  Â  <div class="byline">by DJF â€” The New Chemist</div>
Â  Â  <p class="lead">
Â  Â  Â  Antibodyâ€“antigen docking â€¢ <b>CDR mapping</b> (Kabat/Chothia/IMGT) â€¢ Single-ligand docking â€¢ Batch screening (â‰¤50 SMILES Ã— â‰¤3 receptors) â€¢
Â  Â  Â  Chain pairing â€¢ Clustering â€¢ Consensus ranking â€¢ Î”H estimation â€¢ QA â€¢ Run registry â€” all in-browser
Â  Â  </p>

Â  Â  <div class="infobox" role="region" aria-label="Student guide">
Â  Â  Â  <b>Quick Start (Students):</b>
Â  Â  Â  <div class="guide">
Â  Â  Â  Â  <div class="step">1) <b>Load Proteins</b> in <span class="kbd">Antibody Docking</span>: paste PDB text or click <em>Example</em>. Then <b>Parse</b> to detect chains.</div>
Â  Â  Â  Â  <div class="step">2) <b>Set Parameters</b>: samples control thoroughness; <em>All heavy</em> is most realistic. Press <b>Run Docking</b>.</div>
Â  Â  Â  Â  <div class="step">3) <b>Explore Results</b>: use the Complex picker, click pose buttons, and toggle overlays for contacts/H-bonds/etc.</div>
Â  Â  Â  Â  <div class="step">4) <b>Analyze CDRs</b> in the CDR tab (paste antibody PDB) and visualize per-scheme mappings.</div>
Â  Â  Â  Â  <div class="step">5) <b>Export</b> top poses as PDB/CSV/JSON and <b>validate with professional tools and experiments</b>.</div>
Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div class="tabs" role="tablist">
Â  Â  Â  <button class="tabbtn active" data-tab="dockTab" role="tab" aria-selected="true">ğŸ§· Antibody Docking</button>
Â  Â  Â  <button class="tabbtn" data-tab="cdrTab" role="tab">ğŸ”¬ CDR Analysis</button>
Â  Â  Â  <button class="tabbtn" data-tab="fragmentTab" role="tab">ğŸ“ Fragment Generator</button>
      <button class="tabbtn" data-tab="analyzerTab" role="tab">ğŸ§ª Antibody Analyzer</button>
Â  Â  Â  <button class="tabbtn" data-tab="ligTab" role="tab">ğŸ’Š Ligand Docking</button>
Â  Â  Â  <button class="tabbtn" data-tab="screenTab" role="tab">ğŸ“š Batch Screening</button>
Â  Â  Â  <button class="tabbtn" data-tab="qaTab" role="tab">âœ… QA & Registry</button>
Â  Â  Â  <button class="tabbtn" data-tab="analysisTab" role="tab">ğŸ“Š Analysis</button>
Â  Â  Â  <button class="tabbtn" data-tab="omicsTab" role="tab">ğŸ”¬ Omics Analysis</button>
Â  Â  Â  <button class="tabbtn" data-tab="nmrTab" role="tab">ğŸ“¡ NMR Prediction</button>
Â  Â  Â  <button class="tabbtn" data-tab="aboutTab" role="tab">â„¹ï¸ About</button>
Â  Â  </div>
Â  Â  <div class="topbar">
Â  Â  Â  <button class="btn" id="btnDemo" title="Load small example proteins and run a quick docking">ğŸ¯ Load Demo & Dock</button>
Â  Â  Â  <button class="btn green" id="btnSaveSession" title="Download a JSON snapshot of this session">ğŸ’¾ Save Session</button>
Â  Â  Â  <button class="btn purple" id="btnLoadSession" title="Load a previously saved session (.json)">ğŸ“‚ Load Session</button>
Â  Â  Â  <span class="pill" id="statusPill" aria-live="polite">idle</span>
Â  Â  Â  <progress id="prog" value="0" max="1" aria-label="progress"></progress>
Â  Â  </div>
Â  </div>
</header>

<section id="dockTab" class="tabsec active" data-tab-panel>
Â  <div class="wrap grid two">
Â  Â  <div class="card">
Â  Â  Â  <h2>1ï¸âƒ£ Load Proteins</h2>
Â  Â  Â  <div class="row small" style="color:#9ca3af">Upload PDBs or paste text. Parse, then pick chains. <em>Tip:</em> click <b>Example</b> to try quickly.</div>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <div style="flex:1;min-width:300px">
Â  Â  Â  Â  Â  <h3>Protein A (Antibody) <span class="pill" id="badgeA">0 atoms</span></h3>
Â  Â  Â  Â  Â  <div class="row" role="group" aria-label="Protein A inputs">
Â  Â  Â  Â  Â  Â  <input type="file" id="pdbAFile" accept=".pdb,.ent,.txt,.pdb.gz" />
Â  Â  Â  Â  Â  Â  <button class="btn" onclick="useExample('A')">Example</button>
Â  Â  Â  Â  Â  Â  <button class="btn" onclick="fetchPDBFromRCSB('A')" title="Download by PDB ID from RCSB">Fetch PDB ID</button>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <textarea id="pdbAText" placeholder="Paste PDB for Protein A" aria-label="Protein A PDB"></textarea>
Â  Â  Â  Â  Â  <div class="row"><label>Chains:</label><div id="chainsABox" class="chainchips"></div></div>
Â  Â  Â  Â  Â  <div id="chainWarnA" class="infobox small">Parse to populate chains.</div>
Â  Â  Â  Â  Â  <div class="row"><button class="btn" onclick="parseOne('A')">ğŸ” Parse A</button><button class="btn" onclick="selectAllChains('A')">Select All</button><button class="btn" onclick="invertChains('A')">Invert</button></div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div style="flex:1;min-width:300px">
Â  Â  Â  Â  Â  <h3>Protein B (Antigen) <span class="pill" id="badgeB">0 atoms</span></h3>
Â  Â  Â  Â  Â  <div class="row" role="group" aria-label="Protein B inputs">
Â  Â  Â  Â  Â  Â  <input type="file" id="pdbBFile" accept=".pdb,.ent,.txt,.pdb.gz" />
Â  Â  Â  Â  Â  Â  <button class="btn" onclick="useExample('B')">Example</button>
Â  Â  Â  Â  Â  Â  <button class="btn" onclick="fetchPDBFromRCSB('B')" title="Download by PDB ID from RCSB">Fetch PDB ID</button>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <textarea id="pdbBText" placeholder="Paste PDB for Protein B" aria-label="Protein B PDB"></textarea>
Â  Â  Â  Â  Â  <div class="row"><label>Chains:</label><div id="chainsBBox" class="chainchips"></div></div>
Â  Â  Â  Â  Â  <div id="chainWarnB" class="infobox small">Parse to populate chains.</div>
Â  Â  Â  Â  Â  <div class="row"><button class="btn" onclick="parseOne('B')">ğŸ” Parse B</button><button class="btn" onclick="selectAllChains('B')">Select All</button><button class="btn" onclick="invertChains('B')">Invert</button></div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  <details style="margin-top:10px"><summary><b>Student Notes</b> â€” formats & tips</summary>
Â  Â  Â  Â  <div class="small" style="color:#9ca3af;padding-top:6px">
Â  Â  Â  Â  Â  <b>Formats:</b> PDB text, .pdb.gz â€¢ <b>Fetch:</b> RCSB via PDB ID â€¢ <b>Cartoon:</b> needs backbone atoms (N/CA/C/O)
Â  Â  Â  Â  </div>
Â  Â  Â  </details>
Â  Â  </div>

Â  Â  <div class="card">
Â  Â  Â  <h2>2ï¸âƒ£ Docking Parameters</h2>
Â  Â  Â  <h4>Sampling</h4>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <label>Samples</label><input type="number" id="samples" value="12000" min="1000" step="1000" title="More samples = more thorough (slower)">
Â  Â  Â  Â  <label>Max Translation (Ã…)</label><input type="number" id="maxTrans" value="12" step="1">
Â  Â  Â  Â  <label>Atom Set</label>
Â  Â  Â  Â  <select id="atomMode" title="Which atoms to use for sampling/scoring">
Â  Â  Â  Â  Â  <option value="CA">CÎ± only</option><option value="BB">Backbone</option><option value="HEAVY" selected>All heavy</option>
Â  Â  Â  Â  </select>
Â  Â  Â  </div>
Â  Â  Â  <h4 style="margin-top:8px">Scoring</h4>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <label>Contact (Ã…)</label><input type="number" id="contactCut" value="4.8" step="0.1">
Â  Â  Â  Â  <label>Clash Factor</label><input type="number" id="clashFactor" value="0.85" step="0.05">
Â  Â  Â  Â  <label>Contact W</label><input type="number" id="wContact" value="1.0" step="0.1">
Â  Â  Â  Â  <label>Clash W</label><input type="number" id="wClash" value="6.0" step="0.1">
Â  Â  Â  Â  <label>Softness</label><input type="number" id="soft" value="0.5" step="0.1">
Â  Â  Â  </div>
Â  Â  Â  <h4 style="margin-top:8px">Pairing & Output</h4>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <label>Pairing</label>
Â  Â  Â  Â  <select id="pairMode">
Â  Â  Â  Â  Â  <option value="AGG">Aggregate (all selected)</option>
Â  Â  Â  Â  Â  <option value="A_EACH_B">A Ã— each B-chain</option>
Â  Â  Â  Â  Â  <option value="CROSS">each A-chain Ã— each B-chain</option>
Â  Â  Â  Â  </select>
Â  Â  Â  Â  <label>Top Poses</label><input type="number" id="topN" value="12" min="1" max="50">
Â  Â  Â  Â  <label>Rescore</label>
Â  Â  Â  Â  <select id="rescoreMode"><option value="NONE">Skip</option><option value="HEAVY">Heavy</option><option value="HEAVY_REFINE" selected>Heavy + refine</option></select>
Â  Â  Â  Â  <label>Seed</label><input type="number" id="seed" value="42">
Â  Â  Â  </div>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <label>Diversity (Â°/Ã…)</label>
Â  Â  Â  Â  <input type="number" id="dupAngle" value="12" step="1" style="width:90px">
Â  Â  Â  Â  <input type="number" id="dupTrans" value="2" step="0.5" style="width:90px">
Â  Â  Â  Â  <label>Clusters</label><input type="number" id="clustersK" value="6" min="1" max="24" style="width:90px">
Â  Â  Â  </div>
Â  Â  Â  <div class="row" style="margin-top:10px">
Â  Â  Â  Â  <button class="btn primary" id="dockBtn">â–¶ï¸ Run Docking</button>
Â  Â  Â  Â  <button class="btn red" id="cancelBtn" disabled>âœ– Cancel</button>
Â  Â  Â  Â  <button class="btn orange" id="resetBtn">ğŸ”„ Reset</button>
Â  Â  Â  </div>
Â  Â  Â  <div class="infobox small"><b>Score = contactsÃ—W<sub>c</sub> âˆ’ clashesÃ—W<sub>x</sub></b>. Clustering is pose-diversity aware. Heavy rescoring refines ranks.</div>
Â  Â  </div>
Â  </div>

Â  <div class="wrap grid two">
Â  Â  <div class="card">
Â  Â  Â  <h2>3ï¸âƒ£ Complex Selector â€¢ 3D Visualization & Results</h2>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <label>Complex</label>
Â  Â  Â  Â  <select id="comboSelect" style="min-width:260px" aria-label="Complex selector"></select>
Â  Â  Â  Â  <button class="btn" id="btnPrevCombo">â—€ Prev</button>
Â  Â  Â  Â  <button class="btn" id="btnNextCombo">Next â–¶</button>
Â  Â  Â  Â  <button class="btn" id="btnClusters" title="Group poses into K clusters">ğŸ“ Cluster Poses</button>
Â  Â  Â  </div>
Â  Â  Â  <div class="row" style="margin-top:6px">
Â  Â  Â  Â  <label class="chip"><input type="checkbox" id="toggleContacts" checked> Contacts</label>
Â  Â  Â  Â  <label class="chip"><input type="checkbox" id="toggleHB" checked> H-bonds</label>
Â  Â  Â  Â  <label class="chip"><input type="checkbox" id="toggleSB" checked> Salt bridges</label>
Â  Â  Â  Â  <label class="chip"><input type="checkbox" id="toggleHydro"> Hydrophobic</label>
Â  Â  Â  Â  <label class="chip"><input type="checkbox" id="toggleRibbon" checked> Ribbon</label>
Â  Â  Â  </div>
Â  Â  Â  <div id="viewer" role="img" aria-label="3D viewer"></div>
Â  Â  Â  <div class="row" style="margin-top:8px;flex-wrap:wrap" id="poseControls"></div>
Â  Â  Â  <div class="row" style="margin-top:8px">
Â  Â  Â  Â  <button class="btn green" id="btnAllPDB">â¬‡ All Poses PDB (this complex)</button>
Â  Â  Â  Â  <button class="btn green" id="btnCurrentPDB">â¬‡ Current PDB</button>
Â  Â  Â  Â  <button class="btn" id="btnCSV">â¬‡ CSV</button>
Â  Â  Â  Â  <button class="btn" id="btnJSON">â¬‡ JSON</button>
Â  Â  Â  Â  <button class="btn purple" id="btnPNG">ğŸ“¸ PNG</button>
Â  Â  Â  Â  <button class="btn" id="btnAllComplexesPDB">â¬‡ All Complexes (multi-MODEL PDB)</button>
Â  Â  Â  </div>
Â  Â  Â  <div class="score" id="scoreBox" style="margin-top:8px"></div>
Â  Â  </div>

Â  Â  <div class="card">
Â  Â  Â  <h2>Interface Metrics & Enthalpy</h2>
Â  Â  Â  <div class="metric-grid" id="metricsDisplay"></div>
Â  Â  Â  <h4 style="margin-top:10px">Energy Parameters</h4>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <label>k<sub>elec</sub></label><input type="number" id="kElec" value="0.5" step="0.1">
Â  Â  Â  Â  <label>Elec Cutoff (Ã…)</label><input type="number" id="elecCut" value="12" step="0.5">
Â  Â  Â  Â  <label>Desolv W</label><input type="number" id="wDesolv" value="0.2" step="0.1">
Â  Â  Â  </div>
Â  Â  Â  <div class="infobox small">
Â  Â  Â  Â  <b>Î”H (kcal/mol) â‰ˆ</b> âˆ’0.5Ã—contacts âˆ’2.5Ã—H-bonds âˆ’4.0Ã—salt-bridges âˆ’1.0Ã—hydrophobic +0.3Ã—clash + electrostatics +0.2Ã—contacts (desolv).
Â  Â  Â  </div>
Â  Â  Â  <div class="infobox small"><b>Reproducibility:</b> Outputs include parameters & seed; registry stores signature.</div>
Â  Â  Â  <h3>Complex Summary</h3>
Â  Â  Â  <div class="table-container small">
Â  Â  Â  Â  <table class="table">
Â  Â  Â  Â  Â  <thead><tr><th>Complex</th><th>Top Score</th><th>Contacts</th><th>Î”H</th></tr></thead>
Â  Â  Â  Â  Â  <tbody id="comboSummaryBody"></tbody>
Â  Â  Â  Â  </table>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>
</section>

<section id="cdrTab" class="tabsec" data-tab-panel>
Â  <div class="wrap grid two">
Â  Â  <div class="card">
Â  Â  Â  <h2>CDR Identification & Mapping</h2>
Â  Â  Â  <textarea id="cdrPDB" placeholder="Paste antibody PDB for CDR analysis" style="height:200px"></textarea>
Â  Â  Â  <div class="row" style="margin-top:10px">
Â  Â  Â  Â  <button class="btn primary" onclick="runCDRAnalysis()">Analyze CDRs</button>
Â  Â  Â  Â  <select id="schemeSelect" title="Numbering scheme">
Â  Â  Â  Â  Â  <option value="Kabat">Kabat</option>
Â  Â  Â  Â  Â  <option value="Chothia">Chothia</option>
Â  Â  Â  Â  Â  <option value="IMGT">IMGT</option>
Â  Â  Â  Â  </select>
Â  Â  Â  Â  <button class="btn" onclick="copyAbPDBToCDR()">Use Antibody PDB A</button>
Â  Â  Â  </div>
Â  Â  Â  <div class="scheme-grid" id="cdrResults"></div>
Â  Â  Â  <div class="infobox" style="margin-top:10px">
Â  Â  Â  Â  <strong>Numbering Schemes:</strong><br>
Â  Â  Â  Â  â€¢ <strong>Kabat:</strong> Sequence variability-based. â€¢ <strong>Chothia:</strong> Structural features. â€¢ <strong>IMGT:</strong> Standardized across species.<br>
Â  Â  Â  Â  <span class="small">Heuristic anchoring is used here; for research work, validate with ANARCI/IMGT/AbNum.</span>
Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div class="card">
Â  Â  Â  <h2>CDR Visualization</h2>
Â  Â  Â  <div id="viewerCDR"></div>
Â  Â  Â  <div class="row" style="margin-top:8px">
Â  Â  Â  Â  <label class="chip"><input type="checkbox" id="showCDR1" checked> CDR1</label>
Â  Â  Â  Â  <label class="chip"><input type="checkbox" id="showCDR2" checked> CDR2</label>
Â  Â  Â  Â  <label class="chip"><input type="checkbox" id="showCDR3" checked> CDR3</label>
Â  Â  Â  Â  <label class="chip"><input type="checkbox" id="showFrameworks" checked> Frameworks</label>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>

Â  <div class="wrap">
Â  Â  <div class="card">
Â  Â  Â  <h2>CDR Sequence Details</h2>
Â  Â  Â  <div id="cdrSequenceTable" class="table-container"></div>
Â  Â  </div>
Â  </div>
</section>

<section id="fragmentTab" class="tabsec" data-tab-panel>
Â  <div class="wrap">
Â  Â  <div class="card">
Â  Â  Â  <h2>CA-Trace Fragment Generator</h2>
Â  Â  Â  <div class="grid three">
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <h3>Input PDB</h3>
Â  Â  Â  Â  Â  <textarea id="fragPDB" placeholder="Paste PDB for fragment generation"></textarea>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <h3>Parameters</h3>
Â  Â  Â  Â  Â  <div class="row"><label>Window Size</label><input type="number" id="windowSize" value="10" min="3" max="30"></div>
Â  Â  Â  Â  Â  <div class="row"><label>Step Size</label><input type="number" id="stepSize" value="1" min="1" max="10"></div>
Â  Â  Â  Â  Â  <div class="row"><label>Chain Filter</label><input type="text" id="chainFilter" placeholder="e.g., H,L"></div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <h3>Actions</h3>
Â  Â  Â  Â  Â  <button class="btn primary" onclick="generateFragments()">Generate Fragments</button>
Â  Â  Â  Â  Â  <button class="btn green" onclick="downloadFragments()">â¬‡ Download All</button>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  <div id="fragmentResults" style="margin-top:20px"></div>
Â  Â  </div>
Â  </div>
</section>

<section id="analyzerTab" class="tabsec" data-tab-panel>
    <div class="wrap">
      <div class="card">
        <h2>ğŸ§ª Antibody Fragment Analyzer & Optimizer</h2>
        <p class="lead">Analyze and score antibody candidates based on affinity, stability, internalization, and Fc properties. (Inspired by Goulet & Atkins, 2020)</p>
        
        <div class="grid two">
          <div>
            <h3>Input Candidates (JSON format)</h3>
            <textarea id="analyzerInput" placeholder="Paste JSON array of antibody candidates here..." style="height: 300px;"></textarea>
            <div class="row" style="margin-top: 10px;">
              <button class="btn primary" onclick="runAnalyzer()">â–¶ï¸ Analyze Candidates</button>
              <button class="btn" onclick="loadAnalyzerExample()">Load Example</button>
            </div>
          </div>
          <div>
            <h3>Analysis Results</h3>
            <div class="score" id="analyzerOutput" style="min-height: 350px;">Results will appear here.</div>
          </div>
        </div>
      </div>
    </div>
  </section>

<section id="ligTab" class="tabsec" data-tab-panel>
Â  <div class="wrap grid two">
Â  Â  <div class="card">
Â  Â  Â  <h2>ğŸ’Š Single Ligand Docking</h2>
Â  Â  Â  <div class="small" style="color:#9ca3af">SMILESâ†’3D uses a simplified embedding for demonstration. For research, use RDKit / OpenBabel.</div>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <div style="flex:1;min-width:300px">
Â  Â  Â  Â  Â  <h3>Receptor PDB</h3>
Â  Â  Â  Â  Â  <textarea id="ligReceptorPDB" placeholder="Paste receptor PDB" aria-label="Ligand docking receptor PDB"></textarea>
Â  Â  Â  Â  Â  <div class="row" style="margin-top:6px">
Â  Â  Â  Â  Â  Â  <button class="btn" onclick="loadLigandDemoReceptor()">Load Example</button>
Â  Â  Â  Â  Â  Â  <button class="btn" onclick="parseReceptorForLigand()">Parse & Preview</button>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div style="flex:1;min-width:300px">
Â  Â  Â  Â  Â  <h3>Ligand SMILES</h3>
Â  Â  Â  Â  Â  <textarea id="ligSmiles" placeholder="e.g., CC(=O)Oc1ccccc1C(=O)O (aspirin)" aria-label="Ligand SMILES"></textarea>
Â  Â  Â  Â  Â  <div class="row" style="margin-top:6px">
Â  Â  Â  Â  Â  Â  <label>3D Method</label><select id="ligEmbedMethod"><option value="HASH">HashCloud</option><option value="HELIX">RingHelix</option></select>
Â  Â  Â  Â  Â  Â  <label>Seed</label><input type="number" id="ligSeed" value="1337" style="width:90px" />
Â  Â  Â  Â  Â  Â  <button class="btn primary" onclick="runSingleLigandDock()">â–¶ï¸ Dock</button>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  <div class="infobox small"><b>Note:</b> Posing uses receptor center sampling; score = contacts âˆ’ clash (same core terms).</div>
Â  Â  </div>
Â  Â  <div class="card">
Â  Â  Â  <h2>Ligand Docking Result</h2>
Â  Â  Â  <div id="viewerLig"></div>
Â  Â  Â  <div class="score" id="ligScore" style="margin-top:8px"></div>
Â  Â  Â  <div class="row" style="margin-top:8px">
Â  Â  Â  Â  <button class="btn green" id="btnLigPDB">â¬‡ Complex PDB</button>
Â  Â  Â  Â  <button class="btn" id="btnLigCSV">â¬‡ CSV Result</button>
Â  Â  Â  Â  <span class="pill" id="ligStatus" aria-live="polite">idle</span>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>
</section>

<section id="screenTab" class="tabsec" data-tab-panel>
Â  <div class="wrap">
Â  Â  <div class="card">
Â  Â  Â  <h2>ğŸ“š Batch Screening (â‰¤50 SMILES Ã— â‰¤3 Receptors)</h2>
Â  Â  Â  <div class="grid three">
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <h3>SMILES Library</h3>
Â  Â  Â  Â  Â  <textarea id="scrSmiles" placeholder="One SMILES per line (max 50)"></textarea>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <h3>Receptors (PDBs)</h3>
Â  Â  Â  Â  Â  <textarea id="scrReceptors" placeholder="Paste 2â€“3 PDBs separated by a line with only: END"></textarea>
Â  Â  Â  Â  Â  <div class="small" style="color:#9ca3af">Delimiter must be exactly â€œENDâ€ on its own line.</div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div>
Â  Â  Â  Â  Â  <h3>Parameters</h3>
Â  Â  Â  Â  Â  <div class="row"><label>Samples/Ligand</label><input type="number" id="scrSamples" value="5000" min="1000" step="500" /></div>
Â  Â  Â  Â  Â  <div class="row"><label>Contact (Ã…)</label><input type="number" id="scrContactCut" value="4.8" step="0.1" /></div>
Â  Â  Â  Â  Â  <div class="row"><label>Clash Factor</label><input type="number" id="scrClashFactor" value="0.85" step="0.05" /></div>
Â  Â  Â  Â  Â  <div class="row"><label>Seed</label><input type="number" id="scrSeed" value="777" /></div>
Â  Â  Â  Â  Â  <div class="row"><label>3D Method</label><select id="scrEmbedMethod"><option value="HASH">HashCloud</option><option value="HELIX">RingHelix</option></select></div>
Â  Â  Â  Â  Â  <div class="row"><label>Sort</label>
Â  Â  Â  Â  Â  Â  <select id="scrSort"><option value="score">Score â†“</option><option value="enthalpy">Î”H â†‘ (most negative)</option><option value="consensus" selected>Consensus (rank-sum)</option></select>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  <div class="row" style="margin-top:10px"><button class="btn primary" id="btnStartScreen">â–¶ï¸ Start Screening</button><button class="btn red" id="btnStopScreen" disabled>âœ– Stop</button></div>
Â  Â  Â  Â  Â  <div class="infobox small">Sequential SMILESÃ—Receptor; consensus = rank(scoreâ†“, Î”Hâ†‘, contactsâ†“).</div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div class="card">
Â  Â  Â  <h2>Results</h2>
Â  Â  Â  <div class="row" style="margin-bottom:8px">
Â  Â  Â  Â  <button class="btn green" id="btnScrCSV">â¬‡ Full Results CSV</button>
Â  Â  Â  Â  <button class="btn" id="btnScrJSON">â¬‡ JSON Export</button>
Â  Â  Â  Â  <button class="btn purple" id="btnScrTop10">ğŸ“Š Show Top 10</button>
Â  Â  Â  Â  <span class="pill" id="scrStatus" aria-live="polite">idle</span>
Â  Â  Â  Â  <span class="small" id="scrProgress" style="color:#9ca3af"></span>
Â  Â  Â  </div>
Â  Â  Â  <div class="table-container" style="max-height:460px">
Â  Â  Â  Â  <table class="table" id="scrTable">
Â  Â  Â  Â  Â  <thead><tr>
Â  Â  Â  Â  Â  Â  <th>#</th><th>Receptor</th><th>SMILES</th><th>Score</th><th>Contacts</th><th>H-bonds</th><th>SaltBr</th><th>Clash</th><th>Î”H (kcal/mol)</th><th>CRank</th>
Â  Â  Â  Â  Â  </tr></thead>
Â  Â  Â  Â  Â  <tbody id="scrTableBody"></tbody>
Â  Â  Â  Â  </table>
Â  Â  Â  </div>
Â  Â  Â  <div id="viewerScr" style="height:420px;margin-top:12px"></div>
Â  Â  Â  <div class="small" style="text-align:center;color:#9ca3af;margin-top:4px">Click a row to visualize that docked pose.</div>
Â  Â  </div>

Â  Â  <div class="card">
Â  Â  Â  <h2>Enthalpy Distribution</h2>
Â  Â  Â  <div class="metric-grid" id="screenMetrics"></div>
Â  Â  Â  <div class="score" id="enthalpyBreakdown" style="margin-top:8px"></div>
Â  Â  Â  <div class="infobox small"><b>Interpretation:</b> more negative Î”H â‡’ stronger binding (approximate; entropy not included).</div>
Â  Â  </div>
Â  </div>
</section>

<section id="qaTab" class="tabsec" data-tab-panel>
Â  <div class="wrap grid two">
Â  Â  <div class="card">
Â  Â  Â  <h2>ğŸ“‹ Run Registry & Session Management</h2>
Â  Â  Â  <div class="row" style="margin-top:6px">
Â  Â  Â  Â  <button class="btn green" onclick="saveCurrentRun()">ğŸ’¾ Save Current Run</button>
Â  Â  Â  Â  <button class="btn" onclick="refreshRunRegistry()">ğŸ”„ Refresh</button>
Â  Â  Â  Â  <button class="btn" onclick="exportAllRuns()">â¬‡ Export Registry</button>
Â  Â  Â  Â  <button class="btn purple" onclick="importRunRegistry()">â¬† Import Registry</button>
Â  Â  Â  Â  <button class="btn red" onclick="clearRunRegistry()">ğŸ—‘ï¸ Clear</button>
Â  Â  Â  </div>
Â  Â  Â  <input type="file" id="importRegistryFile" accept=".json" style="display:none" />
Â  Â  Â  <div class="table-container" style="margin-top:10px">
Â  Â  Â  Â  <table class="table">
Â  Â  Â  Â  Â  <thead><tr><th>Timestamp</th><th>Type</th><th>Description</th><th>Top Score</th><th>Signature</th><th>Actions</th></tr></thead>
Â  Â  Â  Â  Â  <tbody id="registryTableBody"></tbody>
Â  Â  Â  Â  </table>
Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div class="card">
Â  Â  Â  <h2>âœ… Quality Assurance (Reproducibility)</h2>
Â  Â  Â  <div class="row" style="margin-top:6px">
Â  Â  Â  Â  <label>Repeats</label><input type="number" id="qaRepeats" value="3" min="2" max="10" style="width:90px" />
Â  Â  Â  Â  <label>Tolerance</label><input type="number" id="qaTolerance" value="0.01" step="0.01" style="width:90px" />
Â  Â  Â  Â  <button class="btn primary" onclick="runQATest()">â–¶ï¸ Run QA Test</button>
Â  Â  Â  </div>
Â  Â  Â  <div class="score" id="qaResults" style="margin-top:10px;min-height:120px"></div>
Â  Â  Â  <div class="infobox small">Runs N repeats with same seed; passes if top scores within tolerance.</div>
Â  Â  </div>
Â  </div>
</section>

<section id="analysisTab" class="tabsec" data-tab-panel>
Â  <div class="wrap">
Â  Â  <div class="card">
Â  Â  Â  <h2>ğŸ“Š Analysis Tools</h2>
Â  Â  Â  <div class="tabs" style="margin-top:6px">
Â  Â  Â  Â  <button class="tabbtn active" data-subtab="energyTab">Energy Decomposition</button>
Â  Â  Â  Â  <button class="tabbtn" data-subtab="compareTab">Pose Comparison</button>
Â  Â  Â  Â  <button class="tabbtn" data-subtab="residueTab">Residue Contacts</button>
Â  Â  Â  </div>
Â  Â  Â  <div id="energyTab" class="tabsec active">
Â  Â  Â  Â  <h3>Energy Component Analysis</h3>
Â  Â  Â  Â  <div id="energyComponents" class="metric-grid"></div>
Â  Â  Â  Â  <h4>Î”H Details</h4>
Â  Â  Â  Â  <div class="score" id="enthalpyDetail"></div>
Â  Â  Â  </div>
Â  Â  Â  <div id="compareTab" class="tabsec">
Â  Â  Â  Â  <h3>Compare Poses</h3>
Â  Â  Â  Â  <div class="row">
Â  Â  Â  Â  Â  <label>Pose 1</label><select id="comparePose1"></select>
Â  Â  Â  Â  Â  <label>Pose 2</label><select id="comparePose2"></select>
Â  Â  Â  Â  Â  <button class="btn primary" onclick="comparePoses()">Compare</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="grid two" style="margin-top:10px">
Â  Â  Â  Â  Â  <div><div id="viewerComp" style="height:420px"></div></div>
Â  Â  Â  Â  Â  <div><div class="score" id="comparisonResults" style="min-height:420px"></div></div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  <div id="residueTab" class="tabsec">
Â  Â  Â  Â  <h3>Residue-Level Contacts</h3>
Â  Â  Â  Â  <div class="row">
Â  Â  Â  Â  Â  <label>Min Dist (Ã…)</label><input type="number" id="filterMinDist" value="0" step="0.5" style="width:90px" />
Â  Â  Â  Â  Â  <label>Max Dist (Ã…)</label><input type="number" id="filterMaxDist" value="6" step="0.5" style="width:90px" />
Â  Â  Â  Â  Â  <button class="btn" onclick="filterResidueContacts()">Filter</button>
Â  Â  Â  Â  Â  <button class="btn green" onclick="exportResidueData()">â¬‡ Export</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="table-container" style="margin-top:8px">
Â  Â  Â  Â  Â  <table class="table">
Â  Â  Â  Â  Â  Â  <thead><tr><th>Residue A</th><th>Chain A</th><th>Residue B</th><th>Chain B</th><th>Distance (Ã…)</th><th>Type</th><th>Energy</th></tr></thead>
Â  Â  Â  Â  Â  Â  <tbody id="residueTableBody"></tbody>
Â  Â  Â  Â  Â  </table>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>
</section>

<section id="omicsTab" class="tabsec" data-tab-panel>
Â  <div class="wrap">
Â  Â  <div class="card">
Â  Â  Â  <h2>ğŸ”¬ Virtual Omics Analysis of a Theoretical Eukaryotic Cell</h2>
Â  Â  Â  <div class="infobox">This is a theoretical analysis for educational purposes. It illustrates data types from proteomics, lipidomics, and metabolomics, using glycolysis as the example pathway.</div>

Â  Â  Â  <div class="tabs" style="margin-top:6px">
Â  Â  Â  Â  <button class="tabbtn active" data-subtab="proteomicsTab">Proteomics</button>
Â  Â  Â  Â  <button class="tabbtn" data-subtab="lipidomicsTab">Lipidomics</button>
Â  Â  Â  Â  <button class="tabbtn" data-subtab="metabolomicsTab">Metabolomics</button>
Â  Â  Â  </div>

Â  Â  Â  <div id="proteomicsTab" class="tabsec active">
Â  Â  Â  Â  <h3>Protein Input (optional PDB for descriptors)</h3>
Â  Â  Â  Â  <textarea id="omicsProteinPDB" placeholder="Paste protein PDB (optional)"></textarea>
Â  Â  Â  Â  <div class="row" style="margin-top:6px">
Â  Â  Â  Â  Â  <button class="btn" id="omicsLoadProteinDemo">Load Protein Demo</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <h3>Virtual Proteomics: Glycolytic Enzymes</h3>
Â  Â  Â  Â  <div class="table-container">
Â  Â  Â  Â  Â  <table class="table">
Â  Â  Â  Â  Â  Â  <thead><tr><th>Protein (Enzyme)</th><th>Subcellular Location</th><th>Function in Glycolysis</th></tr></thead>
Â  Â  Â  Â  Â  Â  <tbody>
Â  Â  Â  Â  Â  Â  Â  <tr><td>Hexokinase (HK)</td><td>Cytosol (near mitochondria)</td><td>Glucose â†’ glucose-6-phosphate.</td></tr>
Â  Â  Â  Â  Â  Â  Â  <tr><td>PFK-1</td><td>Cytosol</td><td>Committed step to F1,6BP.</td></tr>
Â  Â  Â  Â  Â  Â  Â  <tr><td>GAPDH</td><td>Cytosol</td><td>Oxidation step; NADH.</td></tr>
Â  Â  Â  Â  Â  Â  Â  <tr><td>Pyruvate Kinase</td><td>Cytosol</td><td>PEP + ADP â†’ ATP + pyruvate.</td></tr>
Â  Â  Â  Â  Â  Â  </tbody>
Â  Â  Â  Â  Â  </table>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>

Â  Â  Â  <div id="lipidomicsTab" class="tabsec">
Â  Â  Â  Â  <h3>Lipid SMILES (one per line)</h3>
Â  Â  Â  Â  <textarea id="omicsLipidSmiles" placeholder="Enter lipid SMILES, one per line"></textarea>
Â  Â  Â  Â  <div class="row" style="margin-top:6px"><button class="btn" id="omicsLoadLipidDemo">Load Lipid Demo</button></div>
Â  Â  Â  </div>

Â  Â  Â  <div id="metabolomicsTab" class="tabsec">
Â  Â  Â  Â  <h3>Carbohydrate SMILES (one per line) & DNA (FASTA-like)</h3>
Â  Â  Â  Â  <textarea id="omicsCarbSmiles" placeholder="Enter carbohydrate SMILES, one per line"></textarea>
Â  Â  Â  Â  <div class="row" style="margin-top:6px"><button class="btn" id="omicsLoadCarbDemo">Load Carb Demo</button></div>
Â  Â  Â  Â  <h3 style="margin-top:8px">DNA (FASTA)</h3>
Â  Â  Â  Â  <textarea id="omicsDNA" placeholder=">id&#10;ACGT..."></textarea>
Â  Â  Â  Â  <div class="row" style="margin-top:6px"><button class="btn" id="omicsLoadDNADemo">Load DNA Demo</button></div>
Â  Â  Â  </div>

Â  Â  Â  <div class="row" style="margin-top:10px">
Â  Â  Â  Â  <button class="btn primary" id="omicsAnalyzeBtn">â–¶ï¸ Analyze</button>
Â  Â  Â  Â  <button class="btn green" id="omicsExportBtn">â¬‡ Export JSON</button>
Â  Â  Â  Â  <span class="pill" id="omicsStatus" aria-live="polite">idle</span>
Â  Â  Â  </div>

Â  Â  Â  <div class="grid two" style="margin-top:10px">
Â  Â  Â  Â  <div class="card">
Â  Â  Â  Â  Â  <h3>Descriptors</h3>
Â  Â  Â  Â  Â  <div class="table-container">
Â  Â  Â  Â  Â  Â  <table class="table">
Â  Â  Â  Â  Â  Â  Â  <thead><tr><th>Key</th><th>Value</th></tr></thead>
Â  Â  Â  Â  Â  Â  Â  <tbody id="omicsDescriptorBody"></tbody>
Â  Â  Â  Â  Â  Â  </table>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="card">
Â  Â  Â  Â  Â  <h3>Trends</h3>
Â  Â  Â  Â  Â  <div class="score" id="omicsTrends" style="min-height:220px"></div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>
</section>

<section id="nmrTab" class="tabsec" data-tab-panel>
Â  <div class="wrap grid two">
Â  Â  <div class="card">
Â  Â  Â  <h2>ğŸ“¡ Theoretical NMR Prediction</h2>
Â  Â  Â  <div class="infobox small">Enter a SMILES string to get a theoretical description of what its NMR spectra might look like. This is an educational guide, not a simulator.</div>
Â  Â  Â  <h3>SMILES Input</h3>
Â  Â  Â  <textarea id="nmrSmiles" placeholder="Enter SMILES string">CC(=O)Oc1ccccc1C(=O)O</textarea>
Â  Â  Â  <h3>Structure Preview</h3>
Â  Â  Â  <div id="nmrMoleculeImage"></div>
Â  Â  Â  <div class="row">
Â  Â  Â  Â  <button class="btn primary" id="btnPredict1H">Predict Â¹H NMR</button>
Â  Â  Â  Â  <button class="btn" id="btnPredict13C">Predict Â¹Â³C NMR</button>
Â  Â  Â  Â  <button class="btn" id="btnPredictCOSY">Predict COSY</button>
Â  Â  Â  Â  <button class="btn" id="btnPredictNOESY">Predict NOESY</button>
Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div class="card">
Â  Â  Â  <h2>Prediction Output</h2>
Â  Â  Â  <div class="score" id="nmrPredictionOutput" style="min-height:300px">Prediction results will appear here.</div>
Â  Â  </div>
Â  </div>
</section>

<section id="aboutTab" class="tabsec" data-tab-panel>
Â  <div class="wrap">
Â  Â  <div class="card">
Â  Â  Â  <h2>About</h2>
Â  Â  Â  <p>This educational platform demonstrates in-browser docking with parallel sampling, simplified scoring, and interactive visualization. All computations run locally; nothing is uploaded.</p>
Â  Â  Â  <h3>Important Disclaimers</h3>
Â  Â  Â  <div class="errorbox">
Â  Â  Â  Â  <p><b>No warranties; use at your own risk.</b></p>
Â  Â  Â  Â  <p>Scoring/embedding are simplified approximations; entropy, solvation, polarization, water networks, induced fit, glycan effects, and protonation/tautomer states are not fully modeled. <b>Always double-check results and verify with experiments (e.g., SPR/ITC, crystallography, MD, MM-PBSA/FEP).</b> Compare against professional tools.</p>
Â  Â  Â  Â  <p><b>Regulatory note:</b> This is not validated for GLP/Part 11/CSV and is not suitable for regulated decision-making. Educational/research prototyping only.</p>
Â  Â  Â  </div>
Â  Â  Â  <h3>Recommended Workflow</h3>
Â  Â  Â  <div class="infobox small">Use for hypothesis generation â†’ export top poses â†’ refine with AutoDock/HADDOCK/Rosetta â†’ MD â†’ MM-PBSA/FEP â†’ <b>experimental validation</b>.</div>
Â  Â  Â  <h3>Credits</h3>
Â  Â  Â  <div class="small" style="color:#9ca3af">Lead & Concept: <b>DJF â€” The New Chemist</b> â€¢ 3D rendering: 3Dmol.js â€¢ Compression: Pako â€¢ Structures: RCSB PDB</div>
Â  Â  </div>
Â  </div>
</section>

<footer>
Â  <div class="wrap">
Â  Â  <p><b>Educational Use Only.</b> Results are approximate. <b>Always double-check and verify with experiments</b> before making conclusions or decisions.</p>
Â  Â  <p class="small">Â© Student Edition â€¢ No warranties â€¢ We disclaim any loss in any way â€¢ Validate results independently</p>
Â  </div>
</footer>

<script>
// Robust Antibody Fragment Analyzer & Optimizer (Integrated)
// Inspired by Goulet & Atkins, 2020: "Design of Antibody-Based Therapeutics"

class AntibodyFragment {
Â  constructor({
Â  Â  name,
Â  Â  affinityKD, // nM
Â  Â  kon = null, // optional kinetic on-rate
Â  Â  koff = null, // optional kinetic off-rate
Â  Â  internalizationRate, // 0-1
Â  Â  stabilityScore, // 0-1
Â  Â  aggregationRisk = 0.5, // 0-1, default
Â  Â  epitopeClass,
Â  Â  subclass,
Â  Â  glycosylationSites = 1, // number of glycosylation sites (Asn297 etc.)
Â  Â  fcEngineering = false, // boolean if Fc-engineered
Â  }) {
Â  Â  this.name = name;
Â  Â  this.affinityKD = affinityKD;
Â  Â  this.kon = kon;
Â  Â  this.koff = koff;
Â  Â  this.internalizationRate = internalizationRate;
Â  Â  this.stabilityScore = stabilityScore;
Â  Â  this.aggregationRisk = aggregationRisk;
Â  Â  this.epitopeClass = epitopeClass;
Â  Â  this.subclass = subclass;
Â  Â  this.glycosylationSites = glycosylationSites;
Â  Â  this.fcEngineering = fcEngineering;
Â  }

Â  getAffinityScore() {
Â  Â  if (this.affinityKD < 0.01) return 3; // too tight
Â  Â  if (this.affinityKD <= 1) return 10;
Â  Â  if (this.affinityKD <= 10) return 8;
Â  Â  return 5;
Â  }

Â  getDevelopabilityPenalty() {
Â  Â  return (1 - this.stabilityScore) + this.aggregationRisk;
Â  }

Â  getFcScore() {
Â  Â  const baseScores = {
Â  Â  Â  IgG1: 10, IgG3: 9, IgG2: 5, IgG4: 3, IgA: 7, IgM: 8
Â  Â  };
Â  Â  let score = baseScores[this.subclass] || 5;
Â  Â  if (this.fcEngineering) score += 1.5; // engineered Fc for enhanced ADCC/CDC or half-life
Â  Â  return score;
Â  }

Â  getEpitopeBonus() {
Â  Â  const bonuses = {
Â  Â  Â  synergistic: 10,
Â  Â  Â  non_overlapping: 9,
Â  Â  Â  agonistic: 8,
Â  Â  Â  inhibitory: 7,
Â  Â  Â  neutralizing: 6,
Â  Â  };
Â  Â  return bonuses[this.epitopeClass] || 5;
Â  }

Â  getInternalizationScore() {
Â  Â  // >0.7 is ideal for ADC delivery
Â  Â  if (this.internalizationRate >= 0.9) return 10;
Â  Â  if (this.internalizationRate >= 0.7) return 9;
Â  Â  if (this.internalizationRate >= 0.5) return 7;
Â  Â  return 4;
Â  }

Â  getTotalScore() {
Â  Â  const affinity = this.getAffinityScore();
Â  Â  const internalization = this.getInternalizationScore();
Â  Â  const stability = this.stabilityScore * 10;
Â  Â  const epitope = this.getEpitopeBonus();
Â  Â  const fc = this.getFcScore();
Â  Â  const penalty = this.getDevelopabilityPenalty();

Â  Â  // Weighted scoring
Â  Â  const raw = (
Â  Â  Â  affinity * 0.25 +
Â  Â  Â  internalization * 0.2 +
Â  Â  Â  stability * 0.15 +
Â  Â  Â  epitope * 0.2 +
Â  Â  Â  fc * 0.2
Â  Â  ) - penalty * 1.2;

Â  Â  return Math.max(raw.toFixed(2), 0); // ensure no negative scores
Â  }

Â  explainFragment() {
Â  Â  return `\nğŸ§¬ Fragment: ${this.name}
Â  Affinity (KD): ${this.affinityKD} nM â†’ Score: ${this.getAffinityScore()}Â 
Â  Internalization Rate: ${this.internalizationRate} â†’ Score: ${this.getInternalizationScore()}Â 
Â  Stability Score: ${this.stabilityScore} â†’ Weighted: ${(this.stabilityScore * 10).toFixed(2)}
Â  Aggregation Risk: ${this.aggregationRisk}
Â  Epitope Type: ${this.epitopeClass} â†’ Bonus: ${this.getEpitopeBonus()}
Â  Fc Subclass: ${this.subclass} ${this.fcEngineering ? '(Fc-engineered)' : ''} â†’ Score: ${this.getFcScore()}
Â  Glycosylation Sites: ${this.glycosylationSites}
Â  Developability Penalty: ${this.getDevelopabilityPenalty().toFixed(2)}
Â  â†’ ğŸ§  Total Score: ${this.getTotalScore()} / 10\n`;
Â  }
}


/* ===== Shared state & helpers ===== */
let viewer=null, viewerLig=null, viewerScr=null, viewerComp=null, viewerCDR=null;
let inProgress=false, cancelled=false, workerPool=[];
let pdbAAllAtoms=[], pdbBAllAtoms=[];
let combos=[], currentComboIndex=-1;
let currentContacts=[], currentHB=[], currentSB=[], currentHydro=[];
let ligLastResult={}, screenCancel=false, screenResults=[], screenReceptors=[];
const REGISTRY_KEY='docking_registry_v2';

const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
const hydrophobic=new Set(['ALA','VAL','LEU','ILE','PRO','PHE','MET','TRP','TYR','CYS']);
const residueCharges={'ASP':-1,'GLU':-1,'LYS':+1,'ARG':+1,'HIS':+0.1};

const E=id=>document.getElementById(id);
const status=t=>E('statusPill').textContent=t;
const setProgress=f=>{E('prog').value=Math.max(0,Math.min(1,f||0));};

window.addEventListener('DOMContentLoaded', ()=>{
Â  ensureViewer('viewer'); ensureViewer('viewerLig'); ensureViewer('viewerScr'); ensureViewer('viewerComp'); ensureViewer('viewerCDR');
Â  drawPlaceholder(viewer);
Â  setupMainTabs();
Â  setupSubTabs();
Â  bindEvents();
Â  bindOmicsAndNMREvents();
Â  bindCDRControls();
Â  loadSessionHistory();
Â  // setTimeout(autoDemo, 300); // Disabled autoDemo on load to allow user interaction first

Â  const rib = E('toggleRibbon');
Â  if (rib) { rib.addEventListener('change', ()=>{ if (!combos.length) return; const idx = combos[currentComboIndex]?.currentIndex ?? 0; showPose(idx); }); }
});

/* Tabs */
function setupMainTabs(){
Â  document.querySelectorAll('.tabbtn[data-tab]').forEach(btn=>{
Â  Â  btn.addEventListener('click',()=>{
Â  Â  Â  document.querySelectorAll('.tabbtn[data-tab]').forEach(b=>b.classList.remove('active'));
Â  Â  Â  btn.classList.add('active');
Â  Â  Â  const target=btn.dataset.tab;
Â  Â  Â  document.querySelectorAll('[data-tab-panel]').forEach(sec=>{ sec.classList.toggle('active', sec.id===target); });
Â  Â  Â  requestAnimationFrame(()=>{
Â  Â  Â  Â  try{ viewer?.resize(); viewerLig?.resize(); viewerScr?.resize(); viewerComp?.resize(); viewerCDR?.resize();
Â  Â  Â  Â  Â  Â  Â viewer?.render(); viewerLig?.render(); viewerScr?.render(); viewerComp?.render(); viewerCDR?.render(); }catch(e){}
Â  Â  Â  });
Â  Â  });
Â  });
}
function setupSubTabs(){
Â  document.querySelectorAll('.tabbtn[data-subtab]').forEach(btn=>{
Â  Â  btn.addEventListener('click',()=>{
Â  Â  Â  const wrap=btn.closest('.card');
Â  Â  Â  wrap.querySelectorAll('.tabbtn[data-subtab]').forEach(b=>b.classList.remove('active'));
Â  Â  Â  wrap.querySelectorAll('.tabsec').forEach(s=>s.classList.remove('active'));
Â  Â  Â  btn.classList.add('active');
Â  Â  Â  const tgt=wrap.querySelector('#'+btn.dataset.subtab);
Â  Â  Â  if (tgt) tgt.classList.add('active');
Â  Â  Â  requestAnimationFrame(()=>{ viewerComp?.resize(); viewerComp?.render(); });
Â  Â  });
Â  });
}

/* Viewers */
function ensureViewer(id){
Â  const el=E(id); if(!el) return;
Â  const opt={backgroundColor:'#0a0f1a'};
  try {
    if(id==='viewer' && !viewer) viewer=$3Dmol.createViewer(el,opt);
    else if(id==='viewerLig' && !viewerLig) viewerLig=$3Dmol.createViewer(el,opt);
    else if(id==='viewerScr' && !viewerScr) viewerScr=$3Dmol.createViewer(el,opt);
    else if(id==='viewerComp' && !viewerComp) viewerComp=$3Dmol.createViewer(el,opt);
    else if(id==='viewerCDR' && !viewerCDR) viewerCDR=$3Dmol.createViewer(el,opt);
  } catch (e) {
    console.error("Failed to initialize 3Dmol viewer:", id, e);
  }
}
function drawPlaceholder(v){
Â  if(!v) return; v.addSphere({center:{x:-8,y:0,z:0},radius:4,color:'#60a5fa',alpha:.6});
Â  v.addSphere({center:{x:8,y:0,z:0},radius:4,color:'#f97316',alpha:.6});
Â  v.zoomTo(); v.render();
}

/* Events */
function bindEvents(){
Â  // global
Â  E('btnDemo').addEventListener('click', autoDemo);
Â  E('btnSaveSession').addEventListener('click', saveSession);
Â  E('btnLoadSession').addEventListener('click', loadSession);

Â  // docking
Â  E('dockBtn').addEventListener('click', runAntibodyDocking);
Â  E('cancelBtn').addEventListener('click', cancelDocking);
Â  E('resetBtn').addEventListener('click', resetAll);

Â  // complex selector
Â  E('comboSelect').addEventListener('change', ()=>{ setCurrentCombo(parseInt(E('comboSelect').value)||0); });
Â  E('btnPrevCombo').addEventListener('click', ()=>{ if(combos.length) setCurrentCombo((currentComboIndex-1+combos.length)%combos.length); });
Â  E('btnNextCombo').addEventListener('click', ()=>{ if(combos.length) setCurrentCombo((currentComboIndex+1)%combos.length); });
Â  E('btnClusters').addEventListener('click', clusterCurrentPoses);

Â  // exports
Â  E('btnAllPDB').addEventListener('click', downloadAllPoses);
Â  E('btnCurrentPDB').addEventListener('click', downloadCurrentPose);
Â  E('btnCSV').addEventListener('click', downloadCSV);
Â  E('btnJSON').addEventListener('click', downloadJSON);
Â  E('btnPNG').addEventListener('click', ()=>snapshotPNG(viewer));
Â  E('btnAllComplexesPDB').addEventListener('click', downloadAllComplexesPDB);

Â  // overlays
Â  ['toggleContacts','toggleHB','toggleSB','toggleHydro'].forEach(id=>E(id).addEventListener('change', refreshOverlays));

Â  // file inputs
Â  E('pdbAFile').addEventListener('change', e=>handleFileUpload('A', e.target.files[0]));
Â  E('pdbBFile').addEventListener('change', e=>handleFileUpload('B', e.target.files[0]));

Â  // ligand docking
Â  E('btnLigPDB').addEventListener('click', downloadLigandPDB);
Â  E('btnLigCSV').addEventListener('click', downloadLigandCSV);

Â  // screening
Â  E('btnStartScreen').addEventListener('click', startBatchScreening);
Â  E('btnStopScreen').addEventListener('click', ()=>{screenCancel=true;E('btnStopScreen').disabled=true;});
Â  E('btnScrCSV').addEventListener('click', downloadScreeningCSV);
Â  E('btnScrJSON').addEventListener('click', downloadScreeningJSON);
Â  E('btnScrTop10').addEventListener('click', showTop10Screening);
}

/* Utils */
async function fileToText(file){
Â  const name=(file?.name||'').toLowerCase(); const buf=await file.arrayBuffer();
Â  if(name.endsWith('.gz')){
    if (typeof pako === 'undefined') { throw new Error("Pako library not loaded for .gz decompression."); }
    const u8=new Uint8Array(buf); const out=pako.inflate(u8); return new TextDecoder().decode(out);
  }Â 
Â  return new TextDecoder().decode(buf);
}
async function handleFileUpload(which,file){
Â  if(!file) return;
Â  try{ const text=await fileToText(file); E(which==='A'?'pdbAText':'pdbBText').value=text; parseOne(which); }
Â  catch(e){ alert('Error reading file: '+e.message); }
}
async function fetchPDBFromRCSB(which){
Â  const pdbId=prompt(`Enter 4-character PDB ID for Protein ${which}:`); if(!pdbId) return;
Â  const id=pdbId.trim().toLowerCase(); if(id.length!==4){alert('PDB ID must be 4 chars');return;}
Â  try{
Â  Â  status(`fetching ${id}â€¦`);
Â  Â  const res=await fetch(`https://files.rcsb.org/download/${id}.pdb`);
Â  Â  if(!res.ok) throw new Error('RCSB error');
Â  Â  const txt=await res.text();
Â  Â  E(which==='A'?'pdbAText':'pdbBText').value=txt;
Â  Â  await parseOne(which); status('idle');
Â  }catch(e){ alert('Fetch failed: '+e.message); status('error'); }
}
function centroid(pts){ let x=0,y=0,z=0; for(const p of pts){x+=p.x;y+=p.y;z+=p.z;} const n=pts.length||1; return {x:x/n,y:y/n,z:z/n};}
function translate(points,t){return points.map(p=>({...p,x:p.x+t.x,y:p.y+t.y,z:p.z+t.z}));}
function formatPDB(atoms,chainShift=0){
Â  const lines=[]; let serial=1;
Â  for(const a of atoms){
Â  Â  const name=(a.name||'CA').padStart(4,' ');
Â  Â  const resn=(a.resn||'RES').padStart(3,' ');
Â  Â  const chain=String((a.chain||'A')).slice(0,1);
Â  Â  const chainOut=String.fromCharCode(chain.charCodeAt(0)+(chainShift||0));
Â  Â  const resi=String(a.resi||1).padStart(4,' ');
Â  Â  const x=isFinite(a.x)?a.x:0, y=isFinite(a.y)?a.y:0, z=isFinite(a.z)?a.z:0;
Â  Â  const xs=x.toFixed(3).padStart(8,' '), ys=y.toFixed(3).padStart(8,' '), zs=z.toFixed(3).padStart(8,' ');
Â  Â  const elem=(a.elem||'C').toString().padStart(2,' ');
Â  Â  lines.push(`ATOMÂ  ${String(serial).padStart(5,' ')} ${name} ${resn} ${chainOut}${resi}Â  Â  ${xs}${ys}${zs}Â  1.00Â  0.00Â  Â  Â  Â  Â  ${elem}`);
Â  Â  serial++;
Â  }
Â  lines.push('TER','ENDMDL','END'); return lines.join('\n');
}
function downloadBlob(text, filename){
Â  const url=URL.createObjectURL(new Blob([text],{type:'text/plain'}));
Â  const a=document.createElement('a'); a.href=url; a.download=filename; a.click();
Â  setTimeout(()=>URL.revokeObjectURL(url),1000);
}
function snapshotPNG(v){
Â  try{ v.render(); v.pngURI((uri)=>{ const a=document.createElement('a'); a.href=uri; a.download='viewer.png'; a.click(); }); }
Â  catch(e){ alert('PNG failed: '+e.message);}
}

/* PDB parsing / chains */
function parsePDB(text){
Â  const atoms=[]; if(!text) return atoms;
Â  const lines=String(text).split(/\r?\n/);
Â  for(const line of lines){
Â  Â  if(!(line.startsWith('ATOM')||line.startsWith('HETATM'))) continue;
Â  Â  if(line.length<54) continue;
Â  Â  const name=(line.substring(12,16)||'').trim();
Â  Â  const resn=(line.substring(17,20)||'').trim()||'UNK';
Â  Â  const chain=(line.substring(21,22)||'A').trim()||'A';
Â  Â  const resiStr=(line.substring(22,26)||'').trim(); const resi=parseInt(resiStr||'0')||1;
Â  Â  const xf=(s,a,b)=>parseFloat((s.substring(a,b)||'').trim());
Â  Â  const x=xf(line,30,38), y=xf(line,38,46), z=xf(line,46,54);
Â  Â  if(!isFinite(x)||!isFinite(y)||!isFinite(z)) continue;
Â  Â  let elem=(line.length>=78? (line.substring(76,78)||'').trim(): '')||name.trim()[0]||'C';
Â  Â  elem=String(elem).toUpperCase();
Â  Â  atoms.push({name,resn,chain,resi,x,y,z,elem});
Â  }
Â  return atoms;
}
async function parseOne(which){
Â  const t = E(which==='A'?'pdbAText':'pdbBText').value.trim();
Â  if(!t){ alert('Paste PDB or upload file first.'); return; }
Â  const atoms=parsePDB(t);
Â  if(!atoms.length){ alert('No atoms parsed â€” check PDB formatting.'); return; }
Â  if(which==='A'){ pdbAAllAtoms=atoms; populateChainChips('A',atoms); E('badgeA').textContent=`${atoms.length} atoms`; }
Â  else{ pdbBAllAtoms=atoms; populateChainChips('B',atoms); E('badgeB').textContent=`${atoms.length} atoms`; }
}
function populateChainChips(which, atoms){
Â  const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.innerHTML='';
Â  const chains=[...new Set(atoms.map(a=>a.chain||'A'))];
Â  chains.forEach(c=>{
Â  Â  const id=`${which}_ch_${c}`;
Â  Â  const lbl=document.createElement('label'); lbl.className='chip';
Â  Â  lbl.innerHTML=`<input type="checkbox" id="${id}" data-which="${which}" data-chain="${c}" checked> ${c}`;
Â  Â  box.appendChild(lbl);
Â  });
Â  const warn=which==='A'?E('chainWarnA'):E('chainWarnB');
Â  warn.className='successbox small';
Â  warn.textContent=`âœ“ Parsed ${atoms.length} atoms â€¢ Chains: ${chains.join(', ')||'â€”'}`;
}
function selectedChains(which){
Â  const box=which==='A'?E('chainsABox'):E('chainsBBox');
Â  const selected=[...box.querySelectorAll('input[type=checkbox]')].filter(cb=>cb.checked).map(cb=>cb.dataset.chain);
Â  return new Set(selected);
}
function selectAllChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=true); }
function invertChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=!cb.checked); }
function filterChains(atoms, keep){ if(!keep||keep.size===0) return atoms; return atoms.filter(a=>keep.has(a.chain)); }
function selectAtomSet(atoms, mode){ const bb=new Set(['N','CA','C','O']); return atoms.filter(a=>{ if(mode==='CA') return a.name==='CA'; if(mode==='BB') return bb.has(a.name); return a.elem!=='H'; }); }

/* Worker (sampling/scoring) */
function makeDockWorker(){
Â  const code=`
Â  Â  const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
Â  Â  function rand(seed){let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);}
Â  Â  function randomQuat(r){const u1=r(),u2=r(),u3=r(); const a=Math.sqrt(1-u1),b=Math.sqrt(u1),t1=2*Math.PI*u2,t2=2*Math.PI*u3; return [a*Math.sin(t1),a*Math.cos(t1),b*Math.sin(t2),b*Math.cos(t2)];}
Â  Â  function rotate(points,q){const[qx,qy,qz,qw]=q; return points.map(p=>{const vx=p.x,vy=p.y,vz=p.z; const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz; const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy),oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz),oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx); return {x:ox,y:oy,z:oz,elem:p.elem};});}
Â  Â  function translate(points,t){return points.map(p=>({x:p.x+t.x,y:p.y+t.y,z:p.z+t.z,elem:p.elem}));}
Â  Â  function grid(coords,c){const m=new Map(),k=(ix,iy,iz)=>ix+"|"+iy+"|"+iz; for(let i=0;i<coords.length;i++){const x=coords[i].x,y=coords[i].y,z=coords[i].z,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),kk=k(ix,iy,iz); if(!m.has(kk)) m.set(kk,[]); m.get(kk).push(i);} return {c,m};}
Â  Â  function neigh(g,x,y,z){const c=g.c,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),out=[]; for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++)for(let dz=-1;dz<=1;dz++){const kk=(ix+dx)+"|"+(iy+dy)+"|"+(iz+dz); if(g.m.has(kk)) out.push(...g.m.get(kk));} return out;}
Â  Â  function scorePose(A,B,contact,clashFact,wC,wX,soft){const G=grid(A,contact); let contacts=0, clash=0; for(let i=0;i<B.length;i++){const x=B[i].x,y=B[i].y,z=B[i].z, eB=(B[i].elem||'C').toUpperCase(), neighs=neigh(G,x,y,z); for(const j of neighs){const a=A[j],dx=x-a.x,dy=y-a.y,dz=z-a.z, d=Math.hypot(dx,dy,dz), eA=(a.elem||'C').toUpperCase(); const rs=(vdw[eA]||1.7)+(vdw[eB]||1.7), clashCut=clashFact*rs; if(d<=clashCut){const ov=(clashCut-d+1e-6)/clashCut; clash+=wX*ov*(1/(1+soft*ov));} else if(d<=contact){contacts+=1;} } } return {score: wC*contacts - clash, contacts, clash}; }
Â  Â  self.onmessage=(ev)=>{ const {Apts,Bpts,params,start,end}=ev.data; const rng=rand(params.seed+start*1337); const best=[]; const total=end-start; for(let k=0;k<total;k++){ const q=randomQuat(rng), t={x:(rng()*2-1)*params.maxTrans, y:(rng()*2-1)*params.maxTrans, z:(rng()*2-1)*params.maxTrans}; const B=translate(rotate(Bpts,q),t), s=scorePose(Apts,B,params.contactCut,params.clashFactor,params.wContact,params.wClash,params.soft); best.push({score:s.score,contacts:s.contacts,clash:s.clash,q:[...q],t}); if(((k+1)&1023)===0) self.postMessage({type:'progress', done:(k+1), total}); } best.sort((a,b)=>b.score-a.score); self.postMessage({type:'done',poses:best.slice(0,Math.min(200,total))}); };
Â  `;
Â  return new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
}
function angleBetweenQuats(q1,q2){
Â  const dot=q1[0]*q2[0]+q1[1]*q2[1]+q1[2]*q2[2]+q1[3]*q2[3];
Â  const clamped=Math.max(-1,Math.min(1,Math.abs(dot)));
Â  return 2*Math.acos(clamped)*180/Math.PI;
}
function diverseTop(sorted,deg,transA,limit){
Â  const out=[]; const max=Math.max(1,limit||parseInt(E('topN').value)||10);
Â  for(const p of sorted){
Â  Â  let dupe=false;
Â  Â  for(const s of out){
Â  Â  Â  const a=angleBetweenQuats(p.q,s.q);
Â  Â  Â  const t=Math.hypot(p.t.x-s.t.x,p.t.y-s.t.y,p.t.z-s.t.z);
Â  Â  Â  if(a<=deg && t<=transA){dupe=true;break;}
Â  Â  }
Â  Â  if(!dupe){out.push(p); if(out.length>=max) break;}
Â  }
Â  return out;
}

/* Docking driver */
function enumerateCombos(){
Â  const mode=E('pairMode').value; const aSel=selectedChains('A'); const bSel=selectedChains('B');
Â  const Amap=groupByChain(pdbAAllAtoms), Bmap=groupByChain(pdbBAllAtoms);
Â  const Akeys=[...Amap.keys()].filter(k=>aSel.has(k)); const Bkeys=[...Bmap.keys()].filter(k=>bSel.has(k));
Â  const combosOut=[];
Â  if(mode==='AGG'){
Â  Â  const A=filterChains(pdbAAllAtoms,aSel), B=filterChains(pdbBAllAtoms,bSel);
Â  Â  combosOut.push({label:`A{${Akeys.join('')}} vs B{${Bkeys.join('')}}`, Aatoms:A, Batoms:B});
Â  } else if(mode==='A_EACH_B'){
Â  Â  const A=filterChains(pdbAAllAtoms,aSel);
Â  Â  for(const b of Bkeys){ combosOut.push({label:`A{${Akeys.join('')}} vs B{${b}}`, Aatoms:A, Batoms:Bmap.get(b)}); }
Â  } else if(mode==='CROSS'){
Â  Â  for(const a of Akeys){ for(const b of Bkeys){ combosOut.push({label:`A{${a}} vs B{${b}}`, Aatoms:Amap.get(a), Batoms:Bmap.get(b)}); } }
Â  }
Â  return combosOut;
}
function groupByChain(atoms){ const m=new Map(); for(const a of atoms){ const ch=a.chain||'A'; if(!m.has(ch)) m.set(ch,[]); m.get(ch).push(a); } return m; }

async function runAntibodyDocking(){
Â  if(inProgress) return;
Â  cancelled=false; inProgress=true; status('preparing'); setProgress(0);
Â  E('dockBtn').disabled=true; E('cancelBtn').disabled=false; E('dockBtn').textContent='Runningâ€¦';
Â  try{
Â  Â  const textA=await ensureInputText('A'), textB=await ensureInputText('B');
Â  Â  pdbAAllAtoms=parsePDB(textA); pdbBAllAtoms=parsePDB(textB);
Â  Â  if(!pdbAAllAtoms.length || !pdbBAllAtoms.length) throw new Error('Failed to parse one or both PDBs.');
Â  Â  populateChainChips('A',pdbAAllAtoms); populateChainChips('B',pdbBAllAtoms);

Â  Â  const params=collectDockingParams();
Â  Â  const comboDefs=enumerateCombos();
Â  Â  if(!comboDefs.length) throw new Error('No chain combinations produced. Select at least one chain on each protein.');

Â  Â  combos=comboDefs.map(c=>({label:c.label, Aatoms:c.Aatoms, Batoms:c.Batoms, cA:null, cB:null, topPoses:[], currentIndex:0}));
Â  Â  updateComboSelect();

Â  Â  let completed=0; const totalCombos=combos.length;
Â  Â  let sampleDone=0; const totalSamples=(params.samples||10000)*totalCombos;

Â  Â  for(let i=0;i<combos.length;i++){
Â  Â  Â  if(cancelled) break; status(`combo ${i+1}/${totalCombos} samplingâ€¦`);
Â  Â  Â  await dockSingleCombo(i, params, (done,total)=>{Â 
Â  Â  Â  Â  const base=completed*(params.samples||10000);
Â  Â  Â  Â  sampleDone = base + Math.min(done,total);
Â  Â  Â  Â  setProgress(sampleDone/Math.max(1,totalSamples));
Â  Â  Â  });
Â  Â  Â  completed++; fillComboSummaryRow(i);
Â  Â  }

Â  Â  setCurrentCombo(0);
Â  Â  finishDocking(); status(cancelled?'cancelled':'complete'); setProgress(1); inProgress=false;
Â  }catch(e){
Â  Â  alert(e.message||'Docking error'); finishDocking(); status('error'); inProgress=false;
Â  }
}
function cancelDocking(){ cancelled=true; workerPool.forEach(w=>{try{w.terminate();}catch(e){}}); workerPool=[]; setProgress(0); status('cancelled'); finishDocking(); inProgress=false; }
function finishDocking(){ E('dockBtn').disabled=false; E('cancelBtn').disabled=true; E('dockBtn').textContent='â–¶ï¸ Run Docking'; }
function collectDockingParams(){
Â  return {samples:parseInt(E('samples').value),maxTrans:parseFloat(E('maxTrans').value),
Â  Â  Â  Â  Â  contactCut:parseFloat(E('contactCut').value),clashFactor:parseFloat(E('clashFactor').value),
Â  Â  Â  Â  Â  wContact:parseFloat(E('wContact').value),wClash:parseFloat(E('wClash').value),
Â  Â  Â  Â  Â  soft:parseFloat(E('soft').value), topN:Math.max(1,parseInt(E('topN').value)),
Â  Â  Â  Â  Â  seed:parseInt(E('seed').value)||42, atomMode:E('atomMode').value, rescoreMode:E('rescoreMode').value};
}
async function ensureInputText(which){
Â  const file=E(which==='A'?'pdbAFile':'pdbBFile').files[0]; let t=E(which==='A'?'pdbAText':'pdbBText').value.trim();
Â  if(!t && file){ t=await fileToText(file); }
Â  if(!t) throw new Error(`Provide PDB for Protein ${which} (file or text).`);
Â  return t;
}
async function dockSingleCombo(idx, params, onProgress){
Â  const combo=combos[idx];
Â  const aSel=combo.Aatoms, bSel=combo.Batoms;

Â  const selA=selectAtomSet(aSel,params.atomMode);
Â  const selB=selectAtomSet(bSel,params.atomMode);
Â  if(!selA.length||!selB.length) throw new Error('Atom selection empty. Try Backbone or Heavy mode.');

Â  const cA=centroid(selA), cB=centroid(selB);
Â  const ptsA=translate(selA.map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem})), {x:-cA.x,y:-cA.y,z:-cA.z});
Â  const ptsB=translate(selB.map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem})), {x:-cB.x,y:-cB.y,z:-cB.z});
Â  combo.cA=cA; combo.cB=cB;

Â  const cores=Math.max(1,(navigator.hardwareConcurrency||4)-1), pool=Math.min(cores,8);
Â  const total=params.samples; const base=Math.floor(total/pool), extra=total%pool;
Â  let all=[], donePerWorker=Array(pool).fill(0); workerPool=[];

Â  await new Promise((resolve)=>{
Â  Â  let finished=0;
Â  Â  for(let i=0;i<pool;i++){
Â  Â  Â  const start=i*base+Math.min(i,extra), end=start+base+(i<extra?1:0);
Â  Â  Â  const w=makeDockWorker(); workerPool.push(w);
Â  Â  Â  w.onmessage=(m)=>{
Â  Â  Â  Â  if(cancelled) return;
Â  Â  Â  Â  const msg=m.data;
Â  Â  Â  Â  if(msg.type==='progress'){
Â  Â  Â  Â  Â  donePerWorker[i]=Math.min(msg.done, msg.total);
Â  Â  Â  Â  Â  onProgress?.(donePerWorker.reduce((a,b)=>a+b,0), total);
Â  Â  Â  Â  }
Â  Â  Â  Â  if(msg.type==='done'){
Â  Â  Â  Â  Â  all.push(msg.poses); w.terminate(); finished++;
Â  Â  Â  Â  Â  if(finished===pool) resolve();
Â  Â  Â  Â  }
Â  Â  Â  };
Â  Â  Â  w.onerror=(e)=>{ console.error('worker error',e); w.terminate(); finished++; if(finished===pool) resolve(); };
Â  Â  Â  w.postMessage({Apts:ptsA,Bpts:ptsB,params,start,end});
Â  Â  }
Â  });
Â  workerPool=[];

Â  const poses=all.flat().sort((a,b)=>b.score-a.score);
Â  const diverse=diverseTop(poses, parseFloat(E('dupAngle').value)||12, parseFloat(E('dupTrans').value)||2, params.topN*3);

Â  const Aheavy=translate(selectAtomSet(aSel,'HEAVY').map(a=>({...a})), {x:-cA.x,y:-cA.y,z:-cA.z});
Â  const Bheavy0=translate(selectAtomSet(bSel,'HEAVY').map(a=>({...a})), {x:-cB.x,y:-cB.y,z:-cB.z});

Â  let top=diverse;
Â  if(params.rescoreMode!=='NONE'){ top=await heavyAtomRescore(Aheavy,Bheavy0,params,diverse, params.rescoreMode==='HEAVY_REFINE'); }
Â  combo.topPoses=top; combo.Aviz=Aheavy; combo.B0=Bheavy0;
}
function heavyAtomRescore(A,B0,params,coarse,refine=false){
Â  const {contactCut,clashFactor,wContact,wClash,soft}=params;
Â  function score(A,B){ let contacts=0, clash=0;
Â  Â  for(const b of B){ for(const a of A){
Â  Â  Â  const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z);
Â  Â  Â  const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7);
Â  Â  Â  const cut=clashFactor*rs;
Â  Â  Â  if(d<=cut){ const ov=(cut-d+1e-6)/cut; clash+=wClash*ov*(1/(1+soft*ov)); }
Â  Â  Â  else if(d<=contactCut){ contacts++; }
Â  Â  }}
Â  Â  return {score:wContact*contacts-clash,contacts,clash};
Â  }
Â  function apply(B,q,t){
Â  Â  const [qx,qy,qz,qw]=q;
Â  Â  return B.map(p=>{
Â  Â  Â  const vx=p.x,vy=p.y,vz=p.z;
Â  Â  Â  const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz;
Â  Â  Â  const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy);
Â  Â  Â  const oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz);
Â  Â  Â  const oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx);
Â  Â  Â  return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name};
Â  Â  });
Â  }
Â  function jiggle(p){ const r=()=> (Math.random()*2-1)*0.5;
Â  Â  const dq=[p.q[0]+r()*0.01,p.q[1]+r()*0.01,p.q[2]+r()*0.01,p.q[3]+r()*0.01];
Â  Â  const n=Math.hypot(...dq)||1; for(let i=0;i<4;i++) dq[i]/=n;
Â  Â  const dt={x:p.t.x+r(),y:p.t.y+r(),z:p.t.z+r()};
Â  Â  return {q:dq,t:dt};
Â  }
Â  const rescored=[];
Â  for(const p of coarse){
Â  Â  let best={...p};
Â  Â  let TB=apply(B0,p.q,p.t); let s=score(A,TB);
Â  Â  best.score=s.score; best.contacts=s.contacts; best.clash=s.clash;
Â  Â  if(refine){
Â  Â  Â  for(let it=0;it<40;it++){
Â  Â  Â  Â  const pp=jiggle(best);
Â  Â  Â  Â  const TB2=apply(B0,pp.q,pp.t);
Â  Â  Â  Â  const s2=score(A,TB2);
Â  Â  Â  Â  if(s2.score>best.score){ best.q=pp.q; best.t=pp.t; best.score=s2.score; best.contacts=s2.contacts; best.clash=s2.clash; }
Â  Â  Â  }
Â  Â  }
Â  Â  rescored.push(best);
Â  }
Â  rescored.sort((a,b)=>b.score-a.score);
Â  return rescored.slice(0,parseInt(E('topN').value));
}
function applyTransform(points,q,t){
Â  const [qx,qy,qz,qw]=q;
Â  return points.map(p=>{
Â  Â  const vx=p.x,vy=p.y,vz=p.z;
Â  Â  const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz;
Â  Â  const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy);
Â  Â  const oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz);
Â  Â  const oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx);
Â  Â  return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name};
Â  });
}
/* Visualization / overlays */
function updateComboSelect(){
Â  const sel=E('comboSelect'); sel.innerHTML='';
Â  combos.forEach((c,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=`${i+1}. ${c.label}`; sel.appendChild(o); });
Â  E('comboSummaryBody').innerHTML='';
}
function setCurrentCombo(i){
Â  if(i<0||i>=combos.length) return; currentComboIndex=i; E('comboSelect').value=String(i);
Â  buildPoseButtons(combos[i].topPoses);
Â  if(combos[i].topPoses.length) showPose(0);
Â  updateMetricsDisplay();
}
function buildPoseButtons(poses){
Â  const c=E('poseControls'); c.innerHTML='';
Â  poses.forEach((p,i)=>{
Â  Â  const b=document.createElement('button'); b.className='btn';
Â  Â  b.textContent=`Pose ${i+1} (S=${p.score.toFixed(1)}, C=${p.contacts|0}, X=${p.clash.toFixed(1)})`;
Â  Â  b.addEventListener('click',()=>showPose(i)); c.appendChild(b);
Â  Â  const d=document.createElement('button'); d.className='btn green'; d.style.marginLeft='6px'; d.textContent='â¬‡ PDB';
Â  Â  d.addEventListener('click',()=>downloadSinglePose(i)); c.appendChild(d);
Â  });
Â  updateComparisonDropdowns(poses);
}
function showPose(i){
Â  const combo=combos[currentComboIndex]; if(!combo) return;
Â  if(i<0||i>=combo.topPoses.length) return; combo.currentIndex=i;
Â  const p=combo.topPoses[i];
Â  const TB=applyTransform(combo.B0,p.q,p.t);
Â  viewer.clear();
Â  viewer.addModel(formatPDB(combo.Aviz),'pdb');
Â  viewer.addModel(formatPDB(TB,1),'pdb');

Â  const rA = new Set(combo.Aviz.map(a=>a.resi)).size;
Â  const rB = new Set(TB.map(a=>a.resi)).size;
Â  const wantRibbon = E('toggleRibbon')?.checked;

Â  const hasBackboneA = combo.Aviz.some(a=>a.name==='N') && combo.Aviz.some(a=>a.name==='CA') && combo.Aviz.some(a=>a.name==='C');
Â  const hasBackboneB = TB.some(a=>a.name==='N') && TB.some(a=>a.name==='CA') && TB.some(a=>a.name==='C');
Â  const canCartoonÂ  Â = hasBackboneA && hasBackboneB && (rA>=8 && rB>=8);

Â  viewer.setStyle({}, {});
Â  if (wantRibbon && canCartoon) {
Â  Â  viewer.setStyle({model:0},{cartoon:{color:'#60a5fa',arrows:true,thickness:0.5}});
Â  Â  viewer.setStyle({model:1},{cartoon:{color:'#f97316',arrows:true,thickness:0.5}});
Â  } else if (wantRibbon) {
Â  Â  viewer.setStyle({model:0},{line:{linewidth:1.5}});
Â  Â  viewer.setStyle({model:1},{line:{linewidth:1.5,color:'#f97316'}});
Â  } else {
Â  Â  viewer.setStyle({model:0},{stick:{radius:.25}});
Â  Â  viewer.setStyle({model:1},{stick:{radius:.25,color:'#f97316'}});
Â  }

Â  viewer.zoomTo();
Â  const cutoff=parseFloat(E('contactCut').value);
Â  const metrics=computeInterfaceMetrics(combo.Aviz,TB,cutoff);
Â  currentContacts=metrics.contactsPairs.slice(0,800);
Â  currentHB=metrics.hbPairs.slice(0,400);
Â  currentSB=metrics.sbPairs.slice(0,400);
Â  currentHydro=metrics.hydroPairs.slice(0,400);
Â  refreshOverlays();

Â  const kElec=parseFloat(E('kElec').value)||0.5, eCut=parseFloat(E('elecCut').value)||12;
Â  const elec=coulombEnergy(combo.Aviz,TB,kElec,eCut);
Â  const BSA=metrics.contacts*10.0;
Â  const dH=calculateEnthalpy(metrics,elec);
Â  E('scoreBox').innerHTML=`<b>${combo.label}</b> â€¢ <b>Pose ${i+1}</b><br>
Â  Â  Score: ${p.score.toFixed(2)} | Contacts: ${metrics.contacts} | Clash: ${metrics.clash.toFixed(2)} |
Â  Â  H-bonds: ${metrics.hb} | SaltBr: ${metrics.sb} | Hydrophobics: ${metrics.hydrophobics}<br>
Â  Â  BSA â‰ˆ ${BSA.toFixed(0)} Ã…Â² | Electrostatics: ${elec.toFixed(2)} kcal/mol |
Â  Â  <b>Î”H â‰ˆ ${dH.toFixed(2)} kcal/mol</b>`;
Â  updateMetricsDisplay(); updateEnergyDecomposition(metrics,elec,dH);
Â  viewer.render();
}
function refreshOverlays(){
Â  if(!combos.length || !viewer) return;
Â  viewer.removeAllShapes();
Â  if(E('toggleContacts').checked) drawLines(currentContacts,'#60a5fa');
Â  if(E('toggleHB').checked)Â  Â  Â  Â drawLines(currentHB,'#34d399');
Â  if(E('toggleSB').checked)Â  Â  Â  Â drawLines(currentSB,'#f87171');
Â  if(E('toggleHydro').checked)Â  Â  drawLines(currentHydro,'#fbbf24');
Â  viewer.render();
}
function drawLines(pairs,color){
Â  for(const p of pairs){ viewer.addLine({start:{x:p.x1,y:p.y1,z:p.z1},end:{x:p.x2,y:p.y2,z:p.z2},dashed:true,dashLength:.5,color,linewidth:2}); }
}
function computeInterfaceMetrics(A,B,cut){
Â  let contacts=0,clash=0,hb=0,sb=0,hydro=0;
Â  const contactsPairs=[],hbPairs=[],sbPairs=[],hydroPairs=[];
Â  const clashFactor=parseFloat(E('clashFactor').value)||0.85;
Â  for(const b of B) for(const a of A){
Â  Â  const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z);
Â  Â  const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7);
Â  Â  const cutCl=clashFactor*rs;
Â  Â  if(d<=cutCl){ const ov=(cutCl-d+1e-6)/cutCl; clash+=6.0*ov*(1/(1+0.5*ov)); }
Â  Â  if(d<=cut){ contacts++; contactsPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
Â  Â  const aN=a.name?.startsWith('N'), aO=a.name?.startsWith('O'), bN=b.name?.startsWith('N'), bO=b.name?.startsWith('O');
Â  Â  if(((aN&&bO)||(aO&&bN)) && d<=3.5){ hb++; hbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
Â  Â  const isAcidic=at=> (at.resn==='ASP'&&at.name.startsWith('OD'))||(at.resn==='GLU'&&at.name.startsWith('OE'));
Â  Â  const isBasic =at=> (at.resn==='LYS'&&at.name==='NZ')||(at.resn==='ARG'&&(at.name==='NH1'||'NH2'||at.name==='NE'))||(at.resn==='HIS'&&(at.name==='ND1'||at.name==='NE2'));
Â  Â  if(((isAcidic(a)&&isBasic(b))||(isAcidic(b)&&isBasic(a))) && d<=4.0){ sb++; sbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
Â  Â  if(hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)&&(a.elem==='C'||b.elem==='C')&&d<=4.5){ hydro++; hydroPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
Â  }
Â  return {contacts,clash,hb,sb,hydrophobics:hydro,contactsPairs,hbPairs,sbPairs,hydroPairs};
}
function coulombEnergy(A,B,k=0.5,cut=12){
Â  const AA=residueChargesFor(A), BB=residueChargesFor(B); let E=0, cut2=cut*cut;
Â  for(const a of AA) for(const b of BB){
Â  Â  const dx=a.x-b.x,dy=a.y-b.y,dz=a.z-b.z, d2=dx*dx+dy*dy+dz*dz; if(d2>cut2) continue;
Â  Â  E+=k*(a.q*b.q)/(Math.sqrt(d2)+1e-3);
Â  }
Â  return E;
}
function residueChargesFor(atoms){
Â  const groups=new Map();
Â  for(const a of atoms){ const key=(a.chain||'A')+':'+(a.resi||0); if(!groups.has(key)) groups.set(key,[]); groups.get(key).push(a); }
Â  const out=[];
Â  for(const [key,arr] of groups.entries()){
Â  Â  const res=arr[0].resn||'UNK', q=residueCharges[res]||0; if(!q) continue;
Â  Â  const ca=arr.find(x=>x.name==='CA'); let x,y,z;
Â  Â  if(ca){x=ca.x;y=ca.y;z=ca.z;}
Â  Â  else{ let sx=0,sy=0,sz=0; for(const a of arr){sx+=a.x; sy+=a.y; sz+=a.z;} x=sx/arr.length; y=sy/arr.length; z=sz/arr.length; }
Â  Â  out.push({x,y,z,q,resn:res});
Â  }
Â  return out;
}
function calculateEnthalpy(m,elec){
Â  const w={contact:-0.5,hbond:-2.5,salt:-4.0,hydro:-1.0,clash:+0.3,desolv:+0.2};
Â  return w.contact*m.contacts + w.hbond*m.hb + w.salt*m.sb + w.hydro*m.hydrophobics + w.clash*m.clash + elec + w.desolv*m.contacts;
}

/* Clustering & Summary */
function clusterCurrentPoses(){
Â  const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length) return;
Â  const K=Math.max(1,parseInt(E('clustersK').value)||6); const poses=combo.topPoses;
Â  const centers=poses.slice(0,Math.min(K,poses.length)); const assign=new Array(poses.length).fill(0);
Â  function d(p,q){ const a=angleBetweenQuats(p.q,q.q), t=Math.hypot(p.t.x-q.t.x,p.t.y-q.t.y,p.t.z-q.t.z); return a+5*t; }
Â  for(let iter=0;iter<6;iter++){
Â  Â  for(let i=0;i<poses.length;i++){ let best=0,bestd=Infinity; for(let c=0;c<centers.length;c++){ const dd=d(poses[i],centers[c]); if(dd<bestd){bestd=dd;best=c;} } assign[i]=best; }
Â  Â  for(let c=0;c<centers.length;c++){ const members=poses.filter((_,i)=>assign[i]===c); if(members.length){ members.sort((a,b)=>b.score-a.score); centers[c]=members[0]; } }
Â  }
Â  const ordered=poses.map((p,i)=>({p,i,cl:assign[i]})).sort((a,b)=> a.cl-b.cl || b.p.score-a.p.score).map(x=>x.p);
Â  combo.topPoses=ordered; buildPoseButtons(combo.topPoses); showPose(0);
}
function fillComboSummaryRow(i){
Â  const combo=combos[i]; const top=combo.topPoses[0]; if(!top) return;
Â  const TB=applyTransform(combo.B0,top.q,top.t);
Â  const metrics=computeInterfaceMetrics(combo.Aviz,TB,parseFloat(E('contactCut').value));
Â  const elec=coulombEnergy(combo.Aviz,TB,parseFloat(E('kElec').value)||0.5,parseFloat(E('elecCut').value)||12);
Â  const dH=calculateEnthalpy(metrics,elec);
Â  const tr=document.createElement('tr');
Â  tr.innerHTML=`<td>${combo.label}</td><td>${top.score.toFixed(2)}</td><td>${metrics.contacts}</td><td>${dH.toFixed(2)}</td>`;
Â  E('comboSummaryBody').appendChild(tr);
}

/* Metrics / Analysis UI */
function updateMetricsDisplay(){
Â  const combo=combos[currentComboIndex];
Â  if(!combo||!combo.topPoses.length){
Â  Â  E('metricsDisplay').innerHTML='<div class="small" style="color:#9ca3af">Run docking to see metrics.</div>'; return;
Â  }
Â  const p=combo.topPoses[combo.currentIndex];
Â  E('metricsDisplay').innerHTML=
Â  Â  `<div class="metric-card"><div class="metric-value">${p.score.toFixed(2)}</div><div class="metric-label">Score</div></div>
Â  Â  Â <div class="metric-card"><div class="metric-value">${currentContacts.length}</div><div class="metric-label">Contacts</div></div>
Â  Â  Â <div class="metric-card"><div class="metric-value">${currentHB.length}</div><div class="metric-label">H-bonds</div></div>
Â  Â  Â <div class="metric-card"><div class="metric-value">${currentSB.length}</div><div class="metric-label">Salt Bridges</div></div>`;
}
function updateEnergyDecomposition(m,elec,dH){
Â  const box=E('energyComponents');
Â  const parts=[["Contacts","+"+(m.contacts),-0.5*m.contacts],["H-bonds","+"+(m.hb),-2.5*m.hb],["SaltBr","+"+(m.sb),-4.0*m.sb],["Hydrophobic","+"+(m.hydrophobics),-1.0*m.hydrophobics],["Clash","+"+m.clash.toFixed(2),(+0.3*m.clash)],["Electrostatics","",elec],["Desolv","+"+m.contacts,+0.2*m.contacts]];
Â  box.innerHTML=parts.map(([k,c,v])=>`<div class="metric-card"><div class="metric-value">${v.toFixed(2)}</div><div class="metric-label">${k} ${c}</div></div>`).join('');
Â  E('enthalpyDetail').textContent = `Î”H â‰ˆ ${dH.toFixed(2)} kcal/mol (contacts, H-bonds, salt bridges, hydrophobic, clash, electrostatics, desolvation).`;
}
function updateComparisonDropdowns(poses){
Â  const s1=E('comparePose1'), s2=E('comparePose2');
Â  s1.innerHTML=''; s2.innerHTML='';
Â  poses.forEach((p,i)=>{ const o1=document.createElement('option'); o1.value=i; o1.textContent=`Pose ${i+1}`; s1.appendChild(o1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const o2=document.createElement('option'); o2.value=i; o2.textContent=`Pose ${i+1}`; s2.appendChild(o2); });
Â  if(poses.length>=2){ s1.value=0; s2.value=1; }
}
function comparePoses(){
Â  const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length) return;
Â  const i1=parseInt(E('comparePose1').value), i2=parseInt(E('comparePose2').value);
Â  if(!(combo.topPoses[i1]&&combo.topPoses[i2])) return;
Â  const TB1=applyTransform(combo.B0,combo.topPoses[i1].q,combo.topPoses[i1].t);
Â  viewerComp.clear(); viewerComp.addModel(formatPDB(combo.Aviz),'pdb'); viewerComp.addModel(formatPDB(TB1,1),'pdb');
Â  viewerComp.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewerComp.setStyle({model:1},{cartoon:{color:'#f97316'}});
Â  viewerComp.zoomTo(); viewerComp.render();
Â  const a=angleBetweenQuats(combo.topPoses[i1].q, combo.topPoses[i2].q);
Â  const t=Math.hypot(combo.topPoses[i1].t.x-combo.topPoses[i2].t.x,combo.topPoses[i1].t.y-combo.topPoses[i2].t.y,combo.topPoses[i1].t.z-combo.topPoses[i2].t.z);
Â  E('comparisonResults').textContent = `Pose1 score=${combo.topPoses[i1].score.toFixed(2)}, Pose2 score=${combo.topPoses[i2].score.toFixed(2)}\nÎ”angle â‰ˆ ${a.toFixed(1)}Â°, Î”translation â‰ˆ ${t.toFixed(2)} Ã…`;
}
function filterResidueContacts(){
Â  const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length) return;
Â  const min=parseFloat(E('filterMinDist').value)||0, max=parseFloat(E('filterMaxDist').value)||6;
Â  const p=combo.topPoses[combo.currentIndex]; const TB=applyTransform(combo.B0,p.q,p.t);
Â  const rows=[];
Â  for(const b of TB) for(const a of combo.Aviz){
Â  Â  const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z); if(d<min||d>max) continue;
Â  Â  const type=(a.name?.startsWith('N')&&b.name?.startsWith('O')||a.name?.startsWith('O')&&b.name?.startsWith('N'))&&d<=3.5?'H-bond': (hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)?'Hydrophobic': (d<=4?'Contact':'Proximal'));
Â  Â  const e=type==='H-bond'?-2.5:type==='Hydrophobic'?-1.0:type==='Contact'?-0.5:0;
Â  Â  rows.push(`<tr><td>${a.resn}${a.resi}</td><td>${a.chain}</td><td>${b.resn||'-'}${b.resi||'-'}</td><td>${b.chain||'-'}</td><td>${d.toFixed(2)}</td><td>${type}</td><td>${e.toFixed(2)}</td></tr>`);
Â  }
Â  E('residueTableBody').innerHTML=rows.slice(0,1000).join('');
}
function exportResidueData(){
Â  const table=E('residueTableBody').innerText||''; if(!table){alert('No data');return;} downloadBlob(table,'residue_contacts.txt');
}

/* Exports */
function downloadAllPoses(){
Â  const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length){alert('No poses.');return;}
Â  const lines=[]; combo.topPoses.forEach((p,i)=>{lines.push(`MODELÂ  Â  Â ${i+1}Â  ${combo.label}`); lines.push(formatPDB(combo.Aviz)); lines.push(formatPDB(applyTransform(combo.B0,p.q,p.t),1)); lines.push('ENDMDL');});
Â  lines.push('END'); downloadBlob(lines.join('\n'),'all_poses_'+safe(combo.label)+'.pdb');
}
function safe(s){return s.replace(/[^a-z0-9]+/gi,'_');}
function downloadSinglePose(i){
Â  const combo=combos[currentComboIndex]; if(!combo) return;
Â  const p=combo.topPoses[i]; const TB=applyTransform(combo.B0,p.q,p.t);
Â  const pdb=formatPDB(combo.Aviz)+'\n'+formatPDB(TB,1); downloadBlob(pdb,`pose_${i+1}_`+safe(combo.label)+`.pdb`);
}
function downloadCurrentPose(){ const combo=combos[currentComboIndex]; if(!combo){alert('No complex selected.');return;} downloadSinglePose(combo.currentIndex||0); }
function downloadCSV(){
Â  if(!combos.length){alert('No data');return;}
Â  const rows=['complex,rank,score,contacts,clash,qx,qy,qz,qw,tx,ty,tz'];
Â  combos.forEach((combo)=>{ combo.topPoses.forEach((p,i)=>rows.push([`"${combo.label}"`,i+1,p.score.toFixed(4),p.contacts,p.clash.toFixed(4),p.q[0].toFixed(6),p.q[1].toFixed(6),p.q[2].toFixed(6),p.q[3].toFixed(6),p.t.x.toFixed(3),p.t.y.toFixed(3),p.t.z.toFixed(3)].join(','))); });
Â  downloadBlob(rows.join('\n'),'poses_summary_all_complexes.csv');
}
function downloadJSON(){
Â  if(!combos.length){alert('No data');return;}
Â  const out={params:collectDockingParams(), complexes:combos.map(c=>({label:c.label, topPoses:c.topPoses}))};
Â  downloadBlob(JSON.stringify(out,null,2),'poses_all_complexes.json');
}
function downloadAllComplexesPDB(){
Â  if(!combos.length){alert('No complexes');return;}
Â  const lines=[]; let model=1;
Â  combos.forEach((combo)=>{ combo.topPoses.forEach((p,i)=>{ lines.push(`MODELÂ  Â  Â ${model++}Â  ${combo.label}Â  pose ${i+1}`); lines.push(formatPDB(combo.Aviz)); lines.push(formatPDB(applyTransform(combo.B0,p.q,p.t),1)); lines.push('ENDMDL'); }); });
Â  lines.push('END'); downloadBlob(lines.join('\n'),'all_complexes_all_poses.pdb');
}

/* Ligand docking (X5) */
function loadLigandDemoReceptor(){
Â  E('ligReceptorPDB').value=`ATOMÂ  Â  Â  1Â  CAÂ  ALA AÂ  Â 1Â  Â  Â  -8.000Â  Â 0.000Â  Â 0.000Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
ATOMÂ  Â  Â  2Â  CAÂ  ALA AÂ  Â 2Â  Â  Â  -6.600Â  Â 1.200Â  Â 0.200Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
ATOMÂ  Â  Â  3Â  CAÂ  ALA AÂ  Â 3Â  Â  Â  -5.200Â  Â 0.100Â  Â 1.200Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
ATOMÂ  Â  Â  4Â  CAÂ  ALA AÂ  Â 4Â  Â  Â  -3.800Â  Â 1.400Â  Â 1.400Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
ATOMÂ  Â  Â  5Â  CAÂ  ALA AÂ  Â 5Â  Â  Â  -2.400Â  Â 0.500Â  Â 2.200Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
END`;
}
function parseReceptorForLigand(){
Â  const t=E('ligReceptorPDB').value.trim(); if(!t){alert('Paste receptor PDB first'); return;}
Â  const atoms=parsePDB(t); viewerLig.clear(); viewerLig.addModel(formatPDB(atoms),'pdb');
Â  viewerLig.setStyle({},{cartoon:{color:'#60a5fa'}}); viewerLig.zoomTo(); viewerLig.render();
}
function embedSmilesTo3D(smiles, method='HASH', seed=1337){
Â  const rng = (()=>{let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
Â  const atoms = smiles.replace(/[^A-Za-z]/g, '').split('').map(e => ({elem: e.toUpperCase(), x: 0, y: 0, z: 0}));
  if (atoms.length === 0) return [];
Â  if (method === 'HASH') {
Â  Â  for (let i = 0; i < atoms.length; i++) { atoms[i].x = (rng() - 0.5) * 4; atoms[i].y = (rng() - 0.5) * 4; atoms[i].z = (rng() - 0.5) * 4; }
Â  } else {
Â  Â  const R = 2.0, pitch = 1.5;
Â  Â  for (let i = 0; i < atoms.length; i++) {
Â  Â  Â  const angle = 2 * Math.PI * i / Math.min(atoms.length, 8);
Â  Â  Â  atoms[i].x = R * Math.cos(angle); atoms[i].y = R * Math.sin(angle); atoms[i].z = i * pitch / Math.min(atoms.length, 8);
Â  Â  }
Â  }
Â  return atoms;
}
async function runSingleLigandDock() {
Â  const ligStatus = E('ligStatus'); ligStatus.textContent = 'running...';
Â  try {
Â  Â  const receptorPDB = E('ligReceptorPDB').value.trim();
Â  Â  const smiles = E('ligSmiles').value.trim();
Â  Â  if (!receptorPDB || !smiles) throw new Error('Receptor PDB and Ligand SMILES are required.');
Â  Â  const receptorAtoms = parsePDB(receptorPDB);
Â  Â  if (!receptorAtoms.length) throw new Error('Receptor PDB failed to parse.');
Â  Â  const ligandAtomsÂ  Â = embedSmilesTo3D(smiles, E('ligEmbedMethod').value, parseInt(E('ligSeed').value));
    if (!ligandAtoms.length) throw new Error('Ligand SMILES failed to embed.');

Â  Â  const cR = centroid(receptorAtoms);
Â  Â  const receptorCentered = translate(receptorAtoms, {x: -cR.x, y: -cR.y, z: -cR.z});
Â  Â  const cL = centroid(ligandAtoms);
Â  Â  const ligandCentered = translate(ligandAtoms, {x: -cL.x, y: -cL.y, z: -cL.z});

Â  Â  let bestPose = { score: -Infinity };
Â  Â  const rng = (()=>{let s=42; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
Â  Â  for (let i = 0; i < 5000; i++) {
Â  Â  Â  const q = [rng()*2-1, rng()*2-1, rng()*2-1, rng()*2-1]; const n = Math.hypot(...q)||1; for(let j=0;j<4;j++) q[j]/=n;
Â  Â  Â  const t = { x: (rng() - 0.5) * 5, y: (rng() - 0.5) * 5, z: (rng() - 0.5) * 5 };
Â  Â  Â  const posedLigand = applyTransform(ligandCentered, q, t);
Â  Â  Â  const {score, contacts, clash} = scoreLigand(receptorCentered, posedLigand);
Â  Â  Â  if (score > bestPose.score) bestPose = { score, contacts, clash, q, t, ligand: posedLigand, receptor: receptorCentered, smiles, receptorPDB };
Â  Â  }
Â  Â  ligLastResult = bestPose;
Â  Â  viewerLig.clear(); viewerLig.addModel(formatPDB(bestPose.receptor), 'pdb'); viewerLig.addModel(formatPDB(bestPose.ligand, 1), 'pdb');
Â  Â  viewerLig.setStyle({model: 0}, {stick: {radius: 0.2, color: '#60a5fa'}}); viewerLig.setStyle({model: 1}, {stick: {radius: 0.3, color: '#f97316'}});
Â  Â  viewerLig.zoomTo(); viewerLig.render();
Â  Â  E('ligScore').textContent = `Best Score: ${bestPose.score.toFixed(2)}, Contacts: ${bestPose.contacts}, Clash: ${bestPose.clash.toFixed(2)}`;
Â  Â  ligStatus.textContent = 'complete';
Â  } catch (e) {
Â  Â  alert('Ligand Docking Failed: ' + e.message); ligStatus.textContent = 'error';
Â  }
}
function scoreLigand(receptor, ligand){
Â  let contacts = 0, clash = 0;
Â  const contactCut = parseFloat(E('contactCut').value) || 4.8;
Â  const clashFactor = parseFloat(E('clashFactor').value) || 0.85;
Â  for (const l of ligand) for (const r of receptor){
Â  Â  const d = Math.hypot(l.x - r.x, l.y - r.y, l.z - r.z);
Â  Â  const rs = (vdw[(l.elem||'C').toUpperCase()] || 1.7) + (vdw[(r.elem||'C').toUpperCase()] || 1.7);
Â  Â  if (d < rs * clashFactor) clash += (rs * clashFactor - d);
Â  Â  else if (d < contactCut) contacts++;
Â  }
Â  return { score: contacts - 6.0 * clash, contacts, clash };
}
function downloadLigandPDB(){ if (!('score' in ligLastResult)) return; const pdb = formatPDB(ligLastResult.receptor) + "\n" + formatPDB(ligLastResult.ligand, 1); downloadBlob(pdb, 'ligand_complex.pdb'); }
function downloadLigandCSV(){ if (!('score' in ligLastResult)) return; const row = `smiles,score,contacts,clash\n"${ligLastResult.smiles}",${ligLastResult.score.toFixed(3)},${ligLastResult.contacts},${ligLastResult.clash.toFixed(3)}`; downloadBlob(row, 'ligand_result.csv'); }

/* Batch Screening (X5) */
async function startBatchScreening(){
Â  E('btnStartScreen').disabled = true; E('btnStopScreen').disabled = false; E('scrStatus').textContent = 'running...'; screenCancel = false;
Â  try {
Â  Â  const smilesList = E('scrSmiles').value.trim().split(/\r?\n/).map(s=>s.trim()).filter(s => s);
Â  Â  const raw = E('scrReceptors').value;
Â  Â  const receptorPDBs = String(raw||'').split(/\r?\n\s*END\s*(?:\r?\n|$)/).map(s=>s.trim()).filter(Boolean);

Â  Â  if (smilesList.length > 50 || receptorPDBs.length > 3) throw new Error('Exceeded limits: max 50 SMILES, max 3 receptors.');
Â  Â  if (receptorPDBs.length===0) throw new Error('Please paste at least one receptor PDB and separate with END if multiple.');

Â  Â  screenReceptors = receptorPDBs.map((pdb, i) => ({ id: `R${i+1}`, atoms: parsePDB(pdb)}));
Â  Â  if (screenReceptors.some(r => r.atoms.length === 0)) throw new Error('One or more receptors failed to parse.');

Â  Â  screenResults = [];
Â  Â  E('scrTableBody').innerHTML = ''; let count = 0;
Â  Â  const totalJobs = smilesList.length * screenReceptors.length;

Â  Â  for (const receptor of screenReceptors) {
Â  Â  Â  for (const smiles of smilesList) {
Â  Â  Â  Â  if (screenCancel) break;
Â  Â  Â  Â  E('scrProgress').textContent = `Processing ${++count} of ${totalJobs}...`;
Â  Â  Â  Â  await new Promise(resolve => setTimeout(() => {
Â  Â  Â  Â  Â  const result = dockSingleLigandToReceptor(smiles, receptor.atoms, receptor.id);
Â  Â  Â  Â  Â  screenResults.push(result); resolve();
Â  Â  Â  Â  }, 0));
Â  Â  Â  }
Â  Â  Â  if (screenCancel) break;
Â  Â  }
Â  Â  sortAndDisplayScreeningResults();
Â  Â  E('scrStatus').textContent = screenCancel ? 'stopped' : 'complete';
Â  } catch (e) {
Â  Â  alert('Screening failed: ' + e.message); E('scrStatus').textContent = 'error';
Â  }
Â  E('btnStartScreen').disabled = false; E('btnStopScreen').disabled = true;
}
function dockSingleLigandToReceptor(smiles, receptorAtoms, receptorId){
Â  const embedMethod = E('scrEmbedMethod').value;
Â  const seed = parseInt(E('scrSeed').value);
Â  const ligandAtoms = embedSmilesTo3D(smiles, embedMethod, seed + smiles.length);
  if (!ligandAtoms.length) return { score: -Infinity, smiles, receptorId, hb: 0, sb: 0, dH: 0, contacts: 0, clash: 0 };

Â  const cR = centroid(receptorAtoms);
Â  const receptorCentered = translate(receptorAtoms.map(a=>({...a})), {x: -cR.x, y: -cR.y, z: -cR.z});
Â  const cL = centroid(ligandAtoms);
Â  const ligandCentered = translate(ligandAtoms, {x: -cL.x, y: -cL.y, z: -cL.z});

Â  let bestPose = { score: -Infinity };
Â  const rng = (()=>{let s=seed; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
Â  const samples = parseInt(E('scrSamples').value);

Â  for (let i = 0; i < samples; i++) {
Â  Â  const q = [rng()*2-1, rng()*2-1, rng()*2-1, rng()*2-1]; const n=Math.hypot(...q)||1; for(let j=0;j<4;j++) q[j]/=n;
Â  Â  const t = { x: (rng() - 0.5) * 8, y: (rng() - 0.5) * 8, z: (rng() - 0.5) * 8 };
Â  Â  const posedLigand = applyTransform(ligandCentered, q, t);
Â  Â  const { score, contacts, clash } = scoreLigand(receptorCentered, posedLigand);
Â  Â  if (score > bestPose.score) bestPose = { score, contacts, clash, q, t };
Â  }
Â  const metrics = computeInterfaceMetrics(receptorCentered, applyTransform(ligandCentered, bestPose.q, bestPose.t), parseFloat(E('scrContactCut').value));
Â  const dH = calculateEnthalpy(metrics, 0);
Â  return { ...bestPose, smiles, receptorId, hb: metrics.hb, sb: metrics.sb, dH, contacts: metrics.contacts, clash: metrics.clash };
}
function sortAndDisplayScreeningResults(){
Â  const sortBy = E('scrSort').value;
  // Filter out failed embeddings before sorting
  screenResults = screenResults.filter(r => isFinite(r.score));

Â  if (sortBy === 'score') screenResults.sort((a,b) => b.score - a.score);
Â  else if (sortBy === 'enthalpy') screenResults.sort((a,b) => a.dH - b.dH);
Â  else {
Â  Â  const scoreRank = [...screenResults].sort((a,b) => b.score - a.score);
Â  Â  const dHRankÂ  Â = [...screenResults].sort((a,b) => a.dH - b.dH);
Â  Â  const contactRank=[...screenResults].sort((a,b)=> b.contacts - a.contacts); // Changed to descending contacts
Â  Â  const rankMap = new Map();
Â  Â  const add=(arr)=>arr.forEach((r,i)=>{ const k=r.receptorId+'||'+r.smiles; rankMap.set(k,(rankMap.get(k)||0)+i);});
Â  Â  add(scoreRank); add(dHRank); add(contactRank);
Â  Â  screenResults.forEach(r=>{ const k=r.receptorId+'||'+r.smiles; r.cRank = rankMap.get(k); });
Â  Â  screenResults.sort((a,b)=>a.cRank-b.cRank);
Â  }
Â  const body = E('scrTableBody'); body.innerHTML = '';
Â  screenResults.forEach((r, i) => {
Â  Â  const tr = document.createElement('tr');
Â  Â  tr.innerHTML = `<td>${i+1}</td><td>${r.receptorId}</td><td class="small">${r.smiles}</td><td>${r.score.toFixed(2)}</td><td>${r.contacts}</td><td>${r.hb}</td><td>${r.sb}</td><td>${r.clash.toFixed(2)}</td><td>${r.dH.toFixed(2)}</td><td>${r.cRank ?? '-'}</td>`;
Â  Â  tr.addEventListener('click', () => visualizeScreeningPose(r));
Â  Â  body.appendChild(tr);
Â  });
}
function visualizeScreeningPose(result){
Â  const receptor = screenReceptors.find(r => r.id === result.receptorId); if (!receptor) return;
  if (!result.q || !result.t) return; // Skip if docking failed (e.g., embedding failure)

Â  const ligand = embedSmilesTo3D(result.smiles);
Â  const cR = centroid(receptor.atoms);
Â  const receptorCentered = translate(receptor.atoms.map(a=>({...a})), {x: -cR.x, y: -cR.y, z: -cR.z});
Â  const cL = centroid(ligand);
Â  const ligandCentered = translate(ligand, {x: -cL.x, y: -cL.y, z: -cL.z});
Â  const posedLigand = applyTransform(ligandCentered, result.q, result.t);

Â  viewerScr.clear(); viewerScr.addModel(formatPDB(receptorCentered), 'pdb'); viewerScr.addModel(formatPDB(posedLigand, 1), 'pdb');
Â  viewerScr.setStyle({model: 0}, {cartoon: {color: '#60a5fa'}}); viewerScr.setStyle({model: 1}, {stick: {radius: 0.3, color: '#f97316'}});
Â  viewerScr.zoomTo(); viewerScr.render();
}
function downloadScreeningCSV(){
Â  const header = 'rank,receptor,smiles,score,contacts,clash,h_bonds,salt_bridges,delta_h,consensus_rank\n';
Â  const rows = screenResults.map((r,i) => [i+1, r.receptorId, `"${r.smiles}"`, r.score.toFixed(3), r.contacts, r.clash.toFixed(3), r.hb, r.sb, r.dH.toFixed(3), r.cRank??''].join(',')).join('\n');
Â  downloadBlob(header+rows, 'screening_results.csv');
}
function downloadScreeningJSON(){ downloadBlob(JSON.stringify(screenResults, null, 2), 'screening_results.json'); }
function showTop10Screening(){
Â  const top10 = screenResults.slice(0, 10);
Â  const dHs = top10.map(r => r.dH);
  if (dHs.length === 0) return;
Â  const min = Math.min(...dHs), max = Math.max(...dHs), avg = dHs.reduce((a,b) => a+b, 0) / Math.max(1,dHs.length);
Â  E('screenMetrics').innerHTML =
Â  Â  `<div class="metric-card"><div class="metric-value">${(isFinite(min)?min:0).toFixed(2)}</div><div class="metric-label">Min Î”H</div></div>
Â  Â  Â <div class="metric-card"><div class="metric-value">${(isFinite(max)?max:0).toFixed(2)}</div><div class="metric-label">Max Î”H</div></div>
Â  Â  Â <div class="metric-card"><div class="metric-value">${(isFinite(avg)?avg:0).toFixed(2)}</div><div class="metric-label">Avg Î”H</div></div>`;
Â  E('enthalpyBreakdown').textContent = 'Top 10 Î”H Values:\n' + dHs.map(d => d.toFixed(2)).join(', ');
}

/* QA & Registry (X5) */
function saveCurrentRun(){
Â  if (!combos.length) { alert('No run data to save.'); return; }
Â  const topPose = combos[0]?.topPoses[0];
Â  const run = { timestamp: new Date().toISOString(), type: 'Antibody Docking',
Â  Â  description: combos.map(c => c.label).join('; '), topScore: topPose ? topPose.score.toFixed(3) : 'N/A',
Â  Â  signature: '...'+(Math.random().toString(36).substring(2, 8)), data: { combos } };
Â  const registry = JSON.parse(localStorage.getItem(REGISTRY_KEY) || '[]');
Â  registry.unshift(run); localStorage.setItem(REGISTRY_KEY, JSON.stringify(registry.slice(0, 50)));
Â  refreshRunRegistry();
}
function refreshRunRegistry(){
Â  const registry = JSON.parse(localStorage.getItem(REGISTRY_KEY) || '[]');
Â  const body = E('registryTableBody'); body.innerHTML = '';
Â  registry.forEach((run, i) => {
Â  Â  const tr = document.createElement('tr');
Â  Â  tr.innerHTML = `<td>${new Date(run.timestamp).toLocaleString()}</td><td>${run.type}</td><td>${run.description}</td><td>${run.topScore}</td><td>${run.signature}</td><td><button class="btn small" onclick="loadRun(${i})">Load</button></td>`;
Â  Â  body.appendChild(tr);
Â  });
}
function loadRun(index){
Â  const registry = JSON.parse(localStorage.getItem(REGISTRY_KEY) || '[]');
Â  const run = registry[index];
Â  if (run && run.data.combos) { combos = run.data.combos; updateComboSelect(); setCurrentCombo(0); alert('Run loaded.'); }
}
function clearRunRegistry(){ if (confirm('Clear entire run registry?')) { localStorage.removeItem(REGISTRY_KEY); refreshRunRegistry(); }}
function exportAllRuns(){ const data = localStorage.getItem(REGISTRY_KEY) || '[]'; downloadBlob(data, 'docking_registry.json'); }
function importRunRegistry(){
Â  E('importRegistryFile').click();
Â  E('importRegistryFile').onchange = async (e) => {
Â  Â  try { const text = await fileToText(e.target.files[0]); const data = JSON.parse(text);
Â  Â  Â  if (Array.isArray(data)) { localStorage.setItem(REGISTRY_KEY, JSON.stringify(data)); refreshRunRegistry(); alert('Registry imported.'); }
Â  Â  Â  else { alert('Invalid format.'); } }
Â  Â  catch(err) { alert('Import failed: ' + err.message); }
Â  };
}
async function runQATest(){
Â  const repeats = parseInt(E('qaRepeats').value); const tolerance = parseFloat(E('qaTolerance').value);
Â  const qaResults = E('qaResults'); qaResults.textContent = 'Running QA test...';
Â  if (!combos.length || !combos[0]) { qaResults.textContent = 'No docking run available to test.'; return; }
Â  const scores = []; const params = collectDockingParams();
Â  for (let i = 0; i < repeats; i++) { await dockSingleCombo(0, params, ()=>{}); const topScore = combos[0]?.topPoses[0]?.score; if (topScore||topScore===0) scores.push(topScore); }
Â  const avg = scores.reduce((a, b) => a + b, 0) / Math.max(1,scores.length);
Â  const maxDiff = (Math.max(...scores) - Math.min(...scores)) || 0;
Â  const pass = maxDiff <= tolerance;
Â  qaResults.textContent = `QA Test Results (${repeats} repeats):\nScores: ${scores.map(s=>s.toFixed(3)).join(', ')}\nAverage Score: ${avg.toFixed(3)}\nMax Difference: ${maxDiff.toFixed(3)}\nTolerance: ${tolerance.toFixed(3)}\nResult: ${pass ? 'âœ… PASSED' : 'âŒ FAILED'}`;
}

/* Session Save/Load */
function saveSession(){
Â  const state = { pdbAText: E('pdbAText').value, pdbBText: E('pdbBText').value, params: collectDockingParams(), dockingResults: combos };
Â  downloadBlob(JSON.stringify(state), 'docking_session.json');
}
function loadSession(){
Â  const input = document.createElement('input'); input.type = 'file'; input.accept = '.json';
Â  input.onchange = async (e) => {
Â  Â  try {
Â  Â  Â  const text = await e.target.files[0].text(); const state = JSON.parse(text);
Â  Â  Â  E('pdbAText').value = state.pdbAText || ''; E('pdbBText').value = state.pdbBText || '';
Â  Â  Â  if (state.params) { Object.keys(state.params).forEach(k => { const el = E(k); if (el && state.params[k]!==undefined) el.value = state.params[k]; }); }
Â  Â  Â  if (state.dockingResults) { combos = state.dockingResults; updateComboSelect(); setCurrentCombo(0); }
Â  Â  Â  alert('Session loaded.');
Â  Â  } catch(err) { alert('Failed to load session: ' + err.message); }
Â  };
Â  input.click();
}
function loadSessionHistory(){ refreshRunRegistry(); }

/* Demo */
function useExample(which){
Â  if(which==='A'){
Â  Â  E('pdbAText').value=`ATOMÂ  Â  Â  1Â  CAÂ  GLY AÂ  Â 1Â  Â  Â  10.000Â  10.000Â  10.000Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
ATOMÂ  Â  Â  2Â  CAÂ  ALA AÂ  Â 2Â  Â  Â  12.000Â  11.000Â  10.500Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C`;
Â  } else {
Â  Â  E('pdbBText').value=`ATOMÂ  Â  Â  1Â  CAÂ  PRO BÂ  Â 1Â  Â  Â  15.000Â  15.000Â  15.000Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
ATOMÂ  Â  Â  2Â  CAÂ  LEU BÂ  Â 2Â  Â  Â  17.000Â  14.000Â  15.500Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C`;
Â  }
}
async function autoDemo(){ useExample('A'); useExample('B'); E('samples').value=2000; await runAntibodyDocking(); }

/* ===== CDR / Fragment module (merged) ===== */
const AntibodyPDB = (function() {
Â  const THREE_LETTER_TO_ONE = { ALA:'A', ARG:'R', ASN:'N', ASP:'D', CYS:'C', GLN:'Q', GLU:'E', GLY:'G', HIS:'H', ILE:'I', LEU:'L', LYS:'K', MET:'M', PHE:'F', PRO:'P', SER:'S', THR:'T', TRP:'W', TYR:'Y', VAL:'V', SEC:'U', PYL:'O' };
Â  function parsePDB(pdbText) {
Â  Â  const lines = pdbText.split(/\r?\n/);
Â  Â  const atomsByChainResidue = new Map();
Â  Â  for (const line of lines) {
Â  Â  Â  if (!line.startsWith('ATOM')) continue;
Â  Â  Â  const atomName = line.slice(12, 16).trim();
Â  Â  Â  const resName = line.slice(17, 20).trim();
Â  Â  Â  const chainId = line.slice(21, 22).trim() || ' ';
Â  Â  Â  const resSeq = parseInt(line.slice(22, 26).trim(), 10);
Â  Â  Â  const iCode = line.slice(26, 27).trim();
Â  Â  Â  const x = parseFloat(line.slice(30, 38).trim());
Â  Â  Â  const y = parseFloat(line.slice(38, 46).trim());
Â  Â  Â  const z = parseFloat(line.slice(46, 54).trim());
Â  Â  Â  const key = `${chainId}|${resSeq}|${iCode || ''}`;
Â  Â  Â  let entry = atomsByChainResidue.get(key);
Â  Â  Â  if (!entry) { entry = { chain: chainId, resSeq, iCode, resName, atoms: [] }; atomsByChainResidue.set(key, entry); }
Â  Â  Â  entry.atoms.push({ atomName, x, y, z });
Â  Â  Â  if (atomName === 'CA') entry.ca = { x, y, z };
Â  Â  }
Â  Â  const chains = new Map();
Â  Â  for (const entry of atomsByChainResidue.values()) {
Â  Â  Â  const arr = chains.get(entry.chain) || [];
Â  Â  Â  arr.push(entry);
Â  Â  Â  chains.set(entry.chain, arr);
Â  Â  }
Â  Â  const perChain = {};
Â  Â  for (const [chainId, residues] of chains) {
Â  Â  Â  residues.sort((a,b)=> a.resSeq-b.resSeq || (a.iCode||'').localeCompare(b.iCode||''));
Â  Â  Â  const caTrace = residues.filter(r=>r.ca).map(r => ({ resSeq:r.resSeq, iCode:r.iCode||'', resName:r.resName, x:r.ca.x, y:r.ca.y, z:r.ca.z }));
Â  Â  Â  const seqOne = residues.map(r => THREE_LETTER_TO_ONE[r.resName.toUpperCase()] || 'X').join('');
Â  Â  Â  perChain[chainId] = {
Â  Â  Â  Â  chainId,
Â  Â  Â  Â  sequence: seqOne,
Â  Â  Â  Â  residues: residues.map(r => ({ resSeq:r.resSeq, iCode:r.iCode||'', resName:r.resName, oneLetter: THREE_LETTER_TO_ONE[r.resName.toUpperCase()] || 'X', hasCA:Boolean(r.ca) })),
Â  Â  Â  Â  caTrace
Â  Â  Â  };
Â  Â  }
Â  Â  return { chains: perChain };
Â  }
Â  function classifyChainType(seq){
Â  Â  const len = seq.length;
Â  Â  const likelyVariableLen = len >= 95 && len <= 130;
Â  Â  const hasCys = (seq.match(/C/g) || []).length >= 2;
Â  Â  const hasTrp = seq.includes('W');
Â  Â  const heavySigns = [ /GGG/.test(seq), /WGQG/.test(seq), /VLVL|TLVL/.test(seq) ];
Â  Â  const lightSigns = [ /FGG/.test(seq), /LQMT|IQMT|MQMT/.test(seq), /WYQQ/.test(seq) ];
Â  Â  let scoreH=0, scoreL=0;
Â  Â  if (likelyVariableLen) {scoreH++; scoreL++;}
Â  Â  if (hasCys) {scoreH++; scoreL++;}
Â  Â  if (hasTrp) {scoreH++; scoreL++;}
Â  Â  for (const r of heavySigns) if (r) scoreH++;
Â  Â  for (const r of lightSigns) if (r) scoreL++;
Â  Â  if (scoreH >= scoreL + 1) return 'H';
Â  Â  if (scoreL >= scoreH + 1) return 'L';
Â  Â  return 'Unknown';
Â  }
Â  const CDR_INDEX_RANGES = {
Â  Â  Kabat: { H: { CDR1: [26,35], CDR2: [50,65], CDR3: [95,115] }, L: { CDR1: [23,34], CDR2: [49,56], CDR3: [88,98] } },
Â  Â  Chothia:{ H: { CDR1: [26,32], CDR2: [52,56], CDR3: [95,110] }, L: { CDR1: [26,32], CDR2: [50,52], CDR3: [91,96] } },
Â  Â  IMGT:Â  { H: { CDR1: [27,38], CDR2: [56,65], CDR3: [103,117] }, L: { CDR1: [27,38], CDR2: [56,65], CDR3: [103,117] } }
Â  };
Â  function anchorAlignmentOffsets(seq, chainType){
Â  Â  const idxCys = seq.indexOf('C');
Â  Â  const idxTrp = seq.indexOf('W', Math.max(20, idxCys + 10));
Â  Â  const base = idxCys >= 0 ? idxCys - 23 : 0;
Â  Â  const trpAdj = idxTrp >= 0 ? (idxTrp - (chainType === 'H' ? 41 : 35)) : 0;
Â  Â  return Math.round(0.6*base + 0.3*trpAdj);
Â  }
Â  function computeCDRsForChain(chainData, scheme='Kabat'){
Â  Â  const seq = chainData.sequence || '';
Â  Â  if (!seq) return { scheme, cdrs: [], frames: [], note: 'No sequence' };
Â  Â  const chainType = classifyChainType(seq);
Â  Â  const ranges = CDR_INDEX_RANGES[scheme] || CDR_INDEX_RANGES.Kabat;
Â  Â  const rangesForChain = ranges[chainType === 'H' ? 'H' : 'L'];
    
    if (!rangesForChain) return { scheme, chainType, cdrs: [], frames: [], note: 'Chain type not recognized for CDR mapping' };

Â  Â  const offset = anchorAlignmentOffsets(seq, chainType);
Â  Â  const cdrs = Object.entries(rangesForChain).map(([region,[s,e]])=>{
Â  Â  Â  const start = Math.max(0, Math.min(s + offset, seq.length - 1));
Â  Â  Â  const endÂ  Â = Math.max(0, Math.min(e + offset, seq.length - 1));
Â  Â  Â  return { region, start, end, sequence: seq.slice(start, end + 1) };
Â  Â  });
    
Â  Â  const frames = [];
    // Safety check added to prevent errors if cdrs array is incomplete
    if (cdrs.length >= 3) {
    Â  Â  if (cdrs[0].start > 0) frames.push({ region: 'FR1', start: 0, end: cdrs[0].start - 1 });
    Â  Â  frames.push({ region: 'FR2', start: cdrs[0].end + 1, end: cdrs[1].start - 1 });
    Â  Â  frames.push({ region: 'FR3', start: cdrs[1].end + 1, end: cdrs[2].start - 1 });
    Â  Â  frames.push({ region: 'FR4', start: cdrs[2].end + 1, end: seq.length - 1 });
    }
Â  Â  return { scheme, chainType, cdrs, frames, note: 'Heuristic mapping' };
Â  }
Â  function annotateAntibodyChains(parsed){
Â  Â  const result = {};
Â  Â  for (const chainId of Object.keys(parsed.chains)) {
Â  Â  Â  const chain = parsed.chains[chainId];
Â  Â  Â  const type = classifyChainType(chain.sequence);
Â  Â  Â  result[chainId] = {
Â  Â  Â  Â  chainId, chainType: type, sequenceLength: chain.sequence.length,
Â  Â  Â  Â  cdrs: {
Â  Â  Â  Â  Â  Kabat: computeCDRsForChain(chain,'Kabat'),
Â  Â  Â  Â  Â  Chothia: computeCDRsForChain(chain,'Chothia'),
Â  Â  Â  Â  Â  IMGT: computeCDRsForChain(chain,'IMGT')
Â  Â  Â  Â  },
Â  Â  Â  Â  caTrace: chain.caTrace
Â  Â  Â  };
Â  Â  }
Â  Â  return result;
Â  }
Â  function makeFragments(chainData, windowSize=10, step=1){
Â  Â  const { caTrace } = chainData;
Â  Â  if (!caTrace || !caTrace.length) return [];
Â  Â  const frags=[];
Â  Â  for (let i=0; i+windowSize<=caTrace.length; i+=step) {
Â  Â  Â  const coords=caTrace.slice(i,i+windowSize);
Â  Â  Â  frags.push({ startIndex:i, endIndex:i+windowSize-1, sequence: coords.map(r=>THREE_LETTER_TO_ONE[r.resName.toUpperCase()]||'X').join(''), caCoords: coords });
Â  Â  }
Â  Â  return frags;
Â  }
Â  return { parsePDB, classifyChainType, computeCDRsForChain, annotateAntibodyChains, makeFragments };
})();

/* CDR UI */
let currentParsedAb=null, currentCDRAnnotations=null;
function bindCDRControls(){
Â  ['showCDR1','showCDR2','showCDR3','showFrameworks'].forEach(id=>{
Â  Â  const el=E(id); if(el){ el.addEventListener('change', ()=>{ if(currentParsedAb&&currentCDRAnnotations){ visualizeCDRs(currentParsedAb,currentCDRAnnotations,E('schemeSelect').value); } }); }
Â  });
}
function copyAbPDBToCDR(){ const txt=E('pdbAText').value.trim(); if(!txt){alert('No Antibody PDB in Protein A');return;} E('cdrPDB').value=txt; }
function runCDRAnalysis(){
Â  const pdbText = E('cdrPDB').value || E('pdbAText').value;
Â  if (!pdbText) { alert('Please provide a PDB structure'); return; }
Â  const parsed = AntibodyPDB.parsePDB(pdbText);
Â  const annotations = AntibodyPDB.annotateAntibodyChains(parsed);
Â  const scheme = E('schemeSelect').value;
Â  currentParsedAb = parsed;
Â  currentCDRAnnotations = annotations;
Â  displayCDRResults(annotations, scheme);
Â  visualizeCDRs(parsed, annotations, scheme);
Â  displayCDRSequenceTable(annotations, scheme);
}
function displayCDRResults(annotations, scheme){
Â  const container=E('cdrResults'); let html='';
Â  for (const chainId in annotations) {
Â  Â  const chain=annotations[chainId];
Â  Â  const cdrData=chain.cdrs[scheme];
Â  Â  html += `
Â  Â  Â  <div class="scheme-card">
Â  Â  Â  Â  <h4>Chain ${chainId} (${chain.chainType})</h4>
Â  Â  Â  Â  <div style="font-size:12px;color:#9ca3af">Length: ${chain.sequenceLength} aa</div>
Â  Â  Â  Â  ${cdrData.cdrs.map(cdr=>`
Â  Â  Â  Â  Â  <div class="cdr-highlight">
Â  Â  Â  Â  Â  Â  <strong>${cdr.region}</strong>:
Â  Â  Â  Â  Â  Â  <span class="cdr-region">${cdr.sequence||'-'}</span>
Â  Â  Â  Â  Â  Â  <span style="font-size:11px;color:#6b7280">[${cdr.start}-${cdr.end}]</span>
Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  `).join('')}
Â  Â  Â  </div>`;
Â  }
Â  container.innerHTML=html || '<div class="infobox small">No chains parsed.</div>';
}
function visualizeCDRs(parsed, annotations, scheme){
Â  if (!viewerCDR) return; viewerCDR.clear();
Â  for (const chainId in parsed.chains) {
Â  Â  const chain = parsed.chains[chainId];
Â  Â  const cdrData = annotations[chainId]?.cdrs[scheme];
Â  Â  if (!cdrData) continue;
Â  Â  let pdbText='';
Â  Â  chain.caTrace.forEach((res, idx)=>{
Â  Â  Â  pdbText += `ATOMÂ  ${String(idx+1).padStart(5)} CAÂ  Â ${res.resName.padEnd(3)} ${chainId}${String(res.resSeq).padStart(4)}Â  Â  ${res.x.toFixed(3).padStart(8)}${res.y.toFixed(3).padStart(8)}${res.z.toFixed(3).padStart(8)}Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C\n`;
Â  Â  });
Â  Â  viewerCDR.addModel(pdbText,'pdb');
Â  Â  const modelIdx = viewerCDR.getNumModels()-1;
Â  Â  const show = {1:E('showCDR1')?.checked,2:E('showCDR2')?.checked,3:E('showCDR3')?.checked};
Â  Â  const cols=['#f87171','#fbbf24','#34d399'];
Â  Â  cdrData.cdrs.forEach((cdr,i)=>{
Â  Â  Â  if (show[i+1]) {
Â  Â  Â  Â  viewerCDR.setStyle(
Â  Â  Â  Â  Â  {model:modelIdx, resi: Array.from({length: cdr.end-cdr.start+1}, (_,k)=> cdr.start + k + 1)},
Â  Â  Â  Â  Â  {cartoon:{color:cols[i%3]}}
Â  Â  Â  Â  );
Â  Â  Â  }
Â  Â  });
Â  Â  if (E('showFrameworks')?.checked) { viewerCDR.setStyle({model:modelIdx}, {cartoon:{color:'#4b5563'}}); }
Â  }
Â  viewerCDR.zoomTo(); viewerCDR.render();
}
function displayCDRSequenceTable(annotations, scheme){
Â  const container=E('cdrSequenceTable');
Â  let html='<table class="table"><thead><tr><th>Chain</th><th>Type</th><th>Region</th><th>Sequence</th><th>Position</th></tr></thead><tbody>';
Â  for (const chainId in annotations) {
Â  Â  const chain=annotations[chainId];
Â  Â  const cdrData=chain.cdrs[scheme];
Â  Â  cdrData.cdrs.forEach(cdr=>{
Â  Â  Â  html+=`<tr><td>${chainId}</td><td>${chain.chainType}</td><td>${cdr.region}</td><td style="font-family:monospace">${cdr.sequence}</td><td>${cdr.start+1}-${cdr.end+1}</td></tr>`;
Â  Â  });
Â  }
Â  html+='</tbody></table>'; container.innerHTML=html;
}

/* Fragment generator */
function generateFragments(){
Â  const pdbText = E('fragPDB').value;
Â  if (!pdbText) { alert('Please provide a PDB structure'); return; }
Â  const windowSize = parseInt(E('windowSize').value) || 10;
Â  const stepSize = parseInt(E('stepSize').value) || 1;
Â  const chainFilter = E('chainFilter').value.split(',').map(s=>s.trim()).filter(Boolean);

Â  const parsed = AntibodyPDB.parsePDB(pdbText);
Â  const resultsContainer = E('fragmentResults');
Â  let html = '<h3>Generated Fragments</h3>'; let allFragments=[];

Â  for (const chainId in parsed.chains) {
Â  Â  if (chainFilter.length && !chainFilter.includes(chainId)) continue;
Â  Â  const chain = parsed.chains[chainId];
Â  Â  const fragments = AntibodyPDB.makeFragments(chain, windowSize, stepSize);
Â  Â  allFragments.push({chainId, fragments});
Â  Â  html += `<div class="card">
Â  Â  Â  <h4>Chain ${chainId}: ${fragments.length} fragments</h4>
Â  Â  Â  <div style="max-height:200px;overflow:auto">
Â  Â  Â  Â  ${fragments.slice(0, 10).map((frag,i)=>`
Â  Â  Â  Â  Â  <div style="font-family:monospace;font-size:12px;padding:4px;background:#0a0f1a;margin:2px 0;border-radius:4px">
Â  Â  Â  Â  Â  Â  Fragment ${i+1}: ${frag.sequence} [${frag.startIndex}-${frag.endIndex}]
Â  Â  Â  Â  Â  </div>`).join('')}
Â  Â  Â  Â  ${fragments.length > 10 ? `<div style="color:#9ca3af;font-size:12px">... and ${fragments.length - 10} more</div>` : ''}
Â  Â  Â  </div>
Â  Â  </div>`;
Â  }
Â  resultsContainer.innerHTML = html;
Â  window.generatedFragments = allFragments;
}
function downloadFragments(){
Â  if (!window.generatedFragments || !window.generatedFragments.length) { alert('No fragments generated yet'); return; }
Â  let pdbContent=''; let fragNum=1;
Â  window.generatedFragments.forEach(({chainId,fragments})=>{
Â  Â  fragments.forEach(frag=>{
Â  Â  Â  pdbContent += `MODELÂ  Â  Â ${fragNum}\n`;
Â  Â  Â  frag.caCoords.forEach((coord,i)=>{
Â  Â  Â  Â  pdbContent += `ATOMÂ  ${String(i+1).padStart(5)} CAÂ  Â ${coord.resName.padEnd(3)} ${chainId}${String(coord.resSeq).padStart(4)}Â  Â  ${coord.x.toFixed(3).padStart(8)}${coord.y.toFixed(3).padStart(8)}${coord.z.toFixed(3).padStart(8)}Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C\n`;
Â  Â  Â  });
Â  Â  Â  pdbContent += `ENDMDL\n`; fragNum++;
Â  Â  });
Â  });
Â  pdbContent += 'END\n';
Â  downloadBlob(pdbContent, 'fragments.pdb');
}

/* NMR & Omics (X5) */
function bindOmicsAndNMREvents(){
Â  E('nmrSmiles').addEventListener('input', updateNMRImage);
Â  E('btnPredict1H').addEventListener('click', () => predictNMR('1H'));
Â  E('btnPredict13C').addEventListener('click', () => predictNMR('13C'));
Â  E('btnPredictCOSY').addEventListener('click', () => predictNMR('COSY'));
Â  E('btnPredictNOESY').addEventListener('click', () => predictNMR('NOESY'));

Â  const B=(id,fn)=>{ const el=E(id); if(el) el.addEventListener('click', fn); };
Â  B('omicsLoadProteinDemo',()=>{E('omicsProteinPDB').value=`ATOMÂ  Â  Â  1Â  CAÂ  ALA AÂ  Â 1Â  Â  Â  Â 0.000Â  Â 0.000Â  Â 0.000Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
ATOMÂ  Â  Â  2Â  CAÂ  LEU AÂ  Â 2Â  Â  Â  Â 1.500Â  Â 1.200Â  Â 0.200Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
ATOMÂ  Â  Â  3Â  CAÂ  LYS AÂ  Â 3Â  Â  Â  Â 3.000Â  Â 0.100Â  Â 1.000Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
ATOMÂ  Â  Â  4Â  CAÂ  ASP AÂ  Â 4Â  Â  Â  Â 4.300Â  Â 1.400Â  Â 1.400Â  1.00Â  0.00Â  Â  Â  Â  Â  Â C
END`;});
Â  B('omicsLoadLipidDemo',()=>{E('omicsLipidSmiles').value=`CCCCCCCCCCCC=CCCCCC(=O)OCCN(C)CH3
CCOC(=O)CCCCCCCCCCCC
CCCCCCCCCCCCCCCC(=O)OCCOP(=O)(O)OCCN`});
Â  B('omicsLoadCarbDemo',()=>{E('omicsCarbSmiles').value=`OC[C@H]1O[C@@H](O)[C@H](O)[C@@H](O)[C@H]1O
O[C@H]1CO[C@@H](O)[C@H](O)[C@H]1O`;});
Â  B('omicsLoadDNADemo',()=>{E('omicsDNA').value=`>demo
ACGTACGTGGCCGGTTTTAAAACGCGCGTTTACGCGCAGCGCGGATATATATATAGCGC`});
Â  B('omicsAnalyzeBtn', runOmicsAnalysis);
Â  B('omicsExportBtn', ()=>{ if(lastOmics) downloadBlob(JSON.stringify(lastOmics,null,2),'omics_results.json'); else alert('Run analysis first.');});
}
async function updateNMRImage(){
Â  const smiles = E('nmrSmiles').value.trim();
Â  const imgDiv = E('nmrMoleculeImage');
Â  if (!smiles) { imgDiv.style.backgroundImage = 'none'; imgDiv.textContent=''; return; }
Â  imgDiv.textContent = 'Structure preview requires a server-side toolkit (e.g., RDKit).';
Â  imgDiv.style.textAlign = 'center'; imgDiv.style.padding = '20px';
}
function predictNMR(type){
Â  const smiles = E('nmrSmiles').value.trim(); const output = E('nmrPredictionOutput');
Â  if (!smiles) { output.textContent = 'Please enter a SMILES string.'; return; }
Â  let txt = `--- THEORETICAL ${type} PREDICTION FOR ${smiles} ---\n\n`;
Â  if (smiles === 'CC(=O)Oc1ccccc1C(=O)O'){
Â  Â  if(type==='1H'){ txt += `Aspirin, CDCl3 (typical):\n- CH3 singlet ~2.3 ppm (3H)\n- Ar multiplet 7.1â€“8.2 ppm (4H)\n- COOH broad >10 ppm`; }
Â  Â  else if(type==='13C'){ txt += `9 carbons: CH3 ~21; C=O(ester) ~169; C=O(acid) ~171; ring 120â€“155 ppm`; }
Â  Â  else if(type==='COSY'){ txt += `Ortho ring couplings visible; CH3 isolated`; }
Â  Â  else if(type==='NOESY'){ txt += `NOE: CH3 â†” ortho aryl possible; ring proximities`; }
Â  } else { txt += 'Demo provides a detailed aspirin template. For others, interpret via analogy.'; }
Â  output.textContent = txt;
}

/* OMICS ANALYZER (X5) */
let lastOmics=null;
function runOmicsAnalysis(){
Â  E('omicsStatus').textContent='running...';
Â  try{
Â  Â  const proteinPDB = (E('omicsProteinPDB').value||'').trim();
Â  Â  const lipidSmiles = (E('omicsLipidSmiles').value||'').trim().split(/\r?\n/).filter(Boolean);
Â  Â  const carbSmilesÂ  = (E('omicsCarbSmiles').value||'').trim().split(/\r?\n/).filter(Boolean);
Â  Â  const dnaTextÂ  Â  Â = (E('omicsDNA').value||'').trim();

Â  Â  const protAtoms = parsePDB(proteinPDB);
Â  Â  const aa = summarizeResidues(protAtoms);
Â  Â  const protDesc = {
Â  Â  Â  residues: aa.total,
Â  Â  Â  hydrophobic_fraction: round2(aa.hydrophobic/Math.max(1,aa.total)),
Â  Â  Â  charged_fraction: round2((aa.acidic+aa.basic)/Math.max(1,aa.total)),
Â  Â  Â  acidic: aa.acidic, basic: aa.basic, polar: aa.polar, hydrophobic: aa.hydrophobic
Â  Â  };

Â  Â  const lipDesc = summarizeSmilesSet(lipidSmiles);
Â  Â  const carbDesc = summarizeSmilesSet(carbSmiles);
Â  Â  const dnaDesc = summarizeDNA(dnaText);

Â  Â  const trends = inferTrends(protDesc, lipDesc, carbDesc, dnaDesc);

Â  Â  const rows = [];
Â  Â  const add = (k,v)=> rows.push(`<tr><td>${k}</td><td>${typeof v==='number'? (''+v): v}</td></tr>`);
Â  Â  add('Protein residues', protDesc.residues);
Â  Â  add('Protein hydrophobic fraction', protDesc.hydrophobic_fraction);
Â  Â  add('Protein charged fraction', protDesc.charged_fraction);

Â  Â  add('Lipids: count', lipDesc.count);
Â  Â  add('Lipids: avg heteroatom %', round3(lipDesc.avgHetPct));
Â  Â  add('Lipids: avg unsaturation idx', round3(lipDesc.avgUnsat));
Â  Â  add('Lipids: avg ring count', round3(lipDesc.avgRings));

Â  Â  add('Carbs: count', carbDesc.count);
Â  Â  add('Carbs: avg heteroatom %', round3(carbDesc.avgHetPct));
Â  Â  add('Carbs: avg unsaturation idx', round3(carbDesc.avgUnsat));
Â  Â  add('Carbs: avg ring count', round3(carbDesc.avgRings));

Â  Â  add('DNA: total bp', dnaDesc.total);
Â  Â  add('DNA: GC %', round2(dnaDesc.gc*100));
Â  Â  add('DNA: CpG / kb', round3(dnaDesc.cpgPerKb));
Â  Â  add('DNA: top 3-mers', dnaDesc.top3mers.map(x=>x[0]+':'+x[1]).join(', '));

Â  Â  E('omicsDescriptorBody').innerHTML = rows.join('');
Â  Â  E('omicsTrends').textContent = trends.join('\n');
Â  Â  lastOmics={protein:protDesc, lipids:lipDesc, carbs:carbDesc, dna:dnaDesc, trends};
Â  Â  E('omicsStatus').textContent='complete';
Â  }catch(err){
Â  Â  alert('Omics analysis failed: '+err.message);
Â  Â  E('omicsStatus').textContent='error';
Â  }
}
function summarizeResidues(atoms){
Â  const byRes=new Map();
Â  for(const a of atoms){ const key=(a.chain||'A')+':' +(a.resi||0); if(!byRes.has(key)) byRes.set(key,{resn:a.resn}); }
Â  const names=[...byRes.values()].map(x=>x.resn||'UNK');
Â  const acidic = names.filter(x=>x==='ASP'||x==='GLU').length;
Â  const basicÂ  = names.filter(x=>x==='LYS'||x==='ARG'||x==='HIS').length;
Â  const hydÂ  Â  = names.filter(x=>hydrophobic.has(x)).length;
Â  const polarÂ  = Math.max(0, names.length - acidic - basic - hyd);
Â  return { total:names.length, acidic, basic, polar, hydrophobic:hyd };
}
function summarizeSmilesSet(list){
Â  if(!list.length) return {count:0, avgHetPct:0, avgUnsat:0, avgRings:0};
Â  let hetPct=0, unsat=0, rings=0;
Â  for(const s of list){
Â  Â  const desc = smilesDescriptors(s);
Â  Â  hetPct += desc.hetPct; unsat += desc.unsaturation; rings += desc.rings;
Â  }
Â  return {count:list.length, avgHetPct:hetPct/list.length, avgUnsat:unsat/list.length, avgRings:rings/list.length};
}
function smilesDescriptors(s){
Â  const atoms = (s.match(/[A-Z][a-z]?/g)||[]);
Â  const hetÂ  Â = atoms.filter(a=>!/^C$/.test(a)).length;
Â  const total = atoms.length||1;
Â  const hetPct = total > 0 ? het/total : 0;
Â  const unsaturation = (s.match(/=/g)||[]).length + (s.match(/#|\\\\|\\//g)||[]).length*0.5;
Â  const rings = (s.match(/\d/g)||[]).length/2;
Â  return {hetPct, unsaturation, rings};
}
function summarizeDNA(txt){
Â  const seqs = parseFASTA(txt);
Â  const seq = seqs.join('').toUpperCase().replace(/[^ACGT]/g,'');
Â  const total = seq.length;
Â  const gc = total? ((seq.match(/[GC]/g)||[]).length/total):0;
Â  const cpg = (seq.match(/CG/g)||[]).length;
Â  const cpgPerKb = total? (cpg/(total/1000)):0;
Â  const km3 = kmerCounts(seq,3);
Â  const top3 = Object.entries(km3).sort((a,b)=>b[1]-a[1]).slice(0,5);
Â  return {total, gc, cpgPerKb, top3mers: top3};
}
function parseFASTA(t){
Â  if(!t) return [];
Â  const lines=t.split(/\r?\n/);
Â  const seqs=[]; let cur=[];
Â  for(const ln of lines){
Â  Â  if(ln.startsWith('>')){ if(cur.length){ seqs.push(cur.join('')); cur=[]; } }
Â  Â  else { cur.push(ln.trim()); }
Â  }
Â  if(cur.length) seqs.push(cur.join(''));
Â  return seqs.length?seqs:[''];
}
function kmerCounts(seq,k){
Â  const out={}; if(seq.length<k) return out;
Â  for(let i=0;i<=seq.length-k;i++){ const km=seq.slice(i,i+k); out[km]=(out[km]||0)+1; }
Â  return out;
}
function inferTrends(prot, lip, carb, dna){
Â  const trends=[];
Â  if(prot.hydrophobic_fraction>0.45 && lip.avgUnsat<1) trends.push('Membrane-leaning protein hydrophobicity with low lipid unsaturation suggests tighter, ordered microdomains.');
Â  if(carb.avgHetPct>0.35 && prot.charged_fraction>0.2) trends.push('High carbohydrate heteroatom% with higher protein charge hints at glycan-mediated recognition interfaces.');
Â  if(dna.gc>0.55 && lip.avgRings>0.4) trends.push('GC-rich DNA with ring-rich lipids may correlate with raft-associated chromatin-proximal signaling (heuristic).');
Â  if(!trends.length) trends.push('No strong cross-modal signals detected with the simple heuristics â€” consider richer toolkits (RDKit, proteomics ID, motif scans).');
Â  return trends;
}
const round2=x=>Math.round(x*100)/100;
const round3=x=>Math.round(x*1000)/1000;

function resetAll(){
Â  pdbAAllAtoms=[]; pdbBAllAtoms=[]; combos=[]; currentComboIndex=-1;
Â  ['pdbAText','pdbBText'].forEach(id=>E(id).value='');
Â  updateComboSelect(); E('poseControls').innerHTML=''; E('scoreBox').textContent=''; E('metricsDisplay').innerHTML='';
Â  viewer?.clear(); viewerLig?.clear(); viewerScr?.clear(); viewerComp?.clear(); viewerCDR?.clear();
Â  drawPlaceholder(viewer); status('idle'); setProgress(0);
}

/* ===== Antibody Analyzer Functions (Integrated) ===== */

function loadAnalyzerExample() {
    const exampleData = [
      {
        name: "Trastuzumab-FabX",
        affinityKD: 0.5,
        internalizationRate: 0.88,
        stabilityScore: 0.95,
        aggregationRisk: 0.1,
        epitopeClass: "synergistic",
        subclass: "IgG1",
        glycosylationSites: 2,
        fcEngineering: true,
      },
      {
        name: "Anti-CD20-L",
        affinityKD: 0.003,
        internalizationRate: 0.55,
        stabilityScore: 0.75,
        aggregationRisk: 0.3,
        epitopeClass: "inhibitory",
        subclass: "IgG4",
        glycosylationSites: 1,
        fcEngineering: false,
      },
      {
        name: "Bispecific-ADC",
        affinityKD: 3.2,
        internalizationRate: 0.92,
        stabilityScore: 0.88,
        aggregationRisk: 0.2,
        epitopeClass: "non_overlapping",
        subclass: "IgA",
        glycosylationSites: 3,
        fcEngineering: false,
      }
    ];
    E('analyzerInput').value = JSON.stringify(exampleData, null, 2);
  }
  
  function runAnalyzer() {
    const input = E('analyzerInput').value;
    const output = E('analyzerOutput');
    output.textContent = '';
  
    if (!input) {
      alert('Please paste candidate data or load the example.');
      return;
    }
  
    try {
      const data = JSON.parse(input);
      if (!Array.isArray(data)) {
        throw new Error("Input must be a JSON array.");
      }
  
      const candidates = data.map(item => new AntibodyFragment(item));
      
      // Sort by total score descending
      candidates.sort((a, b) => parseFloat(b.getTotalScore()) - parseFloat(a.getTotalScore()));
  
      let results = `Analyzed ${candidates.length} candidates (sorted by score):\n`;
      candidates.forEach(f => {
        results += f.explainFragment() + '\n';
      });
  
      output.textContent = results;
  
    } catch (error) {
      output.textContent = `Error processing input: ${error.message}\nPlease ensure the JSON format is correct and matches the required properties.`;
    }
  }
</script>
</body>
</html>
