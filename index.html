<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Comprehensive Docking Suite ‚Ä¢ Student Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0f172a" />
<meta name="description" content="Antibody‚Äìantigen docking, ligand docking, batch virtual screening (50 SMILES √ó ‚â§3 receptors), chain pairing, clustering, consensus ranking, 3D viz, QA & registry ‚Äî all in-browser. Student-friendly with instructions." />
<style>
  :root{
    --bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--line:#1f2937;
    --green:#34d399;--red:#f87171;--yellow:#fbbf24;--orange:#f97316;--purple:#a78bfa;
    --mono:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;--sans:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans);line-height:1.6}
  a{color:var(--accent);text-decoration:none}
  header{padding:34px 16px;background:radial-gradient(1200px 600px at 15% -10%,#1d2a4a,transparent 60%),radial-gradient(1000px 500px at 120% 10%,#2a1e4a,transparent 60%)}
  .wrap{max-width:1400px;margin:0 auto}
  h1{margin:0 0 8px;font-size:30px;font-weight:800;letter-spacing:.2px}
  h2{margin:0 0 10px;font-size:22px;font-weight:700}
  h3{margin:14px 0 6px;font-size:17px;font-weight:600}
  p.lead{color:var(--muted);margin:6px 0 0;font-size:14px}
  section{padding:22px 16px;border-top:1px solid var(--line);background:var(--panel)}
  .card{background:#0b1220;border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:12px;position:relative}
  .card:before{content:"";position:absolute;inset:-1px;border-radius:14px;padding:1px;background:linear-gradient(45deg,rgba(96,165,250,.35),rgba(167,139,250,.2));-webkit-mask:linear-gradient(#000 0 0) content-box,linear-gradient(#000 0 0);-webkit-mask-composite:xor;mask-composite:exclude}
  .grid{display:grid;gap:16px}
  @media(min-width:980px){.grid.two{grid-template-columns:1.05fr .95fr}}
  @media(min-width:1100px){.grid.three{grid-template-columns:repeat(3,1fr)}}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{font-weight:600;font-size:13px}
  input[type=number],input[type=text],textarea,select{
    background:#0a0f1a;color:var(--text);border:1px solid #1f2937;border-radius:8px;padding:8px 10px;font-family:var(--mono);font-size:13px;min-width:80px
  }
  textarea{width:100%;min-height:110px;resize:vertical}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:9px 12px;border-radius:10px;font-weight:700;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:13px;transition:.2s}
  .btn:hover:not([disabled]){transform:translateY(-1px);box-shadow:0 6px 16px rgba(96,165,250,.25)}
  .btn.primary{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0}
  .btn.green{background:linear-gradient(180deg,#059669,#047857);border:0}
  .btn.red{background:linear-gradient(180deg,#dc2626,#b91c1c);border:0}
  .btn.purple{background:linear-gradient(180deg,#7c3aed,#6d28d9);border:0}
  .btn.orange{background:linear-gradient(180deg,#f97316,#ea580c);border:0}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .pill{padding:2px 8px;border:1px solid #334155;border-radius:999px;font-size:12px;color:#93c5fd;font-weight:700}
  progress{width:260px;height:10px;border:1px solid var(--line);border-radius:999px;background:#0b1220}
  progress::-webkit-progress-value{background:#60a5fa;border-radius:999px;transition:width .3s}
  .infobox{border:1px solid #334155;border-left:4px solid var(--accent);border-radius:10px;padding:10px;background:#0a0f1a;color:#cbd5e1;margin:10px 0;font-size:13px}
  .errorbox{border:1px solid #7f1d1d;border-left:4px solid #dc2626;border-radius:10px;padding:10px;background:#1a0c0c;color:#fecaca;margin:10px 0}
  .successbox{border:1px solid #065f46;border-left:4px solid #10b981;border-radius:10px;padding:10px;background:#0a1f1a;color:#a7f3d0;margin:10px 0}
  .note{font-size:12px;color:var(--muted)}
  .score{font-family:var(--mono);background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:8px;overflow:auto;font-size:12px;line-height:1.5;white-space:pre-wrap}
  .chainchips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{border:1px solid #334155;border-radius:999px;padding:2px 8px;display:inline-flex;align-items:center;gap:6px;font-size:13px}
  .chip input{accent-color:#60a5fa}
  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .tabbtn{padding:8px 12px;border-radius:999px;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:14px;font-weight:700;transition:.2s}
  .tabbtn:hover{background:#152034}
  .tabbtn.active{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0;color:#fff}
  .tabsec{display:none}
  .tabsec.active{display:block}
  .table{width:100%;border-collapse:collapse;font-size:13px;background:#0a0f1a}
  .table th{background:#152034;padding:8px;text-align:left;border-bottom:2px solid var(--line);position:sticky;top:0;z-index:1}
  .table td{padding:6px 8px;border-bottom:1px solid #112033}
  .table tr:hover{background:#0f1829}
  .table-container{max-height:460px;overflow:auto;border:1px solid var(--line);border-radius:8px;margin-top:8px}
  #viewer,#viewerLig,#viewerScr,#viewerComp{position:relative;width:100%;height:560px;border:1px solid var(--line);border-radius:10px;background:#0a0f1a;overflow:hidden}
  .metric-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin:10px 0}
  .metric-card{background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:10px;text-align:center}
  .metric-value{font-size:20px;font-weight:800;color:var(--accent)}
  .metric-label{font-size:12px;color:var(--muted)}
  footer{padding:18px 16px;color:var(--muted);text-align:center;font-size:13px}
  .small{font-size:12px}
  .help{display:flex;gap:8px;flex-wrap:wrap}
  .help .step{background:#0a0f1a;border:1px dashed #274060;border-radius:10px;padding:10px;flex:1;min-width:240px}
  .help .step b{display:block;margin-bottom:6px}
  #nmrMoleculeImage{min-height:200px;background-size:contain;background-position:center;background-repeat:no-repeat;border-radius:8px;border:1px solid var(--line);margin-bottom:12px}
</style>
</head>
<body>

<header>
  <div class="wrap">
    <h1>üß¨ Comprehensive Molecular Docking Suite ‚Äî Student Edition</h1>
    <p class="lead">
      Antibody‚Äìantigen docking ‚Ä¢ Single-ligand docking ‚Ä¢ Batch screening (‚â§50 SMILES √ó ‚â§3 receptors) ‚Ä¢
      Chain pairing ‚Ä¢ Diversity clustering ‚Ä¢ Consensus ranking ‚Ä¢ ŒîH estimation ‚Ä¢ QA ‚Ä¢ Run registry ‚Ä¢ In-browser
    </p>

    <div class="help" aria-label="Quick start help">
      <div class="step"><b>1) Load structures</b> Paste/upload two PDBs on Antibody Docking, then click <i>Parse</i>. Use <i>Example</i> to try instantly.</div>
      <div class="step"><b>2) Set parameters</b> Choose sampling size and scoring; defaults are safe. Press <i>Run Docking</i>.</div>
      <div class="step"><b>3) Inspect & export</b> Use pose buttons, toggles, and exports. Try <i>Cluster Poses</i> and the <i>Analysis</i> tab.</div>
    </div>

    <div class="tabs" role="tablist">
      <button class="tabbtn active" data-tab="dockTab" aria-selected="true">üß∑ Antibody Docking</button>
      <button class="tabbtn" data-tab="ligTab">üß™ Ligand Docking</button>
      <button class="tabbtn" data-tab="screenTab">üìö Batch Screening</button>
      <button class="tabbtn" data-tab="qaTab">‚úÖ QA & Registry</button>
      <button class="tabbtn" data-tab="analysisTab">üìä Analysis</button>
      <button class="tabbtn" data-tab="omicsTab">üî¨ Omics Analysis</button>
      <button class="tabbtn" data-tab="nmrTab">üì° NMR Prediction</button>
      <button class="tabbtn" data-tab="aboutTab">‚ÑπÔ∏è About</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnDemo" title="Load tiny example and run">üéØ Load Demo & Dock</button>
      <button class="btn green" id="btnSaveSession" title="Download a snapshot of your work">üíæ Save Session</button>
      <button class="btn purple" id="btnLoadSession" title="Load a previously saved session JSON">üìÇ Load Session</button>
      <span class="pill" id="statusPill" aria-live="polite">idle</span>
      <progress id="prog" value="0" max="1" aria-label="progress"></progress>
    </div>
  </div>
</header>

<section id="dockTab" class="tabsec active" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>1) Load Proteins</h2>
      <div class="row small" style="color:#9ca3af">Upload PDBs or paste text. Parse, then pick chains.</div>
      <div class="row">
        <div style="flex:1;min-width:300px">
          <h3>Protein A (Antibody) <span class="pill" id="badgeA">0 atoms</span></h3>
          <div class="row">
            <input type="file" id="pdbAFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('A')" title="Load small demo A">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('A')" title="Fetch PDB by 4-char ID">Fetch PDB ID</button>
          </div>
          <textarea id="pdbAText" placeholder="Paste PDB for Protein A" aria-label="PDB text A"></textarea>
          <div class="row"><label>Chains:</label><div id="chainsABox" class="chainchips"></div></div>
          <div id="chainWarnA" class="infobox small">Parse to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('A')">üîé Parse A</button><button class="btn" onclick="selectAllChains('A')">Select All</button><button class="btn" onclick="invertChains('A')">Invert</button></div>
        </div>
        <div style="flex:1;min-width:300px">
          <h3>Protein B (Antigen) <span class="pill" id="badgeB">0 atoms</span></h3>
          <div class="row">
            <input type="file" id="pdbBFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('B')" title="Load small demo B">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('B')">Fetch PDB ID</button></div>
          <textarea id="pdbBText" placeholder="Paste PDB for Protein B" aria-label="PDB text B"></textarea>
          <div class="row"><label>Chains:</label><div id="chainsBBox" class="chainchips"></div></div>
          <div id="chainWarnB" class="infobox small">Parse to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('B')">üîé Parse B</button><button class="btn" onclick="selectAllChains('B')">Select All</button><button class="btn" onclick="invertChains('B')">Invert</button></div>
        </div>
      </div>
      <details style="margin-top:10px"><summary><b>Input notes (click)</b></summary>
        <div class="small" style="color:#9ca3af;padding-top:6px">
          <b>Formats:</b> PDB text, .pdb.gz ‚Ä¢ <b>Fetch:</b> RCSB via PDB ID ‚Ä¢ <b>Cartoon:</b> needs backbone atoms (N/CA/C/O)
        </div>
      </details>
    </div>

    <div class="card">
      <h2>2) Docking Parameters</h2>
      <div class="infobox note">Tip: Start with defaults. Increase <b>Samples</b> for better coverage on real structures.</div>
      <h4>Sampling</h4>
      <div class="row" title="Random rigid-body sampling">
        <label>Samples</label><input type="number" id="samples" value="12000" min="1000" step="1000" />
        <label>Max Translation (√Ö)</label><input type="number" id="maxTrans" value="12" step="1" />
        <label>Atom Set</label><select id="atomMode"><option value="CA">C-alpha only</option><option value="BB">Backbone</option><option value="HEAVY" selected>All heavy</option></select>
      </div>
      <h4 style="margin-top:8px">Scoring</h4>
      <div class="row" title="Contact-based score with soft clashes">
        <label>Contact (√Ö)</label><input type="number" id="contactCut" value="4.8" step="0.1" />
        <label>Clash Factor</label><input type="number" id="clashFactor" value="0.85" step="0.05" />
        <label>Contact W</label><input type="number" id="wContact" value="1.0" step="0.1" />
        <label>Clash W</label><input type="number" id="wClash" value="6.0" step="0.1" />
        <label>Softness</label><input type="number" id="soft" value="0.5" step="0.1" />
      </div>
      <h4 style="margin-top:8px">Pairing & Output</h4>
      <div class="row">
        <label>Pairing</label>
        <select id="pairMode">
          <option value="AGG">Aggregate (all selected)</option>
          <option value="A_EACH_B">A √ó each B-chain</option>
          <option value="CROSS">each A-chain √ó each B-chain</option>
        </select>
        <label>Top Poses</label><input type="number" id="topN" value="12" min="1" max="50" />
        <label>Rescore</label><select id="rescoreMode"><option value="NONE">Skip</option><option value="HEAVY">Heavy</option><option value="HEAVY_REFINE" selected>Heavy + refine</option></select>
        <label>Seed</label><input type="number" id="seed" value="42" />
      </div>
      <div class="row">
        <label>Diversity (¬∞/√Ö)</label><input type="number" id="dupAngle" value="12" step="1" style="width:90px" />
        <input type="number" id="dupTrans" value="2" step="0.5" style="width:90px" />
        <label>Clusters</label><input type="number" id="clustersK" value="6" min="1" max="24" style="width:90px" />
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="dockBtn">‚ñ∂Ô∏è Run Docking</button>
        <button class="btn red" id="cancelBtn" disabled>‚úñ Cancel</button>
        <button class="btn orange" id="resetBtn">üîÑ Reset</button>
      </div>
      <div class="infobox small"><b>Score = contacts√óWc ‚àí clashes√óWx</b>. Clustering is pose-diversity aware. Heavy rescoring refines ranks.</div>
    </div>
  </div>

  <div class="wrap grid two">
    <div class="card">
      <h2>3) Complex Selector ‚Ä¢ 3D Visualization & Results</h2>
      <div class="row">
        <label>Complex</label>
        <select id="comboSelect" style="min-width:260px"></select>
        <button class="btn" id="btnPrevCombo">‚óÄ Prev</button>
        <button class="btn" id="btnNextCombo">Next ‚ñ∂</button>
        <button class="btn" id="btnClusters" title="K-medoids-style cluster of top poses">üìé Cluster Poses</button>
      </div>
      <div id="viewer" role="img" aria-label="3D viewer"></div>
      <div class="row" style="margin-top:8px;flex-wrap:wrap" id="poseControls"></div>
      <div class="row" style="margin-top:8px">
        <label class="chip"><input type="checkbox" id="toggleContacts" checked> Contacts</label>
        <label class="chip"><input type="checkbox" id="toggleHB" checked> H-bonds</label>
        <label class="chip"><input type="checkbox" id="toggleSB" checked> Salt bridges</label>
        <label class="chip"><input type="checkbox" id="toggleHydro"> Hydrophobic</label>
      </div>
      <div class="score" id="scoreBox" style="margin-top:8px"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnAllPDB" title="Download multi-model PDB for this complex">‚¨á All Poses PDB (this complex)</button>
        <button class="btn green" id="btnCurrentPDB">‚¨á Current PDB</button>
        <button class="btn" id="btnCSV">‚¨á CSV</button>
        <button class="btn" id="btnJSON">‚¨á JSON</button>
        <button class="btn purple" id="btnPNG">üì∏ PNG</button>
        <button class="btn" id="btnAllComplexesPDB" title="All complexes, all poses">‚¨á All Complexes (multi-MODEL PDB)</button>
      </div>
    </div>

    <div class="card">
      <h2>Interface Metrics & Enthalpy</h2>
      <div class="metric-grid" id="metricsDisplay"></div>
      <h4 style="margin-top:10px">Energy Parameters</h4>
      <div class="row">
        <label>k_elec</label><input type="number" id="kElec" value="0.5" step="0.1" />
        <label>Elec Cutoff (√Ö)</label><input type="number" id="elecCut" value="12" step="0.5" />
        <label>Desolv W</label><input type="number" id="wDesolv" value="0.2" step="0.1" />
      </div>
      <div class="infobox small">
        <b>ŒîH (kcal/mol) ‚âà</b> ‚àí0.5√ócontacts ‚àí2.5√óH-bonds ‚àí4.0√ósalt-bridges ‚àí1.0√óhydrophobic +0.3√óclash + electrostatics +0.2√ócontacts (desolv).
      </div>
      <div class="infobox small"><b>Reproducibility:</b> Outputs include parameters & seed; registry stores signature.</div>
      <h3>Complex Summary</h3>
      <div class="table-container small"><table class="table"><thead><tr><th>Complex</th><th>Top Score</th><th>Contacts</th><th>ŒîH</th></tr></thead><tbody id="comboSummaryBody"></tbody></table></div>
    </div>
  </div>
</section>

<section id="ligTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>üß™ Single Ligand Docking</h2>
      <div class="infobox small">SMILES‚Üí3D uses simplified embedding for demo; use RDKit/OpenBabel for production.</div>
      <div class="row">
        <div style="flex:1;min-width:300px">
          <h3>Receptor PDB</h3>
          <textarea id="ligReceptorPDB" placeholder="Paste receptor PDB"></textarea>
          <div class="row" style="margin-top:6px"><button class="btn" onclick="loadLigandDemoReceptor()">Load Example</button><button class="btn" onclick="parseReceptorForLigand()">Parse & Preview</button></div>
        </div>
        <div style="flex:1;min-width:300px">
          <h3>Ligand SMILES</h3>
          <textarea id="ligSmiles" placeholder="e.g., CC(=O)Oc1ccccc1C(=O)O (aspirin)"></textarea>
          <div class="row" style="margin-top:6px">
            <label>3D Method</label><select id="ligEmbedMethod"><option value="HASH">HashCloud</option><option value="HELIX">RingHelix</option></select>
            <label>Seed</label><input type="number" id="ligSeed" value="1337" style="width:90px" />
            <button class="btn primary" onclick="runSingleLigandDock()">‚ñ∂Ô∏è Dock</button>
          </div>
        </div>
      </div>
      <div class="infobox small"><b>Note:</b> Posing uses receptor center sampling; score = contacts ‚àí clash (same core terms).</div>
    </div>
    <div class="card">
      <h2>Ligand Docking Result</h2>
      <div id="viewerLig"></div>
      <div class="score" id="ligScore" style="margin-top:8px"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnLigPDB">‚¨á Complex PDB</button>
        <button class="btn" id="btnLigCSV">‚¨á CSV Result</button>
        <span class="pill" id="ligStatus">idle</span>
      </div>
    </div>
  </div>
</section>

<section id="screenTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>üìö Batch Screening (‚â§50 SMILES √ó ‚â§3 Receptors)</h2>
      <div class="help note">How-to: Paste up to 50 SMILES (one per line). Paste 2‚Äì3 receptor PDBs separated by a line containing only <code>END</code>. Choose parameters and Start.</div>
      <div class="grid three">
        <div>
          <h3>SMILES Library</h3>
          <textarea id="scrSmiles" placeholder="One SMILES per line (max 50)"></textarea>
        </div>
        <div>
          <h3>Receptors (PDBs)</h3>
          <textarea id="scrReceptors" placeholder="Paste 2‚Äì3 PDBs separated by a line with only: END"></textarea>
          <div class="small" style="color:#9ca3af">Delimiter must be exactly "END" on its own line.</div>
        </div>
        <div>
          <h3>Parameters</h3>
          <div class="row"><label>Samples/Ligand</label><input type="number" id="scrSamples" value="5000" min="1000" step="500" /></div>
          <div class="row"><label>Contact (√Ö)</label><input type="number" id="scrContactCut" value="4.8" step="0.1" /></div>
          <div class="row"><label>Clash Factor</label><input type="number" id="scrClashFactor" value="0.85" step="0.05" /></div>
          <div class="row"><label>Seed</label><input type="number" id="scrSeed" value="777" /></div>
          <div class="row"><label>3D Method</label><select id="scrEmbedMethod"><option value="HASH">HashCloud</option><option value="HELIX">RingHelix</option></select></div>
          <div class="row"><label>Sort</label>
            <select id="scrSort"><option value="score">Score ‚Üì</option><option value="enthalpy">ŒîH ‚Üë (most negative)</option><option value="consensus" selected>Consensus (rank-sum)</option></select>
          </div>
          <div class="row" style="margin-top:10px"><button class="btn primary" id="btnStartScreen">‚ñ∂Ô∏è Start Screening</button><button class="btn red" id="btnStopScreen" disabled>‚úñ Stop</button></div>
          <div class="infobox small">Sequential SMILES√óReceptor; consensus = rank(score‚Üì, ŒîH‚Üë, contacts‚Üì).</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Results</h2>
      <div class="row" style="margin-bottom:8px">
        <button class="btn green" id="btnScrCSV">‚¨á Full Results CSV</button>
        <button class="btn" id="btnScrJSON">‚¨á JSON Export</button>
        <button class="btn purple" id="btnScrTop10">üìä Show Top 10</button>
        <span class="pill" id="scrStatus">idle</span>
        <span class="small" id="scrProgress" style="color:#9ca3af"></span>
      </div>
      <div class="table-container" style="max-height:460px">
        <table class="table" id="scrTable">
          <thead><tr>
            <th>#</th><th>Receptor</th><th>SMILES</th><th>Score</th><th>Contacts</th><th>H-bonds</th><th>SaltBr</th><th>Clash</th><th>ŒîH (kcal/mol)</th><th>CRank</th>
          </tr></thead>
          <tbody id="scrTableBody"></tbody>
        </table>
      </div>
      <div id="viewerScr" style="height:420px;margin-top:12px"></div>
      <div class="small" style="text-align:center;color:#9ca3af;margin-top:4px">Click a row to visualize that docked pose.</div>
    </div>

    <div class="card">
      <h2>Enthalpy Distribution</h2>
      <div class="metric-grid" id="screenMetrics"></div>
      <div class="score" id="enthalpyBreakdown" style="margin-top:8px"></div>
      <div class="infobox small"><b>Interpretation:</b> more negative ŒîH ‚áí stronger binding (approximate; entropy not included).</div>
    </div>
  </div>
</section>

<section id="qaTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>üìã Run Registry & Session Management</h2>
      <div class="row" style="margin-top:6px">
        <button class="btn green" onclick="saveCurrentRun()">üíæ Save Current Run</button>
        <button class="btn" onclick="refreshRunRegistry()">üîÑ Refresh</button>
        <button class="btn" onclick="exportAllRuns()">‚¨á Export Registry</button>
        <button class="btn purple" onclick="importRunRegistry()">‚¨Ü Import Registry</button>
        <button class="btn red" onclick="clearRunRegistry()">üóëÔ∏è Clear</button>
      </div>
      <input type="file" id="importRegistryFile" accept=".json" style="display:none" />
      <div class="table-container" style="margin-top:10px">
        <table class="table">
          <thead><tr><th>Timestamp</th><th>Type</th><th>Description</th><th>Top Score</th><th>Signature</th><th>Actions</th></tr></thead>
          <tbody id="registryTableBody"></tbody>
        </table>
      </div>
    </div>
    <div class="card">
      <h2>‚úÖ Quality Assurance (Reproducibility)</h2>
      <div class="row" style="margin-top:6px">
        <label>Repeats</label><input type="number" id="qaRepeats" value="3" min="2" max="10" style="width:90px" />
        <label>Tolerance</label><input type="number" id="qaTolerance" value="0.01" step="0.01" style="width:90px" />
        <button class="btn primary" onclick="runQATest()">‚ñ∂Ô∏è Run QA Test</button>
      </div>
      <div class="score" id="qaResults" style="margin-top:10px;min-height:120px"></div>
      <div class="infobox small">Runs N repeats with same seed; passes if top scores within tolerance.</div>
    </div>
  </div>
</section>

<section id="analysisTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>üìä Analysis Tools</h2>
      <div class="tabs" style="margin-top:6px">
        <button class="tabbtn active" data-subtab="energyTab">Energy Decomposition</button>
        <button class="tabbtn" data-subtab="compareTab">Pose Comparison</button>
        <button class="tabbtn" data-subtab="residueTab">Residue Contacts</button>
      </div>
      <div id="energyTab" class="tabsec active">
        <h3>Energy Component Analysis</h3>
        <div id="energyComponents" class="metric-grid"></div>
        <h4>ŒîH Details</h4>
        <div class="score" id="enthalpyDetail"></div>
      </div>
      <div id="compareTab" class="tabsec">
        <h3>Compare Poses</h3>
        <div class="row">
          <label>Pose 1</label><select id="comparePose1"></select>
          <label>Pose 2</label><select id="comparePose2"></select>
          <button class="btn primary" onclick="comparePoses()">Compare</button>
        </div>
        <div class="grid two" style="margin-top:10px">
          <div><div id="viewerComp" style="height:420px"></div></div>
          <div><div class="score" id="comparisonResults" style="min-height:420px"></div></div>
        </div>
      </div>
      <div id="residueTab" class="tabsec">
        <h3>Residue-Level Contacts</h3>
        <div class="row">
          <label>Min Dist (√Ö)</label><input type="number" id="filterMinDist" value="0" step="0.5" style="width:90px" />
          <label>Max Dist (√Ö)</label><input type="number" id="filterMaxDist" value="6" step="0.5" style="width:90px" />
          <button class="btn" onclick="filterResidueContacts()">Filter</button>
          <button class="btn green" onclick="exportResidueData()">‚¨á Export</button>
        </div>
        <div class="table-container" style="margin-top:8px">
          <table class="table">
            <thead><tr><th>Residue A</th><th>Chain A</th><th>Residue B</th><th>Chain B</th><th>Distance (√Ö)</th><th>Type</th><th>Energy</th></tr></thead>
            <tbody id="residueTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</section>

<section id="omicsTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>üî¨ Virtual Omics Analysis of a Theoretical Eukaryotic Cell</h2>
      <div class="infobox">This is a theoretical analysis for educational purposes. It illustrates the types of data obtained from proteomics, lipidomics, and metabolomics, using the glycolysis pathway as a central example.</div>
      <div class="tabs" style="margin-top:6px">
        <button class="tabbtn active" data-subtab="proteomicsTab">Proteomics</button>
        <button class="tabbtn" data-subtab="lipidomicsTab">Lipidomics</button>
        <button class="tabbtn" data-subtab="metabolomicsTab">Metabolomics</button>
      </div>
      <div id="proteomicsTab" class="tabsec active">
        <h3>Virtual Proteomics: Glycolytic Enzymes</h3>
        <p class="small" style="color:var(--muted)">A virtual mass-spectrometry analysis of our model cell's cytoplasm has identified high-abundance proteins related to the glycolysis pathway. A selection is presented below.</p>
        <div class="table-container">
          <table class="table">
            <thead><tr><th>Protein (Enzyme)</th><th>Subcellular Location</th><th>Function in Glycolysis</th></tr></thead>
            <tbody>
              <tr><td>Hexokinase (HK)</td><td>Cytosol (often associated with mitochondria)</td><td>Phosphorylates glucose to glucose-6-phosphate, trapping it in the cell.</td></tr>
              <tr><td>Phosphoglucose Isomerase (PGI)</td><td>Cytosol</td><td>Converts glucose-6-phosphate to fructose-6-phosphate.</td></tr>
              <tr><td>Phosphofructokinase (PFK-1)</td><td>Cytosol</td><td>A key regulatory enzyme; phosphorylates fructose-6-phosphate to fructose-1,6-bisphosphate.</td></tr>
              <tr><td>Aldolase</td><td>Cytosol</td><td>Cleaves fructose-1,6-bisphosphate into two 3-carbon sugars.</td></tr>
              <tr><td>Glyceraldehyde-3-phosphate dehydrogenase (GAPDH)</td><td>Cytosol</td><td>Oxidizes glyceraldehyde-3-phosphate, producing NADH.</td></tr>
              <tr><td>Pyruvate Kinase (PK)</td><td>Cytosol</td><td>Transfers a phosphate group from PEP to ADP, forming ATP and pyruvate.</td></tr>
            </tbody>
          </table>
        </div>
      </div>
      <div id="lipidomicsTab" class="tabsec">
        <h3>Virtual Lipidomics: Cell Membrane Composition</h3>
        <p class="small" style="color:var(--muted)">Analysis of the cell's plasma membrane reveals a typical lipid profile dominated by phospholipids, cholesterol, and sphingolipids, crucial for membrane integrity, signaling, and transport.</p>
        <div class="score">
          <b>Major Lipid Classes Identified:</b>
          <ul>
            <li><b>Phosphatidylcholine (PC):</b> Most abundant phospholipid, provides structural integrity.</li>
            <li><b>Phosphatidylethanolamine (PE):</b> Regulates membrane curvature.</li>
            <li><b>Phosphatidylserine (PS):</b> Typically on the inner leaflet; involved in signaling apoptosis when flipped to the outer leaflet.</li>
            <li><b>Cholesterol:</b> Modulates membrane fluidity and organizes lipid rafts.</li>
            <li><b>Sphingomyelin (SM):</b> Enriched in lipid rafts, involved in signal transduction.</li>
          </ul>
        </div>
      </div>
      <div id="metabolomicsTab" class="tabsec">
        <h3>Virtual Metabolomics: Key Cellular Metabolites</h3>
        <p class="small" style="color:var(--muted)">Metabolite profiling shows high turnover of key small molecules. The levels of these metabolites provide a snapshot of the cell's energetic and biosynthetic state.</p>
        <div class="table-container">
          <table class="table">
            <thead><tr><th>Metabolite</th><th>Pathway</th><th>Significance</th></tr></thead>
            <tbody>
              <tr><td>Glucose-6-Phosphate</td><td>Glycolysis / Pentose Phosphate Pathway</td><td>Central hub; commits glucose to energy production or biosynthesis.</td></tr>
              <tr><td>Fructose-1,6-bisphosphate</td><td>Glycolysis</td><td>Product of the committed step of glycolysis; indicates high glycolytic flux.</td></tr>
              <tr><td>Pyruvate</td><td>Glycolysis (End Product)</td><td>Key branch point; can be converted to lactate, acetyl-CoA (for TCA cycle), or alanine.</td></tr>
              <tr><td>ATP / ADP Ratio</td><td>Energy Metabolism</td><td>High ratio indicates an energy-replete state; a primary regulator of metabolic pathways.</td></tr>
              <tr><td>NADH / NAD+ Ratio</td><td>Redox Metabolism</td><td>Reflects the cell's redox state; impacts the fate of pyruvate.</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</section>

<section id="nmrTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>üì° Theoretical NMR Prediction</h2>
      <div class="infobox small">Enter a SMILES string to get a theoretical analysis of what its NMR spectra might look like. This is an educational tool for interpretation, not a simulator.</div>
      <h3>SMILES Input</h3>
      <textarea id="nmrSmiles" placeholder="Enter SMILES string">CC(=O)Oc1ccccc1C(=O)O</textarea>
      <h3>Structure Preview</h3>
      <div id="nmrMoleculeImage"></div>
      <div class="row">
        <button class="btn primary" id="btnPredict1H">Predict ¬πH NMR</button>
        <button class="btn" id="btnPredict13C">Predict ¬π¬≥C NMR</button>
        <button class="btn" id="btnPredictCOSY">Predict COSY</button>
        <button class="btn" id="btnPredictNOESY">Predict NOESY</button>
      </div>
    </div>
    <div class="card">
      <h2>Prediction Output</h2>
      <div class="score" id="nmrPredictionOutput" style="min-height:300px">Prediction results will appear here.</div>
    </div>
  </div>
</section>

<section id="aboutTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>About</h2>
      <p>This educational platform demonstrates in-browser docking with parallel sampling, simplified scoring, and interactive visualization. All computations run locally; nothing is uploaded.</p>
      <h3>Important Disclaimers</h3>
      <div class="errorbox">
        <p><b>We provide no warranties and we disclaim any loss in any way.</b></p>
        <p>Scoring/embedding are simplified approximations; entropy, solvation, polarization, and induced fit are not fully modeled. Validate results independently with professional tools and experiments.</p>
      </div>
      <h3>Recommended Workflow</h3>
      <div class="infobox small">Use this tool for hypothesis generation ‚Üí export top poses ‚Üí refine with AutoDock/HADDOCK/Rosetta ‚Üí MD ‚Üí MM-PBSA/FEP ‚Üí experimental validation (SPR/ITC).</div>
      <h3>Credits</h3>
      <div class="small" style="color:#9ca3af">3Dmol.js ‚Ä¢ Pako ‚Ä¢ RCSB PDB</div>
    </div>
  </div>
</section>

<footer>
  <div class="wrap">
    <p>All computations execute locally in your browser. No data transmitted to servers.</p>
    <p class="small">¬© Educational Tool ‚Ä¢ No warranties ‚Ä¢ We disclaim any loss in any way ‚Ä¢ Validate results independently</p>
  </div>
</footer>

<script defer src="https://unpkg.com/3dmol@2.4.2/build/3Dmol-min.js"></script>
<script defer src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

<script>
// ========================= GLOBALS =========================
let viewer=null, viewerLig=null, viewerScr=null, viewerComp=null;
let inProgress=false, cancelled=false, workerPool=[];
let pdbAAllAtoms=[], pdbBAllAtoms=[];
let combos=[], currentComboIndex=-1; // each combo: {label, Aatoms, Batoms, cA, cB, topPoses:[], currentIndex:0}
let currentContacts=[], currentHB=[], currentSB=[], currentHydro=[];
let ligLastResult={}, screenCancel=false, screenResults=[], screenReceptors=[];
const REGISTRY_KEY='docking_registry_v2';

// vdW radii (√Ö)
const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
const hydrophobic=new Set(['ALA','VAL','LEU','ILE','PRO','PHE','MET','TRP','TYR','CYS']);
const residueCharges={'ASP':-1,'GLU':-1,'LYS':+1,'ARG':+1,'HIS':+0.1};

// Shorthands
const E=id=>document.getElementById(id);
const status=t=>E('statusPill').textContent=t;
const setProgress=f=>{E('prog').value=Math.max(0,Math.min(1,f||0));};

// ========================= INIT =========================
window.addEventListener('DOMContentLoaded', ()=>{
  ensureViewer('viewer'); ensureViewer('viewerLig'); ensureViewer('viewerScr'); ensureViewer('viewerComp');
  drawPlaceholder(viewer);
  setupMainTabs();
  setupSubTabs();
  bindEvents();
  bindOmicsAndNMREvents();
  loadSessionHistory();
  setTimeout(autoDemo, 200);
  // Initial call for NMR tab
  updateNMRImage(); 
});

// ========================= Tabs =========================
function setupMainTabs(){
  document.querySelectorAll('.tabbtn[data-tab]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      document.querySelectorAll('.tabbtn[data-tab]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      const target=btn.dataset.tab;
      document.querySelectorAll('[data-tab-panel]').forEach(sec=>{ sec.classList.toggle('active', sec.id===target); });
      setTimeout(()=>{try{ viewer?.resize(); viewerLig?.resize(); viewerScr?.resize(); viewerComp?.resize(); viewer?.render(); viewerLig?.render(); viewerScr?.render(); viewerComp?.render(); }catch(e){}},10);
    });
  });
}
function setupSubTabs(){
  document.querySelectorAll('.tabbtn[data-subtab]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const wrap=btn.closest('.card');
      wrap.querySelectorAll('.tabbtn[data-subtab]').forEach(b=>b.classList.remove('active'));
      wrap.querySelectorAll('.tabsec').forEach(s=>s.classList.remove('active'));
      btn.classList.add('active');
      const subTabId = btn.dataset.subtab;
      if (wrap.querySelector('#'+subTabId)) {
        wrap.querySelector('#'+subTabId).classList.add('active');
      }
      setTimeout(()=>{viewerComp?.resize(); viewerComp?.render();},10);
    });
  });
}

// ========================= Viewers =========================
function ensureViewer(id){
  const el=E(id); if(!el) return;
  const opt={backgroundColor:'#0a0f1a'};
  if(id==='viewer' && !viewer) viewer=$3Dmol.createViewer(el,opt);
  else if(id==='viewerLig' && !viewerLig) viewerLig=$3Dmol.createViewer(el,opt);
  else if(id==='viewerScr' && !viewerScr) viewerScr=$3Dmol.createViewer(el,opt);
  else if(id==='viewerComp' && !viewerComp) viewerComp=$3Dmol.createViewer(el,opt);
}
function drawPlaceholder(v){ if(!v) return; v.addSphere({center:{x:-8,y:0,z:0},radius:4,color:'#60a5fa',alpha:.6}); v.addSphere({center:{x:8,y:0,z:0},radius:4,color:'#f97316',alpha:.6}); v.zoomTo(); v.render(); }

// ========================= Events =========================
function bindEvents(){
  // global
  E('btnDemo').addEventListener('click', autoDemo);
  E('btnSaveSession').addEventListener('click', saveSession);
  E('btnLoadSession').addEventListener('click', loadSession);

  // docking
  E('dockBtn').addEventListener('click', runAntibodyDocking);
  E('cancelBtn').addEventListener('click', cancelDocking);
  E('resetBtn').addEventListener('click', resetAll);

  // complex selector
  E('comboSelect').addEventListener('change', ()=>{ setCurrentCombo(parseInt(E('comboSelect').value)||0); });
  E('btnPrevCombo').addEventListener('click', ()=>{ if(combos.length) setCurrentCombo((currentComboIndex-1+combos.length)%combos.length); });
  E('btnNextCombo').addEventListener('click', ()=>{ if(combos.length) setCurrentCombo((currentComboIndex+1)%combos.length); });
  E('btnClusters').addEventListener('click', clusterCurrentPoses);

  // exports
  E('btnAllPDB').addEventListener('click', downloadAllPoses);
  E('btnCurrentPDB').addEventListener('click', downloadCurrentPose);
  E('btnCSV').addEventListener('click', downloadCSV);
  E('btnJSON').addEventListener('click', downloadJSON);
  E('btnPNG').addEventListener('click', ()=>snapshotPNG(viewer));
  E('btnAllComplexesPDB').addEventListener('click', downloadAllComplexesPDB);

  // overlays
  ['toggleContacts','toggleHB','toggleSB','toggleHydro'].forEach(id=>E(id).addEventListener('change', refreshOverlays));

  // file inputs
  E('pdbAFile').addEventListener('change', e=>handleFileUpload('A', e.target.files[0]));
  E('pdbBFile').addEventListener('change', e=>handleFileUpload('B', e.target.files[0]));

  // ligand docking
  E('btnLigPDB').addEventListener('click', downloadLigandPDB);
  E('btnLigCSV').addEventListener('click', downloadLigandCSV);

  // screening
  E('btnStartScreen').addEventListener('click', startBatchScreening);
  E('btnStopScreen').addEventListener('click', ()=>{screenCancel=true;E('btnStopScreen').disabled=true;});
  E('btnScrCSV').addEventListener('click', downloadScreeningCSV);
  E('btnScrJSON').addEventListener('click', downloadScreeningJSON);
  E('btnScrTop10').addEventListener('click', showTop10Screening);
}

// ========================= Utils =========================
async function fileToText(file){
  const name=file.name.toLowerCase(); const buf=await file.arrayBuffer();
  if(name.endsWith('.gz')){const u8=new Uint8Array(buf); const out=pako.inflate(u8); return new TextDecoder().decode(out);} 
  return new TextDecoder().decode(buf);
}
async function handleFileUpload(which,file){ if(!file) return; try{ const text=await fileToText(file); E(which==='A'?'pdbAText':'pdbBText').value=text; parseOne(which); } catch(e){ alert('Error reading file: '+e.message); } }
async function fetchPDBFromRCSB(which){
  const pdbId=prompt(`Enter 4-character PDB ID for Protein ${which}:`); if(!pdbId) return; const id=pdbId.trim().toLowerCase(); if(id.length!==4){alert('PDB ID must be 4 chars');return;}
  try{ status(`fetching ${id}‚Ä¶`); const res=await fetch(`https://files.rcsb.org/download/${id}.pdb`); if(!res.ok) throw new Error('RCSB error'); const txt=await res.text(); E(which==='A'?'pdbAText':'pdbBText').value=txt; await parseOne(which); status('idle'); }catch(e){ alert('Fetch failed: '+e.message); status('error'); }
}
function centroid(pts){let x=0,y=0,z=0; for(const p of pts){x+=p.x;y+=p.y;z+=p.z;} const n=pts.length||1; return {x:x/n,y:y/n,z:z/n};}
function translate(points,t){return points.map(p=>({...p,x:p.x+t.x,y:p.y+t.y,z:p.z+t.z}));}
function formatPDB(atoms,chainShift=0){
  const lines=[]; let serial=1; 
  for(const a of atoms){ 
    const name=(a.name||'CA').padStart(4,' ');
    const resn=(a.resn||'RES').padStart(3,' ');
    const chain=String.fromCharCode((a.chain||'A').charCodeAt(0)+chainShift);
    const resi=String(a.resi||1).padStart(4,' ');
    const x=(a.x??0).toFixed(3).padStart(8,' ');
    const y=(a.y??0).toFixed(3).padStart(8,' ');
    const z=(a.z??0).toFixed(3).padStart(8,' ');
    const elem=(a.elem||'C').toString().padStart(2,' ');
    lines.push(`ATOM  ${String(serial).padStart(5,' ')} ${name} ${resn} ${chain}${resi}    ${x}${y}${z}  1.00  0.00           ${elem}`);
    serial++;
  }
  lines.push('TER');
  return lines.join('\n');
}
function downloadBlob(text, filename){ const url=URL.createObjectURL(new Blob([text],{type:'text/plain'})); const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000); }
function snapshotPNG(v){ try{ v.render(); v.pngURI((uri)=>{ const a=document.createElement('a'); a.href=uri; a.download='viewer.png'; a.click(); }); }catch(e){ alert('PNG failed: '+e.message);} }

// ========================= PDB parsing / chains =========================
function parsePDB(text){
  const atoms=[]; const lines=text.split(/\r?\n/);
  for(const line of lines){ if(!line.startsWith('ATOM') && !line.startsWith('HETATM')) continue; const atom={ name:line.substring(12,16).trim(), resn:line.substring(17,20).trim(), chain:line.substring(21,22).trim()||'A', resi:parseInt(line.substring(22,26)), x:parseFloat(line.substring(30,38)), y:parseFloat(line.substring(38,46)), z:parseFloat(line.substring(46,54)), elem: (line.length>=78? (line.substring(76,78).trim()||line.substring(12,16).trim()[0]) : line.substring(12,16).trim()[0]).toUpperCase() }; atoms.push(atom); }
  return atoms;
}
async function parseOne(which){
  const t = E(which==='A'?'pdbAText':'pdbBText').value.trim(); if(!t){ alert('Paste PDB or upload file first.'); return; }
  const atoms=parsePDB(t); if(!atoms.length){ alert('No atoms parsed ‚Äî check PDB.'); return; }
  if(which==='A'){ pdbAAllAtoms=atoms; populateChainChips('A',atoms); E('badgeA').textContent=`${atoms.length} atoms`; }
  else{ pdbBAllAtoms=atoms; populateChainChips('B',atoms); E('badgeB').textContent=`${atoms.length} atoms`; }
}
function populateChainChips(which, atoms){
  const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.innerHTML=''; const chains=[...new Set(atoms.map(a=>a.chain))]; chains.forEach(c=>{ const id=`${which}_ch_${c}`; const lbl=document.createElement('label'); lbl.className='chip'; lbl.innerHTML=`<input type="checkbox" id="${id}" data-which="${which}" data-chain="${c}" checked> ${c}`; box.appendChild(lbl); });
  const warn=which==='A'?E('chainWarnA'):E('chainWarnB'); warn.className='successbox small'; warn.textContent=`‚úì Parsed ${atoms.length} atoms ‚Ä¢ Chains: ${chains.join(', ')||'‚Äî'}`;
}
function selectedChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); const selected=[...box.querySelectorAll('input[type=checkbox]')].filter(cb=>cb.checked).map(cb=>cb.dataset.chain); return new Set(selected); }
function selectAllChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=true); }
function invertChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=!cb.checked); }
function filterChains(atoms, keep){ if(!keep || keep.size===0) return atoms; return atoms.filter(a=>keep.has(a.chain)); }
function selectAtomSet(atoms, mode){ const bb=new Set(['N','CA','C','O']); return atoms.filter(a=>{ if(mode==='CA') return a.name==='CA'; if(mode==='BB') return bb.has(a.name); return a.elem!=='H'; }); }

// ========================= Worker (sampling/scoring) =========================
function makeDockWorker(){
  const code=`
    const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
    function rand(seed){let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);}    
    function randomQuat(r){const u1=r(),u2=r(),u3=r(); const a=Math.sqrt(1-u1),b=Math.sqrt(u1),t1=2*Math.PI*u2,t2=2*Math.PI*u3; return [a*Math.sin(t1),a*Math.cos(t1),b*Math.sin(t2),b*Math.cos(t2)];}
    function rotate(points,q){const[qx,qy,qz,qw]=q; return points.map(p=>{const vx=p.x,vy=p.y,vz=p.z; const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz; const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy),oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz),oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx); return {x:ox,y:oy,z:oz,elem:p.elem};});}
    function translate(points,t){return points.map(p=>({x:p.x+t.x,y:p.y+t.y,z:p.z+t.z,elem:p.elem}));}
    function grid(coords,c){const m=new Map(),k=(ix,iy,iz)=>ix+"|"+iy+"|"+iz; for(let i=0;i<coords.length;i++){const x=coords[i].x,y=coords[i].y,z=coords[i].z,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),kk=k(ix,iy,iz); if(!m.has(kk)) m.set(kk,[]); m.get(kk).push(i);} return {c,m};}
    function neigh(g,x,y,z){const c=g.c,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),out=[]; for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++)for(let dz=-1;dz<=1;dz++){const kk=(ix+dx)+"|"+(iy+dy)+"|"+(iz+dz); if(g.m.has(kk)) out.push(...g.m.get(kk));} return out;}
    function scorePose(A,B,contact,clashFact,wC,wX,soft){const G=grid(A,contact); let contacts=0, clash=0; for(let i=0;i<B.length;i++){const x=B[i].x,y=B[i].y,z=B[i].z, eB=(B[i].elem||'C').toUpperCase(), neighs=neigh(G,x,y,z); for(const j of neighs){const a=A[j],dx=x-a.x,dy=y-a.y,dz=z-a.z, d=Math.hypot(dx,dy,dz), eA=(a.elem||'C').toUpperCase(); const rs=(vdw[eA]||1.7)+(vdw[eB]||1.7), clashCut=clashFact*rs; if(d<=clashCut){const ov=(clashCut-d+1e-6)/clashCut; clash+=wX*ov*(1/(1+soft*ov));} else if(d<=contact){contacts+=1;} } } return {score: wC*contacts - clash, contacts, clash}; }
    self.onmessage=(ev)=>{ const {Apts,Bpts,params,start,end}=ev.data; const rng=rand(params.seed+start*1337); const best=[]; const total=end-start; for(let k=0;k<total;k++){ const q=randomQuat(rng), t={x:(rng()*2-1)*params.maxTrans, y:(rng()*2-1)*params.maxTrans, z:(rng()*2-1)*params.maxTrans}; const B=translate(rotate(Bpts,q),t), s=scorePose(Apts,B,params.contactCut,params.clashFactor,params.wContact,params.wClash,params.soft); best.push({score:s.score,contacts:s.contacts,clash:s.clash,q:[...q],t}); if((k&1023)===0) self.postMessage({type:'progress',count:k}); } best.sort((a,b)=>b.score-a.score); self.postMessage({type:'done',poses:best.slice(0,Math.min(200,total))}); };
  `;
  return new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
}
function angleBetweenQuats(q1,q2){const dot=q1[0]*q2[0]+q1[1]*q2[1]+q1[2]*q2[2]+q1[3]*q2[3]; return 2*Math.acos(Math.min(1,Math.abs(dot)))*180/Math.PI;}
function diverseTop(sorted,deg,transA,limit){
  const out=[]; const max=Math.max(1,limit||parseInt(E('topN').value)||10);
  for(const p of sorted){ let dupe=false; for(const s of out){ const a=angleBetweenQuats(p.q,s.q); const t=Math.hypot(p.t.x-s.t.x,p.t.y-s.t.y,p.t.z-s.t.z); if(a<=deg && t<=transA){dupe=true;break;} } if(!dupe){out.push(p); if(out.length>=max) break;} }
  return out;
}

// ========================= Docking driver (with chain pairing & multi-complex) =========================
function enumerateCombos(){
  const mode=E('pairMode').value; const aSel=selectedChains('A'); const bSel=selectedChains('B');
  const Amap=groupByChain(pdbAAllAtoms), Bmap=groupByChain(pdbBAllAtoms);
  const Akeys=[...Amap.keys()].filter(k=>aSel.has(k)); const Bkeys=[...Bmap.keys()].filter(k=>bSel.has(k));
  const combosOut=[];
  if(mode==='AGG'){
    const A=filterChains(pdbAAllAtoms,aSel), B=filterChains(pdbBAllAtoms,bSel);
    combosOut.push({label:`A{${Akeys.join('')}} vs B{${Bkeys.join('')}}`, Aatoms:A, Batoms:B});
  } else if(mode==='A_EACH_B'){
    const A=filterChains(pdbAAllAtoms,aSel);
    for(const b of Bkeys){ combosOut.push({label:`A{${Akeys.join('')}} vs B{${b}}`, Aatoms:A, Batoms:Bmap.get(b)}); }
  } else if(mode==='CROSS'){
    for(const a of Akeys){ for(const b of Bkeys){ combosOut.push({label:`A{${a}} vs B{${b}}`, Aatoms:Amap.get(a), Batoms:Bmap.get(b)}); } }
  }
  return combosOut;
}
function groupByChain(atoms){ const m=new Map(); for(const a of atoms){ if(!m.has(a.chain)) m.set(a.chain,[]); m.get(a.chain).push(a); } return m; }

async function runAntibodyDocking(){
  if(inProgress) return; cancelled=false; inProgress=true; status('preparing'); setProgress(0);
  E('dockBtn').disabled=true; E('cancelBtn').disabled=false; E('dockBtn').textContent='Running‚Ä¶';
  try{
    const textA=await ensureInputText('A'), textB=await ensureInputText('B');
    pdbAAllAtoms=parsePDB(textA); pdbBAllAtoms=parsePDB(textB);
    populateChainChips('A',pdbAAllAtoms); populateChainChips('B',pdbBAllAtoms);

    const params=collectDockingParams();
    const comboDefs=enumerateCombos();
    if(!comboDefs.length) throw new Error('No chain combinations produced. Select at least one chain on each protein.');

    combos=comboDefs.map(c=>({label:c.label, Aatoms:c.Aatoms, Batoms:c.Batoms, cA:null, cB:null, topPoses:[], currentIndex:0}));
    updateComboSelect();

    // Process combos sequentially (UI stays responsive)
    let completed=0; const totalCombos=combos.length; let overallProgress=0; const totalSamples=(params.samples||10000)*totalCombos;
    for(let i=0;i<combos.length;i++){
      if(cancelled) break; status(`combo ${i+1}/${totalCombos} sampling‚Ä¶`);
      await dockSingleCombo(i, params, (done)=>{ // progress callback (approx)
        overallProgress = (completed*params.samples + done) / totalSamples; setProgress(overallProgress);
      });
      completed++;
      fillComboSummaryRow(i);
    }

    setCurrentCombo(0);
    finishDocking(); status(cancelled?'cancelled':'complete'); setProgress(1); inProgress=false;
  }catch(e){ alert(e.message||'Docking error'); finishDocking(); status('error'); inProgress=false; }
}
function cancelDocking(){ cancelled=true; workerPool.forEach(w=>{try{w.terminate();}catch(e){}}); workerPool=[]; setProgress(0); status('cancelled'); finishDocking(); inProgress=false; }
function finishDocking(){ E('dockBtn').disabled=false; E('cancelBtn').disabled=true; E('dockBtn').textContent='‚ñ∂Ô∏è Run Docking'; }
function collectDockingParams(){
  return {samples:parseInt(E('samples').value),maxTrans:parseFloat(E('maxTrans').value),contactCut:parseFloat(E('contactCut').value), clashFactor:parseFloat(E('clashFactor').value),wContact:parseFloat(E('wContact').value),wClash:parseFloat(E('wClash').value),soft:parseFloat(E('soft').value), topN:Math.max(1,parseInt(E('topN').value)),seed:parseInt(E('seed').value)||42,atomMode:E('atomMode').value,rescoreMode:E('rescoreMode').value};
}
async function ensureInputText(which){ const file=E(which==='A'?'pdbAFile':'pdbBFile').files[0]; let t=E(which==='A'?'pdbAText':'pdbBText').value.trim(); if(!t && file){ t=await fileToText(file); } if(!t) throw new Error(`Provide PDB for Protein ${which} (file or text).`); return t; }

async function dockSingleCombo(idx, params, onProgress){
  const combo=combos[idx];
  const aSel=combo.Aatoms, bSel=combo.Batoms;
  const ptsA0=selectAtomSet(aSel,params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
  const ptsB0=selectAtomSet(bSel,params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
  if(!ptsA0.length||!ptsB0.length) throw new Error('Atom selection empty. Try Backbone or Heavy mode.');
  const cA=centroid(ptsA0), cB=centroid(ptsB0);
  const ptsA=translate(ptsA0,{x:-cA.x,y:-cA.y,z:-cA.z});
  const ptsB=translate(ptsB0,{x:-cB.x,y:-cB.y,z:-cB.z});
  combo.cA=cA; combo.cB=cB;

  const cores=Math.max(1,(navigator.hardwareConcurrency||4)-1), pool=Math.min(cores,8);
  const total=params.samples, base=Math.floor(total/pool), extra=total%pool;
  let all=[], done=0; workerPool=[];
  const progressUnit=1024; // worker posts every 1024
  await new Promise((resolve)=>{
    for(let i=0;i<pool;i++){
      const start=i*base+Math.min(i,extra), end=start+base+(i<extra?1:0);
      const w=makeDockWorker(); workerPool.push(w);
      w.onmessage=(m)=>{
        if(cancelled) return;
        const msg=m.data;
        if(msg.type==='progress'){ done+=progressUnit; onProgress?.(Math.min(done,total)); }
        if(msg.type==='done'){ all.push(msg.poses); w.terminate(); if(all.length===pool){ resolve(); } }
      };
      w.onerror=(e)=>{ console.error('worker error',e); w.terminate(); };
      w.postMessage({Apts:ptsA,Bpts:ptsB,params,start,end});
    }
  });
  workerPool=[];
  const poses=all.flat(); poses.sort((a,b)=>b.score-a.score);
  const diverse=diverseTop(poses, parseFloat(E('dupAngle').value)||12, parseFloat(E('dupTrans').value)||2, params.topN*3);

  // heavy sets for viz/rescore
  const Aheavy=translate(selectAtomSet(aSel,'HEAVY').map(a=>({...a})), {x:-cA.x,y:-cA.y,z:-cA.z});
  const Bheavy0=translate(selectAtomSet(bSel,'HEAVY').map(a=>({...a})), {x:-cB.x,y:-cB.y,z:-cB.z});

  let top=diverse;
  if(params.rescoreMode!=='NONE'){ top=await heavyAtomRescore(Aheavy,Bheavy0,params,diverse, params.rescoreMode==='HEAVY_REFINE'); }
  combo.topPoses=top; combo.Aviz=Aheavy; combo.B0=Bheavy0;
}

function heavyAtomRescore(A,B0,params,coarse,refine=false){
  const {contactCut,clashFactor,wContact,wClash,soft}=params;
  function score(A,B){ let contacts=0, clash=0; for(const b of B) for(const a of A){ const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z); const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7), cut=clashFactor*rs; if(d<=cut){ const ov=(cut-d+1e-6)/cut; clash+=wClash*ov*(1/(1+soft*ov)); } else if(d<=contactCut){ contacts++; } } return {score:wContact*contacts-clash,contacts,clash}; }
  function apply(points,q,t){ const [qx,qy,qz,qw]=q; return points.map(p=>{ const vx=p.x,vy=p.y,vz=p.z; const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz; const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy),oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz),oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx); return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name}; }); }
  function jiggle(p){ const r=()=> (Math.random()*2-1)*0.5; const dq=[p.q[0]+r()*0.01,p.q[1]+r()*0.01,p.q[2]+r()*0.01,p.q[3]+r()*0.01]; const n=Math.hypot(...dq); for(let i=0;i<4;i++) dq[i]/=n; const dt={x:p.t.x+r(),y:p.t.y+r(),z:p.t.z+r()}; return {q:dq,t:dt}; }
  const rescored=[]; for(const p of coarse){ let best={...p}; let TB=apply(B0,p.q,p.t); let s=score(A,TB); best.score=s.score; best.contacts=s.contacts; best.clash=s.clash; if(refine){ for(let it=0;it<40;it++){ const pp=jiggle(best); const TB2=apply(B0,pp.q,pp.t); const s2=score(A,TB2); if(s2.score>best.score){ best.q=pp.q; best.t=pp.t; best.score=s2.score; best.contacts=s2.contacts; best.clash=s2.clash; } } } rescored.push(best); }
  rescored.sort((a,b)=>b.score-a.score); return rescored.slice(0,parseInt(E('topN').value));
}
function applyTransform(points,q,t){ const [qx,qy,qz,qw]=q; return points.map(p=>{ const vx=p.x,vy=p.y,vz=p.z; const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz; const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy),oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz),oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx); return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name}; }); }

// ========================= Visualization / overlays =========================
function updateComboSelect(){ const sel=E('comboSelect'); sel.innerHTML=''; combos.forEach((c,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=`${i+1}. ${c.label}`; sel.appendChild(o); }); E('comboSummaryBody').innerHTML=''; }
function setCurrentCombo(i){ if(i<0||i>=combos.length) return; currentComboIndex=i; E('comboSelect').value=String(i); buildPoseButtons(combos[i].topPoses); if(combos[i].topPoses.length) showPose(0); updateMetricsDisplay(); }
function buildPoseButtons(poses){ const c=E('poseControls'); c.innerHTML=''; poses.forEach((p,i)=>{ const b=document.createElement('button'); b.className='btn'; b.textContent=`Pose ${i+1} (S=${p.score.toFixed(1)}, C=${p.contacts|0}, X=${p.clash.toFixed(1)})`; b.addEventListener('click',()=>showPose(i)); c.appendChild(b); const d=document.createElement('button'); d.className='btn green'; d.style.marginLeft='6px'; d.textContent='‚¨á PDB'; d.addEventListener('click',()=>downloadSinglePose(i)); c.appendChild(d); }); updateComparisonDropdowns(poses); }
function showPose(i){ const combo=combos[currentComboIndex]; if(!combo) return; if(i<0||i>=combo.topPoses.length) return; combo.currentIndex=i; const p=combo.topPoses[i]; const TB=applyTransform(combo.B0,p.q,p.t); viewer.clear(); viewer.addModel(formatPDB(combo.Aviz),'pdb'); viewer.addModel(formatPDB(TB,1),'pdb'); const rA=new Set(combo.Aviz.map(a=>a.resi)).size, rB=new Set(TB.map(a=>a.resi)).size, cartoon=rA>=8 && rB>=8; if(cartoon){ viewer.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewer.setStyle({model:1},{cartoon:{color:'#f97316'}}); } else{ viewer.setStyle({model:0},{stick:{radius:.25}}); viewer.setStyle({model:1},{stick:{radius:.25,color:'#f97316'}}); } viewer.zoomTo(); const cutoff=parseFloat(E('contactCut').value); const metrics=computeInterfaceMetrics(combo.Aviz,TB,cutoff); currentContacts=metrics.contactsPairs; currentHB=metrics.hbPairs; currentSB=metrics.sbPairs; currentHydro=metrics.hydroPairs||[]; refreshOverlays(); const kElec=parseFloat(E('kElec').value)||0.5, eCut=parseFloat(E('elecCut').value)||12; const elec=coulombEnergy(combo.Aviz,TB,kElec,eCut); const BSA=metrics.contacts*10.0; const dH=calculateEnthalpy(metrics,elec); E('scoreBox').innerHTML=`<b>${combo.label}</b> ‚Ä¢ <b>Pose ${i+1}</b><br> Score: ${p.score.toFixed(2)} | Contacts: ${metrics.contacts} | Clash: ${metrics.clash.toFixed(2)} | H-bonds: ${metrics.hb} | SaltBr: ${metrics.sb} | Hydrophobics: ${metrics.hydrophobics}<br> BSA ‚âà ${BSA.toFixed(0)} √Ö¬≤ | Electrostatics: ${elec.toFixed(2)} kcal/mol | <b>ŒîH ‚âà ${dH.toFixed(2)} kcal/mol</b>`; updateMetricsDisplay(); updateEnergyDecomposition(metrics,elec,dH); viewer.render(); }
function refreshOverlays(){ if(!combos.length) return; viewer.removeAllShapes(); if(E('toggleContacts').checked) drawLines(currentContacts,'#60a5fa'); if(E('toggleHB').checked) drawLines(currentHB,'#34d399'); if(E('toggleSB').checked) drawLines(currentSB,'#f87171'); if(E('toggleHydro').checked) drawLines(currentHydro,'#fbbf24'); viewer.render(); }
function drawLines(pairs,color){ pairs.slice(0,400).forEach(p=>{ viewer.addLine({start:{x:p.x1,y:p.y1,z:p.z1},end:{x:p.x2,y:p.y2,z:p.z2},dashed:true,dashLength:.5,color,linewidth:2}); }); }
function computeInterfaceMetrics(A,B,cut){ let contacts=0,clash=0,hb=0,sb=0,hydro=0; const contactsPairs=[],hbPairs=[],sbPairs=[],hydroPairs=[]; const clashFactor=parseFloat(E('clashFactor').value)||0.85; const wClash=parseFloat(E('wClash').value)||6.0; const soft=parseFloat(E('soft').value)||0.5; for(const b of B) for(const a of A){ const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z); const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7), cutCl=clashFactor*rs; if(d<=cutCl){ const ov=(cutCl-d+1e-6)/cutCl; clash+=wClash*ov*(1/(1+soft*ov)); } if(d<=cut){ contacts++; contactsPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); } const aN=a.name?.startsWith('N'), aO=a.name?.startsWith('O'), bN=b.name?.startsWith('N'), bO=b.name?.startsWith('O'); if(((aN&&bO)||(aO&&bN)) && d<=3.5){ hb++; hbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); } const isAcidic=at=> (at.resn==='ASP'&&at.name.startsWith('OD'))||(at.resn==='GLU'&&at.name.startsWith('OE')); const isBasic =at=> (at.resn==='LYS'&&at.name==='NZ')||(at.resn==='ARG'&&(at.name==='NH1'||at.name==='NH2'||at.name==='NE'))||(at.resn==='HIS'&&(at.name==='ND1'||at.name==='NE2')); if(((isAcidic(a)&&isBasic(b))||(isAcidic(b)&&isBasic(a))) && d<=4.0){ sb++; sbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); } if(hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)&&(a.elem==='C'||b.elem==='C')&&d<=4.5){ hydro++; hydroPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); } } return {contacts,clash,hb,sb,hydrophobics:hydro,contactsPairs,hbPairs,sbPairs,hydroPairs}; }
function coulombEnergy(A,B,k=0.5,cut=12){ const AA=residueChargesFor(A), BB=residueChargesFor(B); let E=0, cut2=cut*cut; for(const a of AA) for(const b of BB){ const dx=a.x-b.x,dy=a.y-b.y,dz=a.z-b.z, d2=dx*dx+dy*dy+dz*dz; if(d2>cut2) continue; E+=k*(a.q*b.q)/(Math.sqrt(d2)+1e-3); } return E; }
function residueChargesFor(atoms){ const groups=new Map(); for(const a of atoms){ const key=a.chain+':'+a.resi; if(!groups.has(key)) groups.set(key,[]); groups.get(key).push(a); } const out=[]; for(const [key,arr] of groups.entries()){ const res=arr[0].resn||'UNK', q=residueCharges[res]||0; if(!q) continue; const ca=arr.find(x=>x.name==='CA'); let x,y,z; if(ca){x=ca.x;y=ca.y;z=ca.z;} else{ let sx=0,sy=0,sz=0; for(const a of arr){sx+=a.x; sy+=a.y; sz+=a.z;} x=sx/arr.length; y=sy/arr.length; z=sz/arr.length; } out.push({x,y,z,q,resn:res}); } return out; }
function calculateEnthalpy(m,elec){ const w={contact:-0.5,hbond:-2.5,salt:-4.0,hydro:-1.0,clash:+0.3,desolv:+0.2}; return w.contact*m.contacts + w.hbond*m.hb + w.salt*m.sb + w.hydro*m.hydrophobics + w.clash*m.clash + elec + w.desolv*m.contacts; }

// ========================= Clustering & Summary =========================
function clusterCurrentPoses(){ const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length) return; const K=Math.max(1,parseInt(E('clustersK').value)||6); const poses=combo.topPoses; const centers=poses.slice(0,Math.min(K,poses.length)); const assign=new Array(poses.length).fill(0);
  // distance = quaternion angle + scaled translation
  function d(p,q){ const a=angleBetweenQuats(p.q,q.q), t=Math.hypot(p.t.x-q.t.x,p.t.y-q.t.y,p.t.z-q.t.z); return a+5*t; }
  for(let iter=0;iter<6;iter++){
    // assign
    for(let i=0;i<poses.length;i++){ let best=0,bestd=Infinity; for(let c=0;c<centers.length;c++){ const dd=d(poses[i],centers[c]); if(dd<bestd){bestd=dd;best=c;} } assign[i]=best; }
    // update
    for(let c=0;c<centers.length;c++){ const members=poses.filter((_,i)=>assign[i]===c); if(members.length){ members.sort((a,b)=>b.score-a.score); centers[c]=members[0]; } }
  }
  // reorder by clusters then score
  const ordered=poses.map((p,i)=>({p,i,cl:assign[i]})).sort((a,b)=> a.cl-b.cl || b.p.score-a.p.score).map(x=>x.p);
  combo.topPoses=ordered; buildPoseButtons(combo.topPoses); showPose(0);
}
function fillComboSummaryRow(i){ const combo=combos[i]; const top=combo.topPoses[0]; if(!top) return; const TB=applyTransform(combo.B0,top.q,top.t); const metrics=computeInterfaceMetrics(combo.Aviz,TB,parseFloat(E('contactCut').value)); const elec=coulombEnergy(combo.Aviz,TB,parseFloat(E('kElec').value)||0.5,parseFloat(E('elecCut').value)||12); const dH=calculateEnthalpy(metrics,elec); const tr=document.createElement('tr'); tr.innerHTML=`<td>${combo.label}</td><td>${top.score.toFixed(2)}</td><td>${metrics.contacts}</td><td>${dH.toFixed(2)}</td>`; E('comboSummaryBody').appendChild(tr); }

// ========================= Metrics / Analysis UI =========================
function updateMetricsDisplay(){ const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length){ E('metricsDisplay').innerHTML='<div class="small" style="color:#9ca3af">Run docking to see metrics.</div>'; return; } const p=combo.topPoses[combo.currentIndex]; E('metricsDisplay').innerHTML=`<div class="metric-card"><div class="metric-value">${p.score.toFixed(2)}</div><div class="metric-label">Score</div></div><div class="metric-card"><div class="metric-value">${currentContacts.length}</div><div class="metric-label">Contacts</div></div><div class="metric-card"><div class="metric-value">${currentHB.length}</div><div class="metric-label">H-bonds</div></div><div class="metric-card"><div class="metric-value">${currentSB.length}</div><div class="metric-label">Salt Bridges</div></div>`; }
function updateEnergyDecomposition(m,elec,dH){ const box=E('energyComponents'); const parts=[["Contacts","+"+(m.contacts),-0.5*m.contacts],["H-bonds","+"+(m.hb),-2.5*m.hb],["SaltBr","+"+(m.sb),-4.0*m.sb],["Hydrophobic","+"+(m.hydrophobics),-1.0*m.hydrophobics],["Clash","+"+m.clash,(+0.3*m.clash)],["Electrostatics","",elec],["Desolv","+"+m.contacts,+0.2*m.contacts]]; box.innerHTML=parts.map(([k,c,v])=>`<div class="metric-card"><div class="metric-value">${v.toFixed(2)}</div><div class="metric-label">${k} ${c}</div></div>`).join(''); E('enthalpyDetail').textContent = `ŒîH ‚âà ${dH.toFixed(2)} kcal/mol (contacts, H-bonds, salt bridges, hydrophobic, clash, electrostatics, desolvation).`; }
function updateComparisonDropdowns(poses){ const s1=E('comparePose1'), s2=E('comparePose2'); s1.innerHTML=''; s2.innerHTML=''; poses.forEach((p,i)=>{ const o1=document.createElement('option'); o1.value=i; o1.textContent=`Pose ${i+1}`; s1.appendChild(o1); const o2=document.createElement('option'); o2.value=i; o2.textContent=`Pose ${i+1}`; s2.appendChild(o2); }); if(poses.length>=2){ s1.value=0; s2.value=1; } }
function comparePoses(){ const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length) return; const i1=parseInt(E('comparePose1').value), i2=parseInt(E('comparePose2').value); if(!(combo.topPoses[i1]&&combo.topPoses[i2])) return; const TB1=applyTransform(combo.B0,combo.topPoses[i1].q,combo.topPoses[i1].t); viewerComp.clear(); viewerComp.addModel(formatPDB(combo.Aviz),'pdb'); viewerComp.addModel(formatPDB(TB1,1),'pdb'); viewerComp.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewerComp.setStyle({model:1},{cartoon:{color:'#f97316'}}); viewerComp.zoomTo(); viewerComp.render(); const a=angleBetweenQuats(combo.topPoses[i1].q, combo.topPoses[i2].q), t=Math.hypot(combo.topPoses[i1].t.x-combo.topPoses[i2].t.x,combo.topPoses[i1].t.y-combo.topPoses[i2].t.y,combo.topPoses[i1].t.z-combo.topPoses[i2].t.z); E('comparisonResults').textContent = `Pose1 score=${combo.topPoses[i1].score.toFixed(2)}, Pose2 score=${combo.topPoses[i2].score.toFixed(2)}\nŒîangle ‚âà ${a.toFixed(1)}¬∞, Œîtranslation ‚âà ${t.toFixed(2)} √Ö`; }
function filterResidueContacts(){ const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length) return; const min=parseFloat(E('filterMinDist').value)||0, max=parseFloat(E('filterMaxDist').value)||6; const p=combo.topPoses[combo.currentIndex]; const TB=applyTransform(combo.B0,p.q,p.t); const rows=[]; for(const b of TB) for(const a of combo.Aviz){ const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z); if(d<min||d>max) continue; const type=(a.name?.startsWith('N')&&b.name?.startsWith('O')||a.name?.startsWith('O')&&b.name?.startsWith('N'))&&d<=3.5?'H-bond': (hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)?'Hydrophobic': (d<=4?'Contact':'Proximal')); const e=type==='H-bond'?-2.5:type==='Hydrophobic'?-1.0:type==='Contact'?-0.5:0; rows.push(`<tr><td>${a.resn}${a.resi}</td><td>${a.chain}</td><td>${b.resn||'-'}${b.resi||'-'}</td><td>${b.chain||'-'}</td><td>${d.toFixed(2)}</td><td>${type}</td><td>${e.toFixed(2)}</td></tr>`); } E('residueTableBody').innerHTML=rows.slice(0,1000).join(''); }
function exportResidueData(){ const table=E('residueTableBody').innerText||''; if(!table){alert('No data');return;} downloadBlob(table,'residue_contacts.txt'); }

// ========================= Exports =========================
function downloadAllPoses(){ const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length){alert('No poses.');return;} const lines=[]; combo.topPoses.forEach((p,i)=>{lines.push(`MODEL     ${i+1}  ${combo.label}`); lines.push(formatPDB(combo.Aviz)); lines.push(formatPDB(applyTransform(combo.B0,p.q,p.t),1)); lines.push('ENDMDL');}); lines.push('END'); downloadBlob(lines.join('\n'),'all_poses_'+safe(combo.label)+'.pdb'); }
function safe(s){return s.replace(/[^a-z0-9]+/gi,'_');}
function downloadSinglePose(i){ const combo=combos[currentComboIndex]; if(!combo) return; const p=combo.topPoses[i]; const TB=applyTransform(combo.B0,p.q,p.t); const pdb=formatPDB(combo.Aviz)+'\n'+formatPDB(TB,1); downloadBlob(pdb,`pose_${i+1}_`+safe(combo.label)+`.pdb`); }
function downloadCurrentPose(){ const combo=combos[currentComboIndex]; if(!combo){alert('No complex selected.');return;} downloadSinglePose(combo.currentIndex||0); }
function downloadCSV(){ if(!combos.length){alert('No data');return;} const rows=['complex,rank,score,contacts,clash,qx,qy,qz,qw,tx,ty,tz']; combos.forEach((combo)=>{ combo.topPoses.forEach((p,i)=>rows.push([`"${combo.label}"`,i+1,p.score.toFixed(4),p.contacts,p.clash.toFixed(4),p.q[0].toFixed(6),p.q[1].toFixed(6),p.q[2].toFixed(6),p.q[3].toFixed(6),p.t.x.toFixed(3),p.t.y.toFixed(3),p.t.z.toFixed(3)].join(','))); }); downloadBlob(rows.join('\n'),'poses_summary_all_complexes.csv'); }
function downloadJSON(){ if(!combos.length){alert('No data');return;} const out={params:collectDockingParams(), complexes:combos.map(c=>({label:c.label, topPoses:c.topPoses}))}; downloadBlob(JSON.stringify(out,null,2),'poses_all_complexes.json'); }
function downloadAllComplexesPDB(){ if(!combos.length){alert('No complexes');return;} const lines=[]; let model=1; combos.forEach((combo)=>{ combo.topPoses.forEach((p,i)=>{ lines.push(`MODEL     ${model++}  ${combo.label}  pose ${i+1}`); lines.push(formatPDB(combo.Aviz)); lines.push(formatPDB(applyTransform(combo.B0,p.q,p.t),1)); lines.push('ENDMDL'); }); }); lines.push('END'); downloadBlob(lines.join('\n'),'all_complexes_all_poses.pdb'); }

// ========================= Ligand docking =========================
function loadLigandDemoReceptor(){ E('ligReceptorPDB').value=`ATOM      1  CA  ALA A   1      -8.000   0.000   0.000  1.00  0.00           C\nATOM      2  CA  ALA A   2      -6.600   1.200   0.200  1.00  0.00           C\nATOM      3  CA  ALA A   3      -5.200   0.100   1.200  1.00  0.00           C\nATOM      4  CA  ALA A   4      -3.800   1.400   1.400  1.00  0.00           C\nATOM      5  CA  ALA A   5      -2.400   0.500   2.200  1.00  0.00           C\nEND`; }
function parseReceptorForLigand(){ const t=E('ligReceptorPDB').value.trim(); if(!t){alert('Paste receptor PDB first'); return;} const atoms=parsePDB(t); viewerLig.clear(); viewerLig.addModel(formatPDB(atoms),'pdb'); viewerLig.setStyle({},{cartoon:{color:'#60a5fa'}}); viewerLig.zoomTo(); viewerLig.render(); }
function embedSmilesTo3D(smiles, method='HASH', seed=1337){ 
    const rng = (()=>{let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
    const atoms = smiles.replace(/[^a-zA-Z]/g, '').split('').map(e => ({elem: e.toUpperCase(), x: 0, y: 0, z: 0}));
    if (method === 'HASH') {
        for (let i = 0; i < atoms.length; i++) {
            atoms[i].x = (rng() - 0.5) * 4;
            atoms[i].y = (rng() - 0.5) * 4;
            atoms[i].z = (rng() - 0.5) * 4;
        }
    } else { // RingHelix
        const R = 2.0, pitch = 1.5;
        for (let i = 0; i < atoms.length; i++) {
            const angle = 2 * Math.PI * i / Math.min(atoms.length, 8);
            atoms[i].x = R * Math.cos(angle);
            atoms[i].y = R * Math.sin(angle);
            atoms[i].z = i * pitch / Math.min(atoms.length, 8);
        }
    }
    return atoms;
}
async function runSingleLigandDock() {
    const ligStatus = E('ligStatus'); ligStatus.textContent = 'running...';
    try {
        const receptorPDB = E('ligReceptorPDB').value.trim();
        const smiles = E('ligSmiles').value.trim();
        if (!receptorPDB || !smiles) throw new Error('Receptor PDB and Ligand SMILES are required.');
        const receptorAtoms = parsePDB(receptorPDB);
        const ligandAtoms = embedSmilesTo3D(smiles, E('ligEmbedMethod').value, parseInt(E('ligSeed').value));

        const cR = centroid(receptorAtoms);
        const receptorCentered = translate(receptorAtoms, {x: -cR.x, y: -cR.y, z: -cR.z});
        const cL = centroid(ligandAtoms);
        const ligandCentered = translate(ligandAtoms, {x: -cL.x, y: -cL.y, z: -cL.z});

        let bestPose = { score: -Infinity };
        const rng = (()=>{let s=42; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
        for (let i = 0; i < 5000; i++) {
            const q = [rng()*2-1, rng()*2-1, rng()*2-1, rng()*2-1];
            const n = Math.hypot(...q);
            q.forEach((v,i)=>q[i]=v/n);
            const t = { x: (rng() - 0.5) * 5, y: (rng() - 0.5) * 5, z: (rng() - 0.5) * 5 };
            const posedLigand = applyTransform(ligandCentered, q, t);
            const {score, contacts, clash} = scoreLigand(receptorCentered, posedLigand);
            if (score > bestPose.score) {
                bestPose = { score, contacts, clash, q, t, ligand: posedLigand, receptor: receptorCentered, smiles, receptorPDB };
            }
        }
        
        ligLastResult = bestPose;
        viewerLig.clear();
        viewerLig.addModel(formatPDB(bestPose.receptor), 'pdb');
        viewerLig.addModel(formatPDB(bestPose.ligand, 1), 'pdb');
        viewerLig.setStyle({model: 0}, {stick: {radius: 0.2, color: '#60a5fa'}});
        viewerLig.setStyle({model: 1}, {stick: {radius: 0.3, color: '#f97316'}});
        viewerLig.zoomTo();
        viewerLig.render();
        E('ligScore').textContent = `Best Score: ${bestPose.score.toFixed(2)}, Contacts: ${bestPose.contacts}, Clash: ${bestPose.clash.toFixed(2)}`;
        ligStatus.textContent = 'complete';
    } catch (e) {
        alert('Ligand Docking Failed: ' + e.message);
        ligStatus.textContent = 'error';
    }
}
function scoreLigand(receptor, ligand) {
    let contacts = 0, clash = 0;
    const contactCut = parseFloat(E('contactCut').value) || 4.8;
    const clashFactor = parseFloat(E('clashFactor').value) || 0.85;
    const wClash = parseFloat(E('wClash').value) || 6.0;
    const soft = parseFloat(E('soft').value) || 0.5;
    for (const l of ligand) {
        for (const r of receptor) {
            const d = Math.hypot(l.x - r.x, l.y - r.y, l.z - r.z);
            const rs = (vdw[l.elem] || 1.7) + (vdw[r.elem] || 1.7);
            const cut = clashFactor * rs;
            if (d < cut) {
                const ov=(cut-d+1e-6)/cut;
                clash += wClash*ov*(1/(1+soft*ov));
            } else if (d < contactCut) {
                contacts++;
            }
        }
    }
    return { score: contacts - clash, contacts, clash };
}
function downloadLigandPDB() { if (!ligLastResult.score) return; const pdb = formatPDB(ligLastResult.receptor) + "\n" + formatPDB(ligLastResult.ligand, 1); downloadBlob(pdb, 'ligand_complex.pdb'); }
function downloadLigandCSV() { if (!ligLastResult.score) return; const row = `smiles,score,contacts,clash\n"${ligLastResult.smiles}",${ligLastResult.score.toFixed(3)},${ligLastResult.contacts},${ligLastResult.clash.toFixed(3)}`; downloadBlob(row, 'ligand_result.csv'); }

// ========================= Batch Screening =========================
async function startBatchScreening() {
    E('btnStartScreen').disabled = true; E('btnStopScreen').disabled = false; E('scrStatus').textContent = 'running...'; screenCancel = false;
    try {
        const smilesList = E('scrSmiles').value.trim().split('\n').map(s=>s.trim()).filter(s => s);
        const receptorPDBs = E('scrReceptors').value.replace(/\r/g,'').split(/^\s*END\s*$/m).map(s=>s.trim()).filter(Boolean);
        if (smilesList.length > 50 || receptorPDBs.length > 3) throw new Error('Exceeded limits: max 50 SMILES, max 3 receptors.');
        
        screenReceptors = receptorPDBs.map((pdb, i) => ({ id: `R${i+1}`, atoms: parsePDB(pdb)}));
        if (screenReceptors.some(r => r.atoms.length === 0)) throw new Error('One or more receptors failed to parse.');
        
        screenResults = [];
        E('scrTableBody').innerHTML = ''; let count = 0;
        const totalJobs = smilesList.length * screenReceptors.length;

        for (const receptor of screenReceptors) {
            for (const smiles of smilesList) {
                if (screenCancel) break;
                E('scrProgress').textContent = `Processing ${++count} of ${totalJobs}...`;
                // Yield to the browser event loop for responsiveness
                await new Promise(resolve => setTimeout(() => {
                    const result = dockSingleLigandToReceptor(smiles, receptor.atoms, receptor.id);
                    screenResults.push(result);
                    resolve();
                }, 0));
            }
            if (screenCancel) break;
        }
        
        // Final sort and display
        sortAndDisplayScreeningResults();
        E('scrStatus').textContent = screenCancel ? 'stopped' : 'complete';
    } catch (e) {
        alert('Screening failed: ' + e.message); E('scrStatus').textContent = 'error';
    }
    E('btnStartScreen').disabled = false; E('btnStopScreen').disabled = true;
}

function dockSingleLigandToReceptor(smiles, receptorAtoms, receptorId) {
    const embedMethod = E('scrEmbedMethod').value;
    const seed = parseInt(E('scrSeed').value);
    const ligandAtoms = embedSmilesTo3D(smiles, embedMethod, seed + smiles.length);
    
    const cR = centroid(receptorAtoms);
    const receptorCentered = translate(receptorAtoms.map(a=>({...a})), {x: -cR.x, y: -cR.y, z: -cR.z});
    const cL = centroid(ligandAtoms);
    const ligandCentered = translate(ligandAtoms, {x: -cL.x, y: -cL.y, z: -cL.z});

    let bestPose = { score: -Infinity };
    const rng = (()=>{let s=seed; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
    const samples = parseInt(E('scrSamples').value);

    for (let i = 0; i < samples; i++) {
        const q = [rng()*2-1, rng()*2-1, rng()*2-1, rng()*2-1];
        const n = Math.hypot(...q); q.forEach((v,i)=>q[i]=v/n);
        const t = { x: (rng() - 0.5) * 8, y: (rng() - 0.5) * 8, z: (rng() - 0.5) * 8 };
        const posedLigand = applyTransform(ligandCentered, q, t);
        const { score, contacts, clash } = scoreLigand(receptorCentered, posedLigand);
        if (score > bestPose.score) {
            bestPose = { score, contacts, clash, q, t };
        }
    }
    
    const metrics = computeInterfaceMetrics(receptorCentered, applyTransform(ligandCentered, bestPose.q, bestPose.t), parseFloat(E('scrContactCut').value));
    const dH = calculateEnthalpy(metrics, 0); // Simplified dH for screening
    return { ...bestPose, smiles, receptorId, hb: metrics.hb, sb: metrics.sb, dH, contacts: metrics.contacts, clash: metrics.clash };
}

function sortAndDisplayScreeningResults() {
    const sortBy = E('scrSort').value;
    if (sortBy === 'score') screenResults.sort((a,b) => b.score - a.score);
    else if (sortBy === 'enthalpy') screenResults.sort((a,b) => a.dH - b.dH);
    else { // consensus
        // rank by each metric
        const scoreRank = [...screenResults].sort((a,b) => b.score - a.score);
        const dHRank = [...screenResults].sort((a,b) => a.dH - b.dH);
        const contactRank = [...screenResults].sort((a,b) => b.contacts - a.contacts); // DESC: more contacts better
        
        const rankMap = new Map();
        const addRanks = (arr)=> arr.forEach((item, i) => {
            const key = item.receptorId + '||' + item.smiles;
            if (!rankMap.has(key)) rankMap.set(key, 0);
            rankMap.set(key, rankMap.get(key) + i);
        });
        addRanks(scoreRank); addRanks(dHRank); addRanks(contactRank);
        screenResults.forEach(r => { r.cRank = rankMap.get(r.receptorId + '||' + r.smiles); });
        screenResults.sort((a,b) => a.cRank - b.cRank);
    }
    
    const body = E('scrTableBody'); body.innerHTML = '';
    screenResults.forEach((r, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${r.receptorId}</td><td class="small">${r.smiles}</td><td>${r.score.toFixed(2)}</td><td>${r.contacts}</td><td>${r.hb}</td><td>${r.sb}</td><td>${r.clash.toFixed(2)}</td><td>${r.dH.toFixed(2)}</td><td>${r.cRank || '-'}</td>`;
        tr.addEventListener('click', () => visualizeScreeningPose(r));
        body.appendChild(tr);
    });
}
function visualizeScreeningPose(result) {
    const receptor = screenReceptors.find(r => r.id === result.receptorId);
    if (!receptor) return;
    const ligand = embedSmilesTo3D(result.smiles);
    const cR = centroid(receptor.atoms);
    const receptorCentered = translate(receptor.atoms.map(a=>({...a})), {x: -cR.x, y: -cR.y, z: -cR.z});
    const cL = centroid(ligand);
    const ligandCentered = translate(ligand, {x: -cL.x, y: -cL.y, z: -cL.z});
    const posedLigand = applyTransform(ligandCentered, result.q, result.t);
    
    viewerScr.clear();
    viewerScr.addModel(formatPDB(receptorCentered), 'pdb');
    viewerScr.addModel(formatPDB(posedLigand, 1), 'pdb');
    viewerScr.setStyle({model: 0}, {cartoon: {color: '#60a5fa'}});
    viewerScr.setStyle({model: 1}, {stick: {radius: 0.3, color: '#f97316'}});
    viewerScr.zoomTo();
    viewerScr.render();
}
function downloadScreeningCSV() { const header = 'rank,receptor,smiles,score,contacts,clash,h_bonds,salt_bridges,delta_h,consensus_rank\n'; const rows = screenResults.map((r,i) => [i+1, r.receptorId, `"${r.smiles}"`, r.score.toFixed(3), r.contacts, r.clash.toFixed(3), r.hb, r.sb, r.dH.toFixed(3), r.cRank||''].join(',')).join('\n'); downloadBlob(header+rows, 'screening_results.csv'); }
function downloadScreeningJSON() { downloadBlob(JSON.stringify(screenResults, null, 2), 'screening_results.json'); }
function showTop10Screening() {
    const top10 = screenResults.slice(0, 10);
    const dHs = top10.map(r => r.dH);
    const min = Math.min(...dHs), max = Math.max(...dHs), avg = dHs.reduce((a,b) => a+b, 0) / (dHs.length||1);
    E('screenMetrics').innerHTML = `<div class="metric-card"><div class="metric-value">${min.toFixed(2)}</div><div class="metric-label">Min ŒîH</div></div><div class="metric-card"><div class="metric-value">${max.toFixed(2)}</div><div class="metric-label">Max ŒîH</div></div><div class="metric-card"><div class="metric-value">${avg.toFixed(2)}</div><div class="metric-label">Avg ŒîH</div></div>`;
    E('enthalpyBreakdown').textContent = 'Top 10 ŒîH Values:\n' + dHs.map(d => d.toFixed(2)).join(', ');
}

// ========================= QA & Registry =========================
function saveCurrentRun() {
    if (!combos.length) { alert('No run data to save.'); return; }
    const topPose = combos[0]?.topPoses[0];
    const run = {
        timestamp: new Date().toISOString(),
        type: 'Antibody Docking',
        description: combos.map(c => c.label).join('; '),
        topScore: topPose ? topPose.score.toFixed(3) : 'N/A',
        signature: '...' + (Math.random().toString(36).substring(2, 8)),
        data: { combos }
    };
    const registry = JSON.parse(localStorage.getItem(REGISTRY_KEY) || '[]');
    registry.unshift(run);
    localStorage.setItem(REGISTRY_KEY, JSON.stringify(registry.slice(0, 50)));
    refreshRunRegistry();
}
function refreshRunRegistry() {
    const registry = JSON.parse(localStorage.getItem(REGISTRY_KEY) || '[]');
    const body = E('registryTableBody'); body.innerHTML = '';
    registry.forEach((run, i) => {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${new Date(run.timestamp).toLocaleString()}</td><td>${run.type}</td><td>${run.description}</td><td>${run.topScore}</td><td>${run.signature}</td><td><button class="btn small" onclick="loadRun(${i})">Load</button></td>`;
        body.appendChild(tr);
    });
}
function loadRun(index) {
    const registry = JSON.parse(localStorage.getItem(REGISTRY_KEY) || '[]');
    const run = registry[index];
    if (run && run.data.combos) {
        combos = run.data.combos;
        updateComboSelect();
        setCurrentCombo(0);
        alert('Run loaded.');
    }
}
function clearRunRegistry() { if (confirm('Clear entire run registry?')) { localStorage.removeItem(REGISTRY_KEY); refreshRunRegistry(); }}
function exportAllRuns() { const data = localStorage.getItem(REGISTRY_KEY) || '[]'; downloadBlob(data, 'docking_registry.json'); }
function importRunRegistry() { E('importRegistryFile').click(); E('importRegistryFile').onchange = async (e) => { try { const text = await fileToText(e.target.files[0]); const data = JSON.parse(text); if (Array.isArray(data)) { localStorage.setItem(REGISTRY_KEY, JSON.stringify(data)); refreshRunRegistry(); alert('Registry imported.'); } else { alert('Invalid format.'); } } catch(err) { alert('Import failed: ' + err.message); } }; }

async function runQATest() {
    const repeats = parseInt(E('qaRepeats').value);
    const tolerance = parseFloat(E('qaTolerance').value);
    const qaResults = E('qaResults');
    qaResults.textContent = 'Running QA test...';
    
    if (!combos.length || !combos[0]) { qaResults.textContent = 'No docking run available to test.'; return; }
    
    const scores = [];
    const params = collectDockingParams();
    for (let i = 0; i < repeats; i++) {
        await dockSingleCombo(0, params, ()=>{}); // no progress update
        const topScore = combos[0]?.topPoses[0]?.score;
        if (typeof topScore === 'number') scores.push(topScore);
    }
    
    if (!scores.length) { qaResults.textContent = 'QA failed to collect scores.'; return; }
    const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
    const maxDiff = Math.max(...scores) - Math.min(...scores);
    const pass = maxDiff <= tolerance;
    
    qaResults.textContent = `QA Test Results (${repeats} repeats):\n`
        + `Scores: ${scores.map(s=>s.toFixed(3)).join(', ')}\n`
        + `Average Score: ${avg.toFixed(3)}\n`
        + `Max Difference: ${maxDiff.toFixed(3)}\n`
        + `Tolerance: ${tolerance.toFixed(3)}\n`
        + `Result: ${pass ? '‚úÖ PASSED' : '‚ùå FAILED'}`;
}

// ========================= Session Save/Load =========================
function saveSession() {
    const state = {
        pdbAText: E('pdbAText').value,
        pdbBText: E('pdbBText').value,
        params: collectDockingParams(),
        dockingResults: combos
    };
    downloadBlob(JSON.stringify(state), 'docking_session.json');
}
function loadSession() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = async (e) => {
        try {
            const text = await e.target.files[0].text();
            const state = JSON.parse(text);
            E('pdbAText').value = state.pdbAText || '';
            E('pdbBText').value = state.pdbBText || '';
            if (state.params) {
                Object.keys(state.params).forEach(k => {
                    const el = E(k);
                    if (el && state.params[k] != null) el.value = state.params[k];
                });
            }
            if (state.dockingResults) {
                combos = state.dockingResults;
                updateComboSelect();
                setCurrentCombo(0);
            }
            alert('Session loaded.');
        } catch(err) {
            alert('Failed to load session: ' + err.message);
        }
    };
    input.click();
}
function loadSessionHistory() { refreshRunRegistry(); }

// ====================== DEMO ======================
function useExample(which){
  if(which==='A'){ E('pdbAText').value=`ATOM      1  CA  GLY A   1      10.000  10.000  10.000  1.00  0.00           C\nATOM      2  CA  ALA A   2      12.000  11.000  10.500  1.00  0.00           C`; }
  else{ E('pdbBText').value=`ATOM      1  CA  PRO B   1      15.000  15.000  15.000  1.00  0.00           C\nATOM      2  CA  LEU B   2      17.000  14.000  15.500  1.00  0.00           C`; }
}
async function autoDemo(){ useExample('A'); useExample('B'); E('samples').value=2000; await runAntibodyDocking(); }

// ====================== OMICS AND NMR EVENTS ======================
function bindOmicsAndNMREvents() {
  E('nmrSmiles').addEventListener('input', updateNMRImage);
  E('btnPredict1H').addEventListener('click', () => predictNMR('1H'));
  E('btnPredict13C').addEventListener('click', () => predictNMR('13C'));
  E('btnPredictCOSY').addEventListener('click', () => predictNMR('COSY'));
  E('btnPredictNOESY').addEventListener('click', () => predictNMR('NOESY'));
}

async function updateNMRImage() {
    const smiles = E('nmrSmiles').value.trim();
    const imgDiv = E('nmrMoleculeImage');
    if (!smiles) {
        imgDiv.style.backgroundImage = 'none';
        imgDiv.textContent='';
        return;
    }
    imgDiv.textContent = 'Image generation requires a server-side call (e.g., using RDKit).';
    imgDiv.style.textAlign = 'center';
    imgDiv.style.padding = '20px';
}

function predictNMR(type) {
    const smiles = E('nmrSmiles').value.trim();
    const output = E('nmrPredictionOutput');
    if (!smiles) {
        output.textContent = 'Please enter a SMILES string.';
        return;
    }

    let predictionText = `--- THEORETICAL ${type} PREDICTION FOR ${smiles} ---\n\n`;

    if (smiles === 'CC(=O)Oc1ccccc1C(=O)O') { // Aspirin
        if (type === '1H') {
            predictionText += `Aspirin has several distinct proton environments:\n\n- Methyl Protons (-CH3): A sharp singlet integrating to 3H, expected around Œ¥ 2.3 ppm.\n- Aromatic Protons (-C6H4-): Four protons on the benzene ring as a multiplet system between Œ¥ 7.1-8.2 ppm.\n- Carboxylic Acid Proton (-COOH): A broad singlet > 10 ppm (solvent dependent; exchanges with D2O).`;
        } else if (type === '13C') {
            predictionText += `There are 9 unique carbon atoms in aspirin:\n\n- Methyl Carbon (-CH3): ~21 ppm.\n- Carbonyl Carbon (Ester, C=O): ~169 ppm.\n- Carbonyl Carbon (Acid, C=O): ~171 ppm.\n- Aromatic Carbons (6 signals): ~120‚Äì155 ppm; C‚ÄìO around 151 ppm.`;
        } else if (type === 'COSY') {
            predictionText += `COSY shows correlations between J-coupled protons (2‚Äì3 bonds). Expect cross-peaks among adjacent aromatic protons.`;
        } else if (type === 'NOESY') {
            predictionText += `NOESY shows through-space correlations (<5 √Ö). Possible cross-peak between methyl protons (~2.3 ppm) and the ortho aromatic proton (~7.1 ppm).`;
        }
    } else {
        predictionText += 'Prediction for this specific molecule is not pre-calculated. This demo includes an example for Aspirin (CC(=O)Oc1ccccc1C(=O)O).';
    }
    output.textContent = predictionText;
}

// ====================== Reset ======================
function resetAll(){
  pdbAAllAtoms=[]; pdbBAllAtoms=[]; combos=[]; currentComboIndex=-1; currentContacts=[]; currentHB=[]; currentSB=[]; currentHydro=[];
  ['pdbAText','pdbBText'].forEach(id=>E(id).value='');
  E('chainsABox').innerHTML=''; E('chainsBBox').innerHTML='';
  E('chainWarnA').className='infobox small'; E('chainWarnA').textContent='Parse to populate chains.';
  E('chainWarnB').className='infobox small'; E('chainWarnB').textContent='Parse to populate chains.';
  E('comboSelect').innerHTML='';
  E('poseControls').innerHTML='';
  E('comboSummaryBody').innerHTML='';
  E('metricsDisplay').innerHTML='';
  E('scoreBox').textContent='';
  E('residueTableBody').innerHTML='';
  viewer?.clear(); viewerLig?.clear(); viewerScr?.clear(); viewerComp?.clear();
  drawPlaceholder(viewer);
  status('idle'); setProgress(0);
}
</script>
</body>
</html>
