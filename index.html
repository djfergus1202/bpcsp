<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Antibody‚ÄìAntigen Docking ‚Ä¢ Parallel ‚Ä¢ Interface Analytics ‚Ä¢ Sequence‚ÜíPDB</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0f172a" />
<meta name="description" content="Client-side protein‚Äìprotein docking with worker pool, clash/contact scoring, diversity clustering, interface analytics (H-bonds, salt bridges, electrostatics, BSA proxy), and a Sequence‚ÜíPDB builder." />
<style>
  :root{
    --bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#9ca3af;
    --accent:#60a5fa;--line:#1f2937;--green:#34d399;--red:#f87171;--yellow:#fbbf24;--violet:#a78bfa;
    --mono: ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;
    --sans: Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,"Helvetica Neue",Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans);line-height:1.6}
  a{color:var(--accent);text-decoration:none}
  a:hover{text-decoration:underline}
  header{padding:40px 16px;background:
    radial-gradient(1200px 600px at 15% -10%,#1d2a4a,transparent 60%),
    radial-gradient(1000px 500px at 120% 10%,#2a1e4a,transparent 60%);}
  .wrap{max-width:1200px;margin:0 auto}
  h1{margin:0 0 8px;font-size:32px}
  p.lead{color:var(--muted);margin:6px 0 0}
  section{padding:22px 16px;border-top:1px solid var(--line);background:var(--panel)}
  h2{margin:0 0 10px;font-size:24px}
  h3{margin:14px 0 6px;font-size:18px}
  .grid{display:grid;gap:16px}
  @media(min-width:980px){.grid{grid-template-columns:1.1fr .9fr}}
  .card{background:#0b1220;border:1px solid var(--line);border-radius:14px;padding:14px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{font-weight:600}
  input[type="number"], input[type="text"], textarea, select{
    background:#0a0f1a;color:var(--text);border:1px solid #1f2937;border-radius:8px;
    padding:8px 10px;font-family:var(--mono);font-size:13px;min-width:80px
  }
  textarea{width:100%;min-height:120px}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:9px 12px;border-radius:10px;font-weight:600;border:1px solid var(--line);background:#0b1220;cursor:pointer}
  .btn.primary{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0}
  .btn.green{background:linear-gradient(180deg,#059669,#047857);border:0}
  .btn.red{background:linear-gradient(180deg,#dc2626,#b91c1c);border:0}
  .muted{color:var(--muted)}
  .small{font-size:12px;color:var(--muted)}
  #viewer,#seqViewer{width:100%;height:520px;border:1px solid var(--line);border-radius:10px;background:#0a0f1a}
  .two{display:grid;gap:12px}
  @media(min-width:700px){.two{grid-template-columns:1fr 1fr}}
  .score{font-family:var(--mono);background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:8px;overflow:auto}
  .badge{display:inline-block;border:1px solid #1f2937;color:var(--muted);border-radius:999px;padding:2px 8px;font-size:12px;margin-right:6px}
  .warn{border-left:4px solid var(--yellow);padding-left:10px;margin:10px 0;color:#fbbf24}
  details{border:1px solid var(--line);border-radius:10px;padding:10px;background:#0b1220}
  details summary{cursor:pointer;font-weight:600}
  .kflex{display:flex;gap:10px;flex-wrap:wrap;margin:6px 0}
  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .tabbtn{padding:8px 12px;border-radius:999px;border:1px solid var(--line);cursor:pointer;background:#0b1220}
  .tabbtn.active{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0}
  .tabsec{display:none}
  .tabsec.active{display:block}
  .pill{padding:2px 8px;border:1px solid #334155;border-radius:999px;font-size:12px;color:#93c5fd}
  progress{width:260px;height:10px;border:1px solid #1f2937;border-radius:999px;background:#0b1220}
  progress::-webkit-progress-bar{background:#0b1220;border-radius:999px}
  progress::-webkit-progress-value{background:#60a5fa;border-radius:999px}
  .toggle{display:inline-flex;align-items:center;gap:6px}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>In-Browser Antibody‚ÄìAntigen Docking</h1>
    <p class="lead">Parallel docking (worker pool) ‚Ä¢ vdW-aware scoring ‚Ä¢ diversity clustering ‚Ä¢ interface analytics ‚Ä¢ rich exports ‚Äî plus a Sequence‚ÜíPDB builder.</p>
    <div class="kflex">
      <span class="badge">No server</span><span class="badge">3Dmol.js</span><span class="badge">Workers</span><span class="badge">PDB/CSV/JSON/PNG</span>
    </div>
    <div class="tabs">
      <button class="tabbtn active" data-tab="dockTab">üß∑ Docking</button>
      <button class="tabbtn" data-tab="seqTab">üß¨ Sequence ‚Üí PDB</button>
    </div>
  </div>
</header>

<!-- DOCKING TAB -->
<section id="dockTab" class="tabsec active">
  <div class="wrap grid">
    <div class="card">
      <h2>1) Load Proteins</h2>
      <div class="two">
        <div>
          <h3>Protein A (e.g., antibody)</h3>
          <div class="row">
            <input type="file" id="pdbAFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('A')">Use example</button>
          </div>
          <textarea id="pdbAText" placeholder="Paste PDB text for Protein A (optional)"></textarea>
          <div class="row">
            <label>Chains</label>
            <input type="text" id="chainsA" placeholder="e.g., H,L or A" />
            <span class="small">Leave blank = all chains</span>
          </div>
        </div>
        <div>
          <h3>Protein B (e.g., antigen)</h3>
          <div class="row">
            <input type="file" id="pdbBFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('B')">Use example</button>
          </div>
          <textarea id="pdbBText" placeholder="Paste PDB text for Protein B (optional)"></textarea>
          <div class="row">
            <label>Chains</label>
            <input type="text" id="chainsB" placeholder="e.g., A or X" />
            <span class="small">Leave blank = all chains</span>
          </div>
        </div>
      </div>
      <details style="margin-top:10px">
        <summary>About formats</summary>
        <p class="muted">Protein‚Äìprotein docking requires **PDB** (this page also accepts <code>.pdb.gz</code>). SMILES is not suitable for full proteins.</p>
      </details>
    </div>

    <div class="card">
      <h2>2) Docking Parameters</h2>
      <div class="row">
        <label>Samples</label><input type="number" id="samples" value="20000" min="100" step="100" />
        <label>Max Œî (√Ö)</label><input type="number" id="maxTrans" value="12" min="0" step="1" />
        <label>Atom selection</label>
        <select id="atomMode">
          <option value="CA">CŒ± only (fast)</option>
          <option value="BB">Backbone (N, CA, C, O)</option>
          <option value="HEAVY">All heavy atoms (slow)</option>
        </select>
      </div>
      <div class="row">
        <label>Contact cutoff (√Ö)</label><input type="number" id="contactCut" value="4.8" step="0.1" />
        <label>Clash factor</label><input type="number" id="clashFactor" value="0.85" step="0.05" />
        <label>Contact weight</label><input type="number" id="wContact" value="1.0" step="0.1" />
        <label>Clash penalty</label><input type="number" id="wClash" value="6.0" step="0.1" />
        <label>Softening</label><input type="number" id="soft" value="0.5" step="0.1" />
      </div>
      <div class="row">
        <label>Top poses</label><input type="number" id="topN" value="20" min="1" max="100" />
        <label>Rescore</label>
        <select id="rescoreMode">
          <option value="NONE">Skip</option>
          <option value="HEAVY">Heavy atoms</option>
          <option value="HEAVY_REFINE">Heavy + micro-refine</option>
        </select>
        <label>Seed</label><input type="number" id="seed" value="42" />
      </div>
      <div class="row">
        <label>Diversity (¬∞/√Ö)</label>
        <input type="number" id="dupAngle" value="10" step="1" title="Max rotation angle difference (degrees)" />
        <input type="number" id="dupTrans" value="2" step="0.5" title="Max translation difference (√Ö)" />
        <span class="small">Filters near-duplicates for diverse top poses</span>
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn primary" id="dockBtn" onclick="runDocking()">‚ñ∂Ô∏è Run Docking</button>
        <button class="btn red" id="cancelBtn" onclick="cancelDocking()" disabled>‚úñ Cancel</button>
        <button class="btn" onclick="resetAll()">Reset</button>
        <span class="pill" id="statusPill">idle</span>
        <progress id="prog" value="0" max="1"></progress>
      </div>
      <p class="small muted">Scoring = contacts ‚àí vdW-aware clash penalty. Use heavy re-score for better ranking; micro-refine jitters the best transforms.</p>
    </div>
  </div>
</section>

<section class="tabsec active" id="dockResults">
  <div class="wrap grid">
    <div class="card">
      <h2>3) Results & Viewer</h2>
      <div id="viewer"></div>
      <div id="poseControls" class="row" style="margin-top:8px;flex-wrap:wrap"></div>
      <div class="row" style="margin-top:6px">
        <button class="btn green" onclick="downloadAllPoses()">‚¨á Multi-model PDB (top N)</button>
        <button class="btn" onclick="downloadCSV()">‚¨á Summary CSV</button>
        <button class="btn" onclick="downloadJSON()">‚¨á Interface JSON</button>
        <button class="btn" onclick="snapshotPNG()">üì∏ PNG Snapshot</button>
      </div>
      <div class="row" style="margin-top:6px">
        <label class="toggle"><input type="checkbox" id="toggleContacts" onchange="refreshOverlays()"> Contacts</label>
        <label class="toggle"><input type="checkbox" id="toggleHB" onchange="refreshOverlays()"> H-bonds</label>
        <label class="toggle"><input type="checkbox" id="toggleSB" onchange="refreshOverlays()"> Salt bridges</label>
      </div>
      <div class="score" id="scoreBox" style="margin-top:8px"></div>
    </div>
    <div class="card">
      <h2>Interface Metrics</h2>
      <ul class="small">
        <li><b>Contacts:</b> atom pairs within contact cutoff.</li>
        <li><b>H-bonds:</b> N‚Ä¶O < 3.5 √Ö (geometric proxy; no hydrogens/angles).</li>
        <li><b>Salt bridges:</b> (Asp/Glu O*)‚Äì(Lys/Arg/His N*) < 4.0 √Ö.</li>
        <li><b>Hydrophobic contacts:</b> C‚Ä¶C < 4.5 √Ö between hydrophobic residues.</li>
        <li><b>Electrostatics:</b> residue-level Coulomb q‚àà{‚àí1,0,+1,+0.1 for HIS} within 12 √Ö (arbitrary units parameterized by k<sub>elec</sub>).</li>
        <li><b>BSA proxy:</b> ~10 √Ö¬≤ per contact pair (educational approximation).</li>
      </ul>
      <div class="row">
        <label>k<sub>elec</sub></label><input type="number" id="kElec" value="0.5" step="0.1" />
        <label>Elec cutoff (√Ö)</label><input type="number" id="elecCut" value="12" step="0.5" />
      </div>
      <div class="warn">‚ÄúPseudo-enthalpy‚Äù is an educational score ‚Äî not a calibrated ŒîG. Use exported PDBs for refinement in HADDOCK/ClusPro/Rosetta/MD for publication-grade results.</div>
    </div>
  </div>
</section>

<!-- SEQUENCE ‚Üí PDB TAB -->
<section id="seqTab" class="tabsec">
  <div class="wrap grid">
    <div class="card">
      <h2>Sequence ‚Üí PDB (Educational Builder)</h2>
      <p class="muted">Build a quick CA or approximate backbone model from a sequence (helix/strand/coil). Use this to prototype before docking.</p>
      <div class="two">
        <div>
          <h3>Input</h3>
          <label>Protein Sequence (one-letter; spaces/newlines ok)</label>
          <textarea id="seqInput" placeholder=">optional FASTA header
EVQLVESGGGLVQPGGSLRLSC..."></textarea>
          <div class="row">
            <input type="file" id="fastaFile" accept=".fasta,.fa,.txt" />
            <button class="btn" onclick="loadFASTA()">Load FASTA</button>
          </div>
          <div class="row">
            <label>Filename</label><input type="text" id="seqFilename" value="sequence_model.pdb" style="min-width:240px" />
          </div>
          <div class="row">
            <label>Chain</label><input type="text" id="seqChain" value="A" style="width:80px" />
            <label>Start Res#</label><input type="number" id="seqStart" value="1" min="1" />
            <label>Atoms</label>
            <select id="seqAtoms">
              <option value="CA">CA-only</option>
              <option value="BB">Backbone (N,CA,C,O approx)</option>
            </select>
          </div>
          <h3>Secondary Structure</h3>
          <div class="row">
            <label>Preset</label>
            <select id="ssPreset">
              <option value="HELIX">Helix (œÜ‚âà‚àí57¬∞, œà‚âà‚àí47¬∞)</option>
              <option value="STRAND">Strand (œÜ‚âà‚àí139¬∞, œà‚âà135¬∞)</option>
              <option value="COIL">Coil (random œÜ/œà)</option>
            </select>
            <label>Helix radius (√Ö)</label><input type="number" id="seqRadius" value="2.3" step="0.1" />
            <label>Rise/res (√Ö)</label><input type="number" id="seqRise" value="1.5" step="0.1" />
          </div>
          <div class="row" style="margin-top:8px">
            <button class="btn green" onclick="seqPreview()">üëÅÔ∏è Preview</button>
            <button class="btn primary" onclick="seqDownload()">‚¨á Download PDB</button>
          </div>
        </div>
        <div>
          <h3>Preview</h3>
          <div id="seqViewer"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Notes</h2>
      <ul>
        <li>Use AlphaFold/ESMFold for realistic structures; then refine/dock.</li>
        <li>You can feed the generated PDB back into the Docking tab.</li>
      </ul>
    </div>
  </div>
</section>

<footer class="wrap" style="padding:20px 16px;color:var(--muted);text-align:center">
  All computations are client-side. ¬© You.
</footer>

<!-- 3D viewer & gzip -->
<script src="https://unpkg.com/3dmol@2.4.2/build/3Dmol-min.js"></script>
<script src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

<script>
/* ========================= Tabs ========================= */
const tabButtons = document.querySelectorAll('.tabbtn');
tabButtons.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    tabButtons.forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    document.querySelectorAll('.tabsec').forEach(s=>s.classList.remove('active'));
    document.getElementById(btn.dataset.tab).classList.add('active');
    if (btn.dataset.tab === 'dockTab') document.getElementById('dockResults').classList.add('active');
    if (btn.dataset.tab === 'seqTab') document.getElementById('dockResults').classList.remove('active');
  });
});

/* ========================= Viewers ========================= */
let viewer=null, seqViewer=null;
function initViewers(){
  viewer = $3Dmol.createViewer("viewer", {backgroundColor:"#0a0f1a"});
  viewer.render();
  seqViewer = $3Dmol.createViewer("seqViewer", {backgroundColor:"#0a0f1a"});
  seqViewer.render();
}
window.addEventListener('DOMContentLoaded', initViewers);

/* ========================= PDB helpers ========================= */
function parsePDB(text) {
  const atoms = [];
  const lines = text.split(/\r?\n/);
  for (const ln of lines) {
    if (ln.startsWith('ATOM') || ln.startsWith('HETATM')) {
      const name = ln.substring(12,16).trim();
      const resn = ln.substring(17,20).trim();
      const chain = (ln.substring(21,22).trim() || 'A');
      const resi = parseInt(ln.substring(22,26));
      const x = parseFloat(ln.substring(30,38));
      const y = parseFloat(ln.substring(38,46));
      const z = parseFloat(ln.substring(46,54));
      const elem = ln.length >= 78 ? (ln.substring(76,78).trim() || name[0]) : name[0];
      atoms.push({name,resn,chain,resi,x,y,z,elem});
    }
  }
  return atoms;
}
function filterChains(atoms, keepSet) {
  if (!keepSet || keepSet.size===0) return atoms;
  return atoms.filter(a => keepSet.has(a.chain));
}
function selectAtomSet(atoms, mode) {
  const bb = new Set(['N','CA','C','O']);
  return atoms.filter(a=>{
    if (mode==='CA') return a.name==='CA';
    if (mode==='BB') return bb.has(a.name);
    if (mode==='HEAVY') return a.elem!=='H';
    return true;
  });
}
function centroid(points) {
  let sx=0,sy=0,sz=0,n=points.length;
  for (const p of points){sx+=p.x;sy+=p.y;sz+=p.z}
  return {x:sx/n, y:sy/n, z:sz/n};
}
function translate(points, v) { return points.map(p=>({...p, x:p.x+v.x, y:p.y+v.y, z:p.z+v.z })); }
function formatPDB(atoms, chainShift=0) {
  let lines=[]; let serial=1;
  for (const a of atoms){
    const name = (a.name||"CA").padStart(4,' ');
    const resn = (a.resn||'RES').padStart(3,' ');
    const chain = (a.chain || 'A');
    const chainOut = String.fromCharCode(chain.charCodeAt(0)+chainShift);
    const resi = (a.resi||1).toString().padStart(4,' ');
    const x=(a.x??0).toFixed(3).toString().padStart(8,' ');
    const y=(a.y??0).toFixed(3).toString().padStart(8,' ');
    const z=(a.z??0).toFixed(3).toString().padStart(8,' ');
    const occ=" 1.00"; const b=" 0.00";
    const elem=(a.elem||'C').toString().padStart(2,' ');
    lines.push(`ATOM  ${String(serial).padStart(5,' ')} ${name} ${resn} ${chainOut}${resi}    ${x}${y}${z}${occ}${b}          ${elem}`);
    serial++;
  }
  lines.push("TER","ENDMDL","END");
  return lines.join("\n");
}
const vdw = {H:1.2, C:1.7, N:1.55, O:1.52, S:1.8, P:1.8, F:1.47, CL:1.75, BR:1.85, I:1.98};

/* ========================= File IO (+gzip) ========================= */
async function fileToText(file){
  const name = file.name.toLowerCase();
  const buf = await file.arrayBuffer();
  if (name.endsWith('.gz')){
    const u8 = new Uint8Array(buf);
    const out = pako.inflate(u8);
    return new TextDecoder().decode(out);
  }
  return new TextDecoder().decode(buf);
}

/* ========================= Global state ========================= */
let pdbA=null, pdbB=null, pdbAAtoms=[], pdbBAtoms=[];
let posesTop=[], currentContacts=[], currentHB=[], currentSB=[];
let heavyUsed=false, currentA=null, currentB0=null, currentPose=null;
let workerPool=[], cancelled=false, inProgress=false;

/* ========================= Loading & UI ========================= */
function status(msg){ const p=document.getElementById('statusPill'); p.textContent=msg; }
function setProgress(frac){ const el=document.getElementById('prog'); el.value=Math.max(0,Math.min(1,frac||0)); }
function resetAll(){
  ['pdbAFile','pdbBFile'].forEach(id=>document.getElementById(id).value="");
  ['pdbAText','pdbBText','chainsA','chainsB'].forEach(id=>document.getElementById(id).value="");
  document.getElementById('poseControls').innerHTML="";
  document.getElementById('scoreBox').textContent="";
  posesTop=[]; currentContacts=[]; currentHB=[]; currentSB=[];
  viewer.clear(); viewer.render(); setProgress(0); status('idle');
}
async function loadInputs(){
  const fA = document.getElementById("pdbAFile").files[0];
  const fB = document.getElementById("pdbBFile").files[0];
  let tA = document.getElementById("pdbAText").value.trim();
  let tB = document.getElementById("pdbBText").value.trim();
  if (!tA && fA) tA = await fileToText(fA);
  if (!tB && fB) tB = await fileToText(fB);
  if (!tA || !tB) throw new Error("Provide PDB for both Protein A and Protein B (file or pasted text).");
  const chainsA = new Set((document.getElementById('chainsA').value||'').split(',').map(s=>s.trim()).filter(Boolean));
  const chainsB = new Set((document.getElementById('chainsB').value||'').split(',').map(s=>s.trim()).filter(Boolean));
  pdbAAtoms = filterChains(parsePDB(tA), chainsA);
  pdbBAtoms = filterChains(parsePDB(tB), chainsB);
  if (pdbAAtoms.length===0 || pdbBAtoms.length===0) throw new Error("No atoms after chain filtering; check chain IDs.");
  pdbA=tA; pdbB=tB;
}

/* ========================= Example minimal PDBs ========================= */
function useExample(which){
  const egA=`ATOM      1  N   GLY H   1      -2.000   0.000   0.000  1.00  0.00           N
ATOM      2  CA  GLY H   1      -0.650   0.000   0.000  1.00  0.00           C
ATOM      3  C   GLY H   1       0.000   1.300   0.500  1.00  0.00           C
ATOM      4  O   GLY H   1       0.000   2.300  -0.200  1.00  0.00           O
END`;
  const egB=`ATOM      1  N   GLY A   1       2.000   0.000   0.000  1.00  0.00           N
ATOM      2  CA  GLY A   1       0.650   0.000   0.000  1.00  0.00           C
ATOM      3  C   GLY A   1       0.000  -1.300  -0.500  1.00  0.00           C
ATOM      4  O   GLY A   1       0.000  -2.300   0.200  1.00  0.00           O
END`;
  if (which==='A') document.getElementById('pdbAText').value=egA;
  else document.getElementById('pdbBText').value=egB;
}

/* ========================= Worker pool (parallel sampling) ========================= */
function makeDockWorker(){
  const src = `
    const vdw = {H:1.2, C:1.7, N:1.55, O:1.52, S:1.8, P:1.8, F:1.47, CL:1.75, BR:1.85, I:1.98};
    function rand(seed){ let s = seed>>>0; return ()=> (s = (1664525*s + 1013904223)>>>0, (s/0xFFFFFFFF)); }
    function randomQuat(rng){ const u1=rng(), u2=rng(), u3=rng(); const a=Math.sqrt(1-u1), b=Math.sqrt(u1), t1=2*Math.PI*u2, t2=2*Math.PI*u3; return [a*Math.sin(t1), a*Math.cos(t1), b*Math.sin(t2), b*Math.cos(t2)]; }
    function rotatePoints(pts, q){ const [x,y,z,w]=q; return pts.map(p=>{ const vx=p.x, vy=p.y, vz=p.z;
      const ix =  w*vx + y*vz - z*vy; const iy =  w*vy + z*vx - x*vz; const iz =  w*vz + x*vy - y*vx; const iw = -x*vx - y*vy - z*vz;
      const ox = ix*w + iw*(-x) + iy*(-z) - iz*(-y); const oy = iy*w + iw*(-y) + iz*(-x) - ix*(-z); const oz = iz*w + iw*(-z) + ix*(-y) - iy*(-x);
      return {x:ox,y:oy,z:oz,elem:p.elem}; }); }
    function translate(pts, t){ return pts.map(p=>({x:p.x+t.x,y:p.y+t.y,z:p.z+t.z,elem:p.elem})); }
    function makeGrid(coords, cell){
      const map=new Map(); const key=(ix,iy,iz)=>ix+"|"+iy+"|"+iz;
      for(let i=0;i<coords.length;i++){ const x=coords[i].x, y=coords[i].y, z=coords[i].z; const ix=Math.floor(x/cell), iy=Math.floor(y/cell), iz=Math.floor(z/cell);
        const k=key(ix,iy,iz); if(!map.has(k)) map.set(k, []); map.get(k).push(i); }
      return {cell,map};
    }
    function neighbors(grid, x,y,z){
      const c=grid.cell; const ix=Math.floor(x/c), iy=Math.floor(y/c), iz=Math.floor(z/c);
      const res=[]; for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++) for(let dz=-1;dz<=1;dz++){
        const k=(ix+dx)+"|"+(iy+dy)+"|"+(iz+dz); if(grid.map.has(k)) res.push(...grid.map.get(k)); }
      return res;
    }
    function scorePose(A,B,contactCut,clashFactor,wContact,wClash,soft){
      const grid = makeGrid(A, contactCut);
      let contacts=0, clashPenalty=0;
      for(let i=0;i<B.length;i++){
        const x=B[i].x, y=B[i].y, z=B[i].z; const elemB=(B[i].elem||'C').toUpperCase();
        const cand = neighbors(grid,x,y,z);
        for(const j of cand){
          const ax=A[j].x, ay=A[j].y, az=A[j].z; const elemA=(A[j].elem||'C').toUpperCase();
          const dx=x-ax, dy=y-ay, dz=z-az; const d2=dx*dx+dy*dy+dz*dz; if (d2===0) { clashPenalty += wClash; continue; }
          const d=Math.sqrt(d2);
          const rv = (vdw[elemA]||1.7) + (vdw[elemB]||1.7);
          const clashCut = clashFactor * rv;
          if (d<=clashCut){
            const over = (clashCut - d + 1e-6)/(clashCut);
            clashPenalty += wClash * over * (1.0/(1.0+soft*over));
          } else if (d<=contactCut){
            contacts += 1.0;
          }
        }
      }
      return {score: contacts - clashPenalty, contacts, clash: clashPenalty};
    }
    self.onmessage = (e)=>{
      const {Apts, Bpts, params, start, end} = e.data;
      const rng = rand(params.seed + start*1337);
      let best=[];
      const total=end-start;
      for (let k=0;k<total;k++){
        const q = randomQuat(rng);
        const tx = (rng()*2-1)*params.maxTrans, ty=(rng()*2-1)*params.maxTrans, tz=(rng()*2-1)*params.maxTrans;
        const Bt = translate(rotatePoints(Bpts, q), {x:tx,y:ty,z:tz});
        const sc = scorePose(Apts, Bt, params.contactCut, params.clashFactor, params.wContact, params.wClash, params.soft);
        best.push({score:sc.score, contacts:sc.contacts, clash:sc.clash, q:[q[0],q[1],q[2],q[3]], t:{x:tx,y:ty,z:tz}});
        if (k%1000===0) self.postMessage({type:"progress", k});
      }
      best.sort((a,b)=>b.score-a.score);
      self.postMessage({type:"done", list: best.slice(0, Math.min(200, total))});
    }
  `;
  const blob = new Blob([src], {type:'application/javascript'});
  return new Worker(URL.createObjectURL(blob));
}
function angleBetweenQuats(q1,q2){
  const dot = q1[0]*q2[0]+q1[1]*q2[1]+q1[2]*q2[2]+q1[3]*q2[3];
  return 2*Math.acos(Math.min(1,Math.abs(dot))) * 180/Math.PI;
}
function diverseTop(sorted, dupAngDeg, dupTransA){
  const out=[];
  for (const p of sorted){
    let dup=false;
    for (const q of out){
      const ad = angleBetweenQuats(p.q, q.q);
      const td = Math.hypot(p.t.x-q.t.x, p.t.y-q.t.y, p.t.z-q.t.z);
      if (ad<=dupAngDeg && td<=dupTransA){ dup=true; break; }
    }
    if (!dup) out.push(p);
    if (out.length>=parseInt(document.getElementById('topN').value)) break;
  }
  return out;
}

/* ========================= Docking driver ========================= */
async function runDocking(){
  if (inProgress) return;
  cancelled=false; inProgress=true;
  const btn = document.getElementById('dockBtn'); const cancelBtn=document.getElementById('cancelBtn');
  btn.disabled=true; cancelBtn.disabled=false; btn.textContent="Running‚Ä¶";
  posesTop=[]; heavyUsed=false; currentContacts=[]; currentHB=[]; currentSB=[];
  document.getElementById('poseControls').innerHTML="";
  document.getElementById('scoreBox').textContent="";
  setProgress(0); status('loading');
  try{
    await loadInputs();

    const params = {
      samples: parseInt(document.getElementById('samples').value),
      maxTrans: parseFloat(document.getElementById('maxTrans').value),
      contactCut: parseFloat(document.getElementById('contactCut').value),
      clashFactor: parseFloat(document.getElementById('clashFactor').value),
      wContact: parseFloat(document.getElementById('wContact').value),
      wClash: parseFloat(document.getElementById('wClash').value),
      soft: parseFloat(document.getElementById('soft').value),
      topN: Math.max(1, parseInt(document.getElementById('topN').value)),
      seed: parseInt(document.getElementById('seed').value)||42,
      atomMode: document.getElementById('atomMode').value,
      rescoreMode: document.getElementById('rescoreMode').value
    };
    const dupAng = parseFloat(document.getElementById('dupAngle').value)||10;
    const dupTrans = parseFloat(document.getElementById('dupTrans').value)||2;

    // prepare reduced atom sets
    let Apts = selectAtomSet(pdbAAtoms, params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
    let Bpts = selectAtomSet(pdbBAtoms, params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
    if (!Apts.length || !Bpts.length) throw new Error("No atoms selected with current atom mode.");
    const cA = centroid(Apts), cB = centroid(Bpts);
    Apts = translate(Apts, {x:-cA.x,y:-cA.y,z:-cA.z});
    Bpts = translate(Bpts, {x:-cB.x,y:-cB.y,z:-cB.z});
    status('sampling');

    // worker pool
    const cores = Math.max(1, (navigator.hardwareConcurrency||4)-1);
    const poolSize = Math.min(cores, 8);
    const per = Math.floor(params.samples / poolSize);
    const extra = params.samples % poolSize;
    let done=0, lists=[];
    workerPool = [];
    for (let i=0;i<poolSize;i++){
      const start = i*per + Math.min(i, extra);
      const end = start + per + (i<extra?1:0);
      const w = makeDockWorker(); workerPool.push(w);
      w.onmessage = (e)=>{
        if (cancelled) return;
        const msg = e.data;
        if (msg.type==="progress"){
          done += 1000; setProgress(Math.min(1, done/params.samples));
          status(`scan ${Math.min(done,params.samples)}/${params.samples}`);
        }
        if (msg.type==="done"){
          lists.push(msg.list);
          w.terminate();
          if (lists.length===poolSize){
            // merge and sort
            let merged = lists.flat();
            merged.sort((a,b)=>b.score-a.score);
            // diversity filter
            const diverse = diverseTop(merged, dupAng, dupTrans);

            resolveAfterSampling(diverse, params);
          }
        }
      };
      w.onerror = err=>{ console.error(err); w.terminate(); };
      w.postMessage({Apts, Bpts, params, start, end});
    }

  }catch(e){
    alert(e.message||e);
    status('error');
    inProgress=false;
  }finally{
    // buttons reset handled in resolveAfterSampling/cancelDocking
  }
}

function cancelDocking(){
  cancelled=true;
  workerPool.forEach(w=>{try{w.terminate();}catch{}});
  workerPool=[];
  status('cancelled'); setProgress(0);
  const btn = document.getElementById('dockBtn'); const cancelBtn=document.getElementById('cancelBtn');
  btn.disabled=false; cancelBtn.disabled=true; btn.textContent="‚ñ∂Ô∏è Run Docking";
  inProgress=false;
}

async function resolveAfterSampling(diverse, params){
  if (cancelled){ cancelDocking(); return; }
  status(params.rescoreMode==="NONE" ? 'ranking' : (params.rescoreMode==="HEAVY"?'rescore':'refine'));

  // Heavy sets for postprocessing
  const Aheavy = translate(selectAtomSet(pdbAAtoms,'HEAVY').map(a=>({...a})), {x:-centroid(pdbAAtoms).x, y:-centroid(pdbAAtoms).y, z:-centroid(pdbAAtoms).z});
  const Bheavy0 = translate(selectAtomSet(pdbBAtoms,'HEAVY').map(a=>({...a})), {x:-centroid(pdbBAtoms).x, y:-centroid(pdbBAtoms).y, z:-centroid(pdbBAtoms).z});

  let top = diverse;
  if (params.rescoreMode!=="NONE"){
    top = await heavyRescore(Aheavy, Bheavy0, params, top, params.rescoreMode==="HEAVY_REFINE");
    heavyUsed=true;
  } else {
    heavyUsed=false;
  }
  posesTop = top;

  // Keep references for rendering
  currentA = Aheavy;
  currentB0 = Bheavy0;

  buildPoseButtons(top);
  if (top.length>0) document.querySelector('#poseControls button.btn[data-rank="1"]')?.click();

  // finalize
  const btn = document.getElementById('dockBtn'); const cancelBtn=document.getElementById('cancelBtn');
  btn.disabled=false; cancelBtn.disabled=true; btn.textContent="‚ñ∂Ô∏è Run Docking";
  status('done'); setProgress(1);
  inProgress=false;
}

/* ========================= Heavy re-score (+refine) ========================= */
function heavyRescore(Aheavy, Bheavy0, params, topCoarse, refine=false){
  const contactCut = params.contactCut, clashFactor=params.clashFactor, wContact=params.wContact, wClash=params.wClash, soft=params.soft;
  function score(A,B){
    let contacts=0, clashPenalty=0;
    for (let i=0;i<B.length;i++){
      const x=B[i].x, y=B[i].y, z=B[i].z; const elemB=(B[i].elem||'C').toUpperCase();
      for (let j=0;j<A.length;j++){
        const ax=A[j].x, ay=A[j].y, az=A[j].z; const elemA=(A[j].elem||'C').toUpperCase();
        const dx=x-ax, dy=y-ay, dz=z-az; const d2=dx*dx+dy*dy+dz*dz; const d=Math.sqrt(d2);
        const rv=(vdw[elemA]||1.7)+(vdw[elemB]||1.7); const clashCut=clashFactor*rv;
        if (d<=clashCut){
          const over = (clashCut - d + 1e-6)/(clashCut);
          clashPenalty += wClash * over * (1.0/(1.0+soft*over));
        } else if (d<=contactCut){ contacts += 1.0; }
      }
    }
    return {score:contacts - clashPenalty, contacts, clash:clashPenalty};
  }
  function applyTransform(points, q, t){
    const [x,y,z,w]=q;
    return points.map(p=>{
      const vx=p.x, vy=p.y, vz=p.z;
      const ix =  w*vx + y*vz - z*vy; const iy =  w*vy + z*vx - x*vz; const iz =  w*vz + x*vy - y*vx; const iw = -x*vx - y*vy - z*vz;
      const ox = ix*w + iw*(-x) + iy*(-z) - iz*(-y);
      const oy = iy*w + iw*(-y) + iz*(-x) - ix*(-z);
      const oz = iz*w + iw*(-z) + ix*(-y) - iy*(-x);
      return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name};
    });
  }
  function jiggle(p){ // micro-refine transform
    const j=0.5;
    const r=()=> (Math.random()*2-1)*j;
    const dq = [p.q[0]+r()*0.01, p.q[1]+r()*0.01, p.q[2]+r()*0.01, p.q[3]+r()*0.01];
    const norm = Math.hypot(dq[0],dq[1],dq[2],dq[3]); for(let i=0;i<4;i++) dq[i]/=norm;
    const dt = {x:p.t.x+r(), y:p.t.y+r(), z:p.t.z+r()};
    return {q:dq, t:dt};
  }

  const rescored = [];
  for (const p of topCoarse){
    let best = {...p};
    let Bcur = applyTransform(Bheavy0, p.q, p.t);
    let sc = score(Aheavy, Bcur);
    best.score=sc.score; best.contacts=sc.contacts; best.clash=sc.clash;
    if (refine){
      for (let i=0;i<50;i++){
        const jt = jiggle(best);
        const Btry = applyTransform(Bheavy0, jt.q, jt.t);
        const sc2 = score(Aheavy, Btry);
        if (sc2.score>best.score){ best.q=jt.q; best.t=jt.t; best.score=sc2.score; best.contacts=sc2.contacts; best.clash=sc2.clash; }
      }
    }
    rescored.push(best);
  }
  rescored.sort((a,b)=>b.score-a.score);
  return rescored.slice(0, parseInt(document.getElementById('topN').value));
}

/* ========================= Pose rendering & overlays ========================= */
function buildPoseButtons(top){
  const pc = document.getElementById('poseControls'); pc.innerHTML="";
  top.forEach((p, idx)=>{
    const btn = document.createElement('button');
    btn.className="btn"; btn.dataset.rank=(idx+1);
    btn.textContent = `Pose ${idx+1}  (S=${p.score.toFixed(1)}, C=${p.contacts|0}, X=${p.clash.toFixed(1)})`;
    btn.onclick = ()=> showPose(idx);
    pc.appendChild(btn);

    const dbtn = document.createElement('button');
    dbtn.className="btn green"; dbtn.textContent="‚¨á PDB"; dbtn.style.marginLeft="6px";
    dbtn.onclick = ()=> downloadPose(idx);
    pc.appendChild(dbtn);
  });
}
function showPose(i){
  currentPose = posesTop[i];
  const Bshow = applyTransform(currentB0, currentPose.q, currentPose.t);
  // base render
  viewer.clear();
  viewer.addModel(formatPDB(currentA), "pdb"); viewer.setStyle({model:0},{cartoon:{colorscheme:"Chain"}});
  viewer.addModel(formatPDB(Bshow,1), "pdb"); viewer.setStyle({model:1},{cartoon:{color:"#f97316"}});
  viewer.zoomTo();

  // compute metrics
  const cut = parseFloat(document.getElementById('contactCut').value);
  const metrics = computeInterfaceMetrics(currentA, Bshow, cut);
  currentContacts = metrics.contactsPairs;
  currentHB = metrics.hbPairs;
  currentSB = metrics.sbPairs;

  refreshOverlays();
  const kElec = parseFloat(document.getElementById('kElec').value)||0.5;
  const elecCut = parseFloat(document.getElementById('elecCut').value)||12;
  const Eelec = coulombResidueEnergy(currentA, Bshow, kElec, elecCut);
  const BSA = metrics.contacts * 10.0; // proxy 10 √Ö¬≤/contact

  const enthalpyProxy = (metrics.contacts) - (metrics.clash) + (metrics.hb*0.5) + (metrics.sb*1.0) - (Eelec); // arbitrary weights
  document.getElementById('scoreBox').textContent =
    `Pose ${i+1} ‚Äî Score=${currentPose.score.toFixed(2)}  Contacts=${metrics.contacts}  Clash=${metrics.clash.toFixed(2)}  `+
    `HB=${metrics.hb}  SB=${metrics.sb}  Hydrophobics=${metrics.hydrophobics}  BSA‚âà${BSA.toFixed(0)} √Ö¬≤  `+
    `Electrostatics‚âà${Eelec.toFixed(2)}  Pseudo-enthalpy‚âà${enthalpyProxy.toFixed(2)}`;
  viewer.render();
}
function refreshOverlays(){
  if (!currentPose) return;
  viewer.removeAllShapes();
  const showC = document.getElementById('toggleContacts').checked;
  const showH = document.getElementById('toggleHB').checked;
  const showS = document.getElementById('toggleSB').checked;
  if (showC) drawPairs(currentContacts, "#60a5fa");
  if (showH) drawPairs(currentHB, "#34d399");
  if (showS) drawPairs(currentSB, "#f87171");
  viewer.render();
}
function drawPairs(pairs, color){
  pairs.slice(0,400).forEach(pr=>{
    viewer.addLine({start:{x:pr.x1,y:pr.y1,z:pr.z1},end:{x:pr.x2,y:pr.y2,z:pr.z2}, dashed:true, dashLength:0.5, color, linewidth:2});
  });
}

/* ========================= Interface metrics ========================= */
const hydrophobic = new Set(['ALA','VAL','LEU','ILE','PRO','PHE','MET','TRP','TYR','CYS']);
function computeInterfaceMetrics(A,B,contactCut){
  let contacts=0, clash=0, hb=0, sb=0, hyd=0;
  const contactsPairs=[], hbPairs=[], sbPairs=[];
  for (const b of B){
    for (const a of A){
      const dx=b.x-a.x, dy=b.y-a.y, dz=b.z-a.z; const d2=dx*dx+dy*dy+dz*dz; const d=Math.sqrt(d2);
      // clashes (vdW-aware)
      const rv=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7);
      const clashCut = parseFloat(document.getElementById('clashFactor').value) * rv;
      if (d<=clashCut){ const over=(clashCut-d+1e-6)/clashCut; clash += 6.0*over*(1/(1+0.5*over)); }
      // contacts
      if (d<=contactCut){ contacts++; contactsPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
      // H-bonds proxy
      const aN = a.name?.trim().startsWith('N'); const bO = b.name?.trim().startsWith('O');
      const aO = a.name?.trim().startsWith('O'); const bN = b.name?.trim().startsWith('N');
      if ((aN && bO || aO && bN) && d<=3.5){ hb++; hbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
      // salt bridges
      const acid = (x)=> (x.resn==='ASP' && x.name.startsWith('OD')) || (x.resn==='GLU' && x.name.startsWith('OE'));
      const base = (x)=> (x.resn==='LYS' && x.name==='NZ') || (x.resn==='ARG' && (x.name==='NH1'||x.name==='NH2'||x.name==='NE')) || (x.resn==='HIS' && (x.name==='ND1'||x.name==='NE2'));
      if ( (acid(a)&&base(b) || acid(b)&&base(a)) && d<=4.0){ sb++; sbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
      // hydrophobic
      if (hydrophobic.has(a.resn) && hydrophobic.has(b.resn) && (a.elem==='C'||b.elem==='C') && d<=4.5) hyd++;
    }
  }
  return {contacts, clash, hb, sb, hydrophobics:hyd, contactsPairs, hbPairs, sbPairs};
}

/* ========================= Electrostatics (residue-level) ========================= */
function residueCharges(atoms){
  const charges=new Map(); // key chain:resi -> {x,y,z,q}
  const qByResn={ASP:-1, GLU:-1, LYS:+1, ARG:+1, HIS:+0.1};
  const pos=new Map();
  for (const a of atoms){
    const key=a.chain+':'+a.resi;
    if (!pos.has(key)) pos.set(key, []);
    pos.get(key).push(a);
  }
  for (const [key, arr] of pos.entries()){
    const resn = arr[0].resn || 'UNK';
    const q = qByResn[resn]||0;
    if (q!==0){
      // use CA if available else centroid
      let ca = arr.find(x=>x.name==='CA');
      let x,y,z;
      if (ca) { x=ca.x;y=ca.y;z=ca.z; }
      else {
        let sx=0,sy=0,sz=0; for (const a of arr){sx+=a.x;sy+=a.y;sz+=a.z}
        x=sx/arr.length; y=sy/arr.length; z=sz/arr.length;
      }
      charges.set(key, {x,y,z,q, resn, chain:arr[0].chain, resi:arr[0].resi});
    }
  }
  return Array.from(charges.values());
}
function coulombResidueEnergy(A,B,k=0.5,cut=12){
  const cA = residueCharges(A), cB = residueCharges(B);
  let e=0, cut2=cut*cut;
  for (const a of cA){
    for (const b of cB){
      const dx=a.x-b.x, dy=a.y-b.y, dz=a.z-b.z; const d2=dx*dx+dy*dy+dz*dz;
      if (d2>cut2) continue;
      const d = Math.sqrt(d2)+1e-3;
      e += k * (a.q*b.q)/d;
    }
  }
  return e;
}

/* ========================= Downloads & snapshots ========================= */
function downloadPose(rankIdx){
  const p = posesTop[rankIdx];
  const Aout = currentA;
  const Bout = applyTransform(currentB0, p.q, p.t);
  const pdbOut = formatPDB(Aout) + "\n" + formatPDB(Bout,1);
  downloadBlob(pdbOut, `pose_${rankIdx+1}.pdb`);
}
function downloadAllPoses(){
  if (!posesTop.length){ alert("No poses yet."); return; }
  let out=[];
  posesTop.forEach((p, i)=>{
    out.push(`MODEL     ${i+1}`);
    out.push(formatPDB(currentA));
    out.push(formatPDB(applyTransform(currentB0,p.q,p.t),1));
    out.push("ENDMDL");
  });
  out.push("END");
  downloadBlob(out.join("\n"), "top_poses.pdb");
}
function downloadCSV(){
  if (!posesTop.length){ alert("No poses yet."); return; }
  const rows = ["rank,score,contacts,clash,qx,qy,qz,qw,tx,ty,tz"];
  posesTop.forEach((p,i)=>rows.push([i+1,p.score,p.contacts,p.clash,p.q[0],p.q[1],p.q[2],p.q[3],p.t.x,p.t.y,p.t.z].join(",")));
  downloadBlob(rows.join("\n"), "poses_summary.csv");
}
function downloadJSON(){
  if (!posesTop.length){ alert("No poses yet."); return; }
  const kElec = parseFloat(document.getElementById('kElec').value)||0.5;
  const elecCut = parseFloat(document.getElementById('elecCut').value)||12;
  const cut = parseFloat(document.getElementById('contactCut').value);
  const report = posesTop.map((p,i)=>{
    const Bout = applyTransform(currentB0, p.q, p.t);
    const m = computeInterfaceMetrics(currentA, Bout, cut);
    return {
      rank:i+1, score:p.score, contacts:m.contacts, clash:m.clash, hb:m.hb, sb:m.sb, hydrophobic:m.hydrophobics,
      BSA_proxy_A2: m.contacts*10.0,
      electrostatics: coulombResidueEnergy(currentA, Bout, kElec, elecCut),
      transform:{q:p.q, t:p.t}
    };
  });
  downloadBlob(JSON.stringify(report,null,2), "interface_report.json");
}
function snapshotPNG(){
  viewer.pngURI(function(uri){ const a=document.createElement('a'); a.href=uri; a.download="viewer.png"; a.click(); });
}
function downloadBlob(text, name){
  const blob = new Blob([text], {type:"text/plain"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download=name; a.click();
  setTimeout(()=>URL.revokeObjectURL(url),0);
}

/* ========================= Transforms used in rendering ========================= */
function applyTransform(points, q, t){
  const [x,y,z,w]=q;
  return points.map(p=>{
    const vx=p.x, vy=p.y, vz=p.z;
    const ix =  w*vx + y*vz - z*vy; const iy =  w*vy + z*vx - x*vz; const iz =  w*vz + x*vy - y*vx; const iw = -x*vx - y*vy - z*vz;
    const ox = ix*w + iw*(-x) + iy*(-z) - iz*(-y);
    const oy = iy*w + iw*(-y) + iz*(-x) - ix*(-z);
    const oz = iz*w + iw*(-z) + ix*(-y) - iy*(-x);
    return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name};
  });
}

/* ========================= Sequence ‚Üí PDB ========================= */
const aa3 = {'A':'ALA','R':'ARG','N':'ASN','D':'ASP','C':'CYS','E':'GLU','Q':'GLN','G':'GLY','H':'HIS','I':'ILE','L':'LEU','K':'LYS','M':'MET','F':'PHE','P':'PRO','S':'SER','T':'THR','W':'TRP','Y':'TYR','V':'VAL'};
function loadFASTA(){
  const f = document.getElementById('fastaFile').files[0];
  if (!f) return alert("Choose a FASTA file first.");
  f.text().then(txt=>{
    const seq = txt.split(/\r?\n/).filter(l=>!l.startsWith('>')).join('');
    document.getElementById('seqInput').value = seq;
  });
}
function cleanSequence(raw){ return (raw||"").toUpperCase().replace(/[^A-Z]/g,'').replace(/[^ARNDCEQGHILKMFPSTWYV]/g,'X'); }
function buildFromCA(ca, chain, start, atomsMode){
  const out=[]; const add=(x,y,z,name,resn,resi)=>out.push({x,y,z,name,elem:name.trim()==='O'?'O':name.trim()==='N'?'N':'C',resn,chain,resi});
  for (let i=0;i<ca.length;i++){
    const resi=start+i; const resn='ALA'; // will swap later
    const c=ca[i], prev=ca[Math.max(0,i-1)], next=ca[Math.min(ca.length-1,i+1)];
    const tx=next.x-prev.x, ty=next.y-prev.y, tz=next.z-prev.z; const tlen=Math.hypot(tx,ty,tz)||1; const ux=tx/tlen, uy=ty/tlen, uz=tz/tlen;
    const nx=-uy, ny=ux, nz=0;
    if (atomsMode==='BB') add(c.x-1.33*ux, c.y-1.33*uy, c.z-1.33*uz, " N  ", resn, resi);
    add(c.x, c.y, c.z, " CA ", resn, resi);
    if (atomsMode==='BB'){
      add(c.x+1.52*ux, c.y+1.52*uy, c.z+1.52*uz, " C  ", resn, resi);
      add(c.x+2.30*ux+0.5*nx, c.y+2.30*uy+0.5*ny, c.z+2.30*uz+0.5*nz, " O  ", resn, resi);
    }
  }
  return out;
}
function helixCA(seq, radius, rise){
  const ca=[]; const turnDeg=100.0;
  for (let i=0;i<seq.length;i++){ const ang=i*turnDeg*Math.PI/180.0; ca.push({x:radius*Math.cos(ang),y:radius*Math.sin(ang),z:i*rise}); }
  return ca;
}
function strandCA(seq){ const ca=[]; for (let i=0;i<seq.length;i++){ const dir=(i%2===0?1:-1); ca.push({x:i*3.5,y:dir*1.2,z:0}); } return ca; }
function coilCA(seq){ const ca=[]; let x=0,y=0,z=0; for (let i=0;i<seq.length;i++){ x+=(Math.random()*2-1)*2.5; y+=(Math.random()*2-1)*2.5; z+=3.2; ca.push({x,y,z}); } return ca; }
function seqToPDB(opts){
  const {rawSeq, chain, start, atomsMode, preset, radius, rise} = opts;
  const seq = cleanSequence(rawSeq); if (!seq) throw new Error("Enter a valid sequence.");
  let ca; if (preset==='HELIX') ca=helixCA(seq, radius, rise); else if (preset==='STRAND') ca=strandCA(seq); else ca=coilCA(seq);
  const bb = buildFromCA(ca, chain, start, atomsMode);
  // swap residue names to actual ones per residue
  let idx=0; for (let i=0;i<bb.length;i++){ const step=(atomsMode==='BB'? (bb[i].name.trim()==='N'||bb[i].name.trim()==='CA'||bb[i].name.trim()==='C'||bb[i].name.trim()==='O') : bb[i].name.trim()==='CA'); if (step){ bb[i].resn = aa3[seq[idx]]||'UNK'; if (bb[i].name.trim()==='O'||bb[i].name.trim()==='N'||bb[i].name.trim()==='C'){}; if (bb[i].name.trim()==='CA') idx++; } }
  return formatPDB(bb);
}
function seqPreview(){
  const opts = {
    rawSeq: document.getElementById('seqInput').value,
    chain: (document.getElementById('seqChain').value||"A").charAt(0).toUpperCase(),
    start: parseInt(document.getElementById('seqStart').value)||1,
    atomsMode: document.getElementById('seqAtoms').value,
    preset: document.getElementById('ssPreset').value,
    radius: parseFloat(document.getElementById('seqRadius').value)||2.3,
    rise: parseFloat(document.getElementById('seqRise').value)||1.5,
  };
  try{
    const pdb = seqToPDB(opts);
    seqViewer.clear(); seqViewer.addModel(pdb,"pdb");
    seqViewer.setStyle({cartoon:{color:"#60a5fa"}}); seqViewer.zoomTo(); seqViewer.render();
  }catch(e){ alert(e.message||e); }
}
function seqDownload(){
  const opts = {
    rawSeq: document.getElementById('seqInput').value,
    chain: (document.getElementById('seqChain').value||"A").charAt(0).toUpperCase(),
    start: parseInt(document.getElementById('seqStart').value)||1,
    atomsMode: document.getElementById('seqAtoms').value,
    preset: document.getElementById('ssPreset').value,
    radius: parseFloat(document.getElementById('seqRadius').value)||2.3,
    rise: parseFloat(document.getElementById('seqRise').value)||1.5,
  };
  try{ const pdb = seqToPDB(opts); const fn=document.getElementById('seqFilename').value||"sequence_model.pdb"; downloadBlob(pdb, fn); }catch(e){ alert(e.message||e); }
}

/* ========================= Init ========================= */
initViewers();
</script>
</body>
</html>
