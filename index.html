<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Comprehensive Docking & Antibody Design Suite • Student Edition</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0f172a" />
<meta name="description" content="In-browser antibody design (CDR, scaffold) and molecular docking (antibody–antigen, ligand screening, CDR mapping), 3D visualization, and analysis." />

<script defer src="https://unpkg.com/3dmol@2.4.2/build/3Dmol-min.js"></script>
<script defer src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>
<script defer src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>

<style>
  :root{
    --bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#9ca3af;--accent:#7dd3fc;--line:#1f2937;
    --green:#34d399;--red:#f87171;--yellow:#fbbf24;--orange:#fb923c;--purple:#a78bfa;
    --mono:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;--sans:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans);line-height:1.6}
  a{color:var(--accent);text-decoration:none}
  header{padding:34px 16px;background:radial-gradient(1200px 600px at 15% -10%,#1d2a4a,transparent 60%),radial-gradient(1000px 500px at 120% 10%,#2a1e4a,transparent 60%)}
  .wrap{max-width:1400px;margin:0 auto}
  h1{margin:0 0 8px;font-size:30px;font-weight:800}
  .byline{color:#93c5fd;font-weight:700;margin-top:6px}
  h2{margin:0 0 10px;font-size:22px;font-weight:700}
  h3{margin:14px 0 6px;font-size:17px;font-weight:700}
  h4{margin:14px 0 6px;font-size:15px;font-weight:700}
  p.lead{color:var(--muted);margin:6px 0 0;font-size:14px}
  section{padding:22px 16px;border-top:1px solid var(--line);background:var(--panel)}
  .card{background:#0b1220;border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:12px}
  .grid{display:grid;gap:16px}
  @media(min-width:980px){.grid.two{grid-template-columns:1.05fr .95fr}}
  @media(min-width:1100px){.grid.three{grid-template-columns:repeat(3,1fr)}}
  @media(min-width:1200px){.grid.four{grid-template-columns:repeat(4,1fr)}}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{font-weight:700;font-size:13px}
  input[type=number],input[type=text],input[type=file],textarea,select{background:#0a0f1a;color:var(--text);border:1px solid #1f2937;border-radius:8px;padding:8px 10px;font-family:var(--mono);font-size:13px;min-width:80px;width:100%}
  textarea{width:100%;min-height:110px;resize:vertical}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:9px 12px;border-radius:10px;font-weight:700;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:13px;transition:.2s;color:var(--text)}
  .btn:hover:not([disabled]){transform:translateY(-1px);box-shadow:0 6px 16px rgba(125,211,252,.25);color:var(--text)}
  .btn.primary{background:linear-gradient(180deg,#2563eb,#1e40af);border:0;color:white}
  .btn.green{background:linear-gradient(180deg,#059669,#047857);border:0;color:white}
  .btn.red{background:linear-gradient(180deg,#dc2626,#b91c1c);border:0;color:white}
  .btn.purple{background:linear-gradient(180deg,#7c3aed,#6d28d9);border:0;color:white}
  .btn.orange{background:linear-gradient(180deg,#fb923c,#f97316);border:0;color:white}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .btn-group{display:flex;gap:1rem;flex-wrap:wrap}
  .pill{padding:2px 8px;border:1px solid #334155;border-radius:999px;font-size:12px;color:#93c5fd;font-weight:800;display:inline-block;}
  .pill-green{color:var(--green);border-color:var(--green);}
  .pill-purple{color:var(--purple);border-color:var(--purple);}
  progress{width:260px;height:10px;border:1px solid var(--line);border-radius:999px;background:#0b1220}
  progress::-webkit-progress-value{background:#7dd3fc;border-radius:999px;transition:width .3s}
  .infobox{border:1px solid #334155;border-left:4px solid var(--accent);border-radius:10px;padding:10px;background:#0a0f1a;color:#cbd5e1;margin:10px 0;font-size:13px}
  .errorbox{border:1px solid #7f1d1d;border-left:4px solid #dc2626;border-radius:10px;padding:10px;background:#1a0c0c;color:#fecaca;margin:10px 0}
  .successbox{border:1px solid #065f46;border-left:4px solid #10b981;border-radius:10px;padding:10px;background:#0a1f1a;color:#a7f3d0;margin:10px 0}
  .score{font-family:var(--mono);background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:8px;overflow:auto;font-size:12px;line-height:1.5;white-space:pre-wrap}
  .chainchips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{border:1px solid #334155;border-radius:999px;padding:2px 8px;display:inline-flex;align-items:center;gap:6px;font-size:13px}
  .chip input{accent-color:#7dd3fc;width:auto;min-width:auto;}
  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .tabbtn{padding:8px 12px;border-radius:999px;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:14px;font-weight:800;transition:.2s;color:var(--text)}
  .tabbtn:hover{background:#152034}
  .tabbtn.active{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0;color:#fff}
  .tabsec{display:none}
  .tabsec.active{display:block}
  .table{width:100%;border-collapse:collapse;font-size:13px;background:#0a0f1a}
  .table th{background:#152034;padding:8px;text-align:left;border-bottom:2px solid var(--line);position:sticky;top:0;z-index:1}
  .table td{padding:6px 8px;border-bottom:1px solid #112033}
  .table tr:hover{background:#0f1829}
  .table-container{max-height:460px;overflow:auto;border:1px solid var(--line);border-radius:8px;margin-top:8px}
  #viewer,#viewerLig,#viewerScr,#viewerComp,#viewerCDR,#viewerDesign{position:relative;width:100%;height:560px;border:1px solid var(--line);border-radius:10px;background:#0a0f1a;overflow:hidden}
  .metric-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin:10px 0}
  .metric-card{background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:10px;text-align:center}
  .metric-value{font-size:20px;font-weight:800;color:var(--accent)}
  .metric-label{font-size:12px;color:var(--muted)}
  footer{padding:18px 16px;color:#9ca3af;text-align:center;font-size:13px}
  .small{font-size:12px}
  .guide{display:grid;gap:8px;margin-top:12px}
  .step{background:#0a0f1a;border:1px dashed #334155;border-radius:10px;padding:10px}
  #nmrMoleculeImage { min-height: 200px; background-size: contain; background-position: center; background-repeat: no-repeat; border-radius: 8px; border: 1px solid var(--line); margin-bottom: 12px; }
  .topbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px}
  .kbd{font-family:var(--mono);background:#111827;border:1px solid #374151;border-radius:6px;padding:2px 6px;font-size:12px}
  [aria-live]{min-width:40px}
  .scheme-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;margin-top:10px}
  .scheme-card{background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:8px}
  .cdr-highlight{background:#1e293b;border-left:3px solid var(--accent);padding:6px 8px;margin:6px 0;border-radius:6px}
  .cdr-region{font-family:var(--mono);font-size:11px;color:#fbbf24;background:#1a1a2e;padding:2px 4px;border-radius:4px;margin:2px}
  
  /* === Styles for Antibody Designer components === */
  .ig-selector { display: grid; grid-template-columns: repeat(5, 1fr); gap: 1rem; margin: 1.5rem 0; }
  .ig-option { padding: 1rem; background: var(--panel); border: 2px solid var(--line); border-radius: 12px; cursor: pointer; text-align: center; transition: all 0.3s; }
  .ig-option:hover { border-color: var(--accent); transform: translateY(-2px); }
  .ig-option.selected { background: #152034; border-color: var(--green); }
  .ig-option h3 { margin: 0; color: var(--accent); font-size: 1.5rem; }
  .ig-option p { margin: 0.5rem 0 0; font-size: 0.85rem; color: var(--muted); }
  .cdr-panel { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem; }
  .cdr-item { background: var(--bg); padding: 1rem; border-radius: 8px; border: 1px solid var(--line); }
  .cdr-label { font-weight: 600; color: var(--green); margin-bottom: 0.5rem; font-size: 0.9rem; }
  .cdr-sequence { font-family: var(--mono); font-size: 1.1rem; color: var(--text); letter-spacing: 1px; word-break: break-all; }
  .affinity-meter { margin: 1rem 0; }
  .meter-bar { height: 30px; background: var(--bg); border: 1px solid var(--line); border-radius: 15px; overflow: hidden; position: relative; }
  .meter-fill { height: 100%; background: linear-gradient(90deg, #2563eb, #7dd3fc); transition: width 0.5s ease; display: flex; align-items: center; justify-content: flex-end; padding-right: 1rem; }
  .meter-value { color: white; font-weight: 600; font-size: 0.9rem; }
  .viewer-controls { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 10px; }
  .result-item { display: flex; justify-content: space-between; padding: 0.75rem 0; border-bottom: 1px solid var(--line); }
  .result-label { color: var(--muted); font-weight: 500; }
  .result-value { color: var(--green); font-weight: 600; font-family: var(--mono); }
  @media (max-width: 768px) {
    .ig-selector { grid-template-columns: repeat(2, 1fr); }
    .cdr-panel { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<header>
  <div class="wrap">
    <h1>🧬 Comprehensive Molecular Design & Docking Suite — <span style="color:#a7f3d0">Student Edition</span></h1>
    <div class="byline">by DJF — The New Chemist</div>
    <p class="lead">
      <b>Design:</b> Antibody CDR/scaffold generation • Epitope DB • Property prediction
      <b>Docking:</b> Antibody–antigen • Ligand screening
      <b>Analysis:</b> CDR mapping (Kabat/IMGT) • Pose clustering • ΔH estimation • QA
    </p>

    <div class="infobox" role="region" aria-label="Student guide">
      <b>Quick Start (Students):</b>
      <div class="guide">
        <div class="step">1) <b>Design an Ab</b> in <span class="kbd">🎨 Ab Design</span>: Pick a target (e.g., IgG), scaffold (e.g., scFv), and click <b>Generate Antibody</b>.</div>
        <div class="step">2) <b>Analyze CDRs</b> in <span class="kbd">🔬 CDR Analysis</span>: Paste a PDB to map its CDRs by Kabat/Chothia/IMGT.</div>
        <div class="step">3) <b>Dock Proteins</b> in <span class="kbd">🧷 Antibody Docking</span>: Load PDBs (or <em>Example</em>), <b>Parse</b>, and <b>Run Docking</b>.</div>
        <div class="step">4) <b>Explore Results</b>: Use the Complex picker, click pose buttons, and toggle overlays for contacts/H-bonds.</div>
        <div class="step">5) <b>Validate</b> all results with professional tools and experiments. This is an educational guide.</div>
      </div>
    </div>

    <div class="tabs" role="tablist">
      <button class="tabbtn active" data-tab="abDesignTab" role="tab">🎨 Ab Design</button>
      <button class="tabbtn" data-tab="epitopesTab" role="tab">🎯 Epitope DB</button>
      <button class="tabbtn" data-tab="dockTab" role="tab" aria-selected="true">🧷 Antibody Docking</button>
      <button class="tabbtn" data-tab="cdrTab" role="tab">🔬 CDR Analysis</button>
      <button class="tabbtn" data-tab="fragmentTab" role="tab">📐 Fragment Generator</button>
      <button class="tabbtn" data-tab="fragLibTab" role="tab">🧩 Fragment Library</button>
      <button class="tabbtn" data-tab="ligTab" role="tab">🧪 Ligand Docking</button>
      <button class="tabbtn" data-tab="screenTab" role="tab">📚 Batch Screening</button>
      <button class="tabbtn" data-tab="designAnalysisTab" role="tab">📈 Design Analysis</button>
      <button class="tabbtn" data-tab="analysisTab" role="tab">📊 Docking Analysis</button>
      <button class="tabbtn" data-tab="designExportTab" role="tab">💾 Design Export</button>
      <button class="tabbtn" data-tab="qaTab" role="tab">✅ QA & Registry</button>
      <button class="tabbtn" data-tab="omicsTab" role="tab">🔬 Omics Analysis</button>
      <button class="tabbtn" data-tab="nmrTab" role="tab">📡 NMR Prediction</button>
      <button class="tabbtn" data-tab="aboutTab" role="tab">ℹ️ About</button>
    </div>
    <div class="topbar">
      <button class="btn" id="btnDemo" title="Load small example proteins and run a quick docking">🎯 Load Docking Demo</button>
      <button class="btn green" id="btnSaveSession" title="Download a JSON snapshot of this session">💾 Save Session</button>
      <button class="btn purple" id="btnLoadSession" title="Load a previously saved session (.json)">📂 Load Session</button>
      <span class="pill" id="statusPill" aria-live="polite">idle</span>
      <progress id="prog" value="0" max="1" aria-label="progress"></progress>
    </div>
  </div>
</header>

<section id="abDesignTab" class="tabsec active" data-tab-panel>
  <div class="wrap grid two">
    <div>
      <div class="card">
        <h2>Select Target Immunoglobulin <span class="pill">Step 1</span></h2>
        
        <div class="ig-selector">
          <div class="ig-option" onclick="abDesign_selectIg('IgG')" id="ig-IgG">
            <h3>IgG</h3>
            <p>Most abundant<br>Therapeutic Abs</p>
          </div>
          <div class="ig-option" onclick="abDesign_selectIg('IgA')" id="ig-IgA">
            <h3>IgA</h3>
            <p>Mucosal immunity<br>Secretory</p>
          </div>
          <div class="ig-option" onclick="abDesign_selectIg('IgM')" id="ig-IgM">
            <h3>IgM</h3>
            <p>Pentameric<br>Complement</p>
          </div>
          <div class="ig-option" onclick="abDesign_selectIg('IgD')" id="ig-IgD">
            <h3>IgD</h3>
            <p>B cell receptor<br>Signaling</p>
          </div>
          <div class="ig-option" onclick="abDesign_selectIg('IgE')" id="ig-IgE">
            <h3>IgE</h3>
            <p>Allergic response<br>Mast cells</p>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top: 1.5rem;">
        <h2>Choose Scaffold Type <span class="pill">Step 2</span></h2>
        
        <div class="form-group">
          <select id="scaffold-type" onchange="abDesign_updateScaffoldInfo()">
            <option value="scFv">scFv - Single Chain Variable Fragment (27 kDa)</option>
            <option value="Fab">Fab - Fragment Antigen Binding (50 kDa)</option>
            <option value="IgG">Full IgG - Complete Antibody (150 kDa)</option>
            <option value="Bispecific">Bispecific - Dual Targeting (150 kDa)</option>
          </select>
        </div>
        
        <div id="scaffold-info" class="infobox" style="margin-top: 1rem; padding: 1rem;">
          </div>
      </div>
      
      <div class="card" style="margin-top: 1.5rem;">
          <h2>3D Structure Viewer</h2>
          <div class="viewer-controls">
            <button class="btn" onclick="abDesign_resetView()">Reset</button>
            <button class="btn" onclick="abDesign_toggleSpin()">Spin</button>
            <button class="btn" onclick="abDesign_changeStyle('cartoon')">Cartoon</button>
            <button class="btn" onclick="abDesign_changeStyle('stick')">Stick</button>
            <button class="btn" onclick="abDesign_changeStyle('sphere')">Sphere</button>
          </div>
        <div id="viewerDesign" style="height: 450px;"></div>
      </div>
    </div>

    <div>
      <div class="card">
        <h2>CDR Design <span class="pill pill-green">Auto-Generated</span></h2>
        
        <div class="cdr-panel" id="cdr-display">
          <div class="cdr-item">
            <div class="cdr-label">CDR H1</div>
            <div class="cdr-sequence" id="cdr-h1">GFTFSSY</div>
          </div>
          <div class="cdr-item">
            <div class="cdr-label">CDR H2</div>
            <div class="cdr-sequence" id="cdr-h2">ISGSGGST</div>
          </div>
          <div class="cdr-item">
            <div class="cdr-label">CDR H3</div>
            <div class="cdr-sequence" id="cdr-h3">AREGYCSSGSCYFD</div>
          </div>
          <div class="cdr-item">
            <div class="cdr-label">CDR L1</div>
            <div class="cdr-sequence" id="cdr-l1">QSISSY</div>
          </div>
          <div class="cdr-item">
            <div class="cdr-label">CDR L2</div>
            <div class="cdr-sequence" id="cdr-l2">AAS</div>
          </div>
          <div class="cdr-item">
            <div class="cdr-label">CDR L3</div>
            <div class="cdr-sequence" id="cdr-l3">QQYGSSPT</div>
          </div>
        </div>
        
        <div class="btn-group" style="margin-top: 1.5rem;">
          <button class="btn primary" onclick="abDesign_generateAntibody()">
            🧬 Generate Antibody
          </button>
          <button class="btn" onclick="abDesign_optimizeCDRs()">
            ⚡ Optimize CDRs
          </button>
        </div>
        
        <div class="btn-group" style="margin-top: 1rem; border-top: 1px solid var(--line); padding-top: 1rem;">
            <label class="chip">Highlight:</label>
            <button class="btn small" onclick="abDesign_highlightCDR('H1')">H1</button>
            <button class="btn small" onclick="abDesign_highlightCDR('H2')">H2</button>
            <button class="btn small" onclick="abDesign_highlightCDR('H3')">H3</button>
            <button class="btn small" onclick="abDesign_highlightCDR('L1')">L1</button>
            <button class="btn small" onclick="abDesign_highlightCDR('L2')">L2</button>
            <button class="btn small" onclick="abDesign_highlightCDR('L3')">L3</button>
        </div>
      </div>

      <div class="card" style="margin-top: 1.5rem;">
        <h2>Antigen C-Alpha Trace Input <span class="pill pill-green">Structure-Guided Design</span></h2>
        <p class="lead">Import target antigen C-alpha coordinates to guide CDR design based on epitope structure</p>
        
        <div style="margin-top: 1rem;">
          <label for="calpha-trace-input" style="display: block; margin-bottom: 0.5rem;">
            Paste Antigen C-Alpha Trace Coordinates
          </label>
          <textarea 
            id="calpha-trace-input" 
            placeholder="Format: X Y Z (one line per residue)&#10;Example:&#10;10.234 15.678 20.123&#10;11.456 16.789 21.234&#10;12.678 17.890 22.345&#10;...or paste PDB ATOM/HETATM lines with CA atoms"
            style="min-height: 180px; font-family: var(--mono); font-size: 12px;"
          ></textarea>
        </div>
        
        <div class="btn-group" style="margin-top: 1rem;">
          <button class="btn primary" onclick="abDesign_parseCAlphaTrace()">
            📍 Parse Antigen Structure
          </button>
          <button class="btn green" onclick="abDesign_designCDRsFromAntigen()">
            🧬 Design CDRs from Antigen
          </button>
          <button class="btn" onclick="abDesign_loadCAlphaFile()">
            📂 Load from File
          </button>
          <button class="btn" onclick="abDesign_clearCAlphaTrace()">
            🗑️ Clear
          </button>
        </div>
        <input type="file" id="calpha-file-input" accept=".pdb,.txt,.xyz" style="display: none;" onchange="abDesign_handleCAlphaFile(event)">
        
        <div id="calpha-status" class="infobox" style="margin-top: 1rem; display: none;">
          <strong>Status:</strong> <span id="calpha-status-text"></span>
        </div>
        
        <div id="calpha-stats" style="margin-top: 1rem; display: none;">
          <div class="result-item">
            <span class="result-label">Antigen Residues</span>
            <span class="result-value" id="calpha-count">0</span>
          </div>
          <div class="result-item">
            <span class="result-label">Chain Length (Å)</span>
            <span class="result-value" id="calpha-length">0.0</span>
          </div>
          <div class="result-item">
            <span class="result-label">Radius of Gyration</span>
            <span class="result-value" id="calpha-rg">0.0 Å</span>
          </div>
          <div class="result-item">
            <span class="result-label">Predicted Epitope</span>
            <span class="result-value" id="calpha-epitope">None</span>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top: 1.5rem;">
        <h2>Predicted Properties <span class="pill pill-purple">ML-Based (Sim)</span></h2>
        
        <div class="affinity-meter">
          <label>Predicted Affinity (KD)</label>
          <div class="meter-bar">
            <div class="meter-fill" id="affinity-meter" style="width: 75%;">
              <span class="meter-value">10 nM</span>
            </div>
          </div>
        </div>
        
        <div class="results-panel" style="background: transparent; border: none; padding: 0;">
          <div class="result-item">
            <span class="result-label">Specificity Score</span>
            <span class="result-value" id="specificity-score">0.85</span>
          </div>
          <div class="result-item">
            <span class="result-label">Stability (Tm)</span>
            <span class="result-value" id="stability-tm">72°C</span>
          </div>
          <div class="result-item">
            <span class="result-label">Humanization</span>
            <span class="result-value" id="humanization">92%</span>
          </div>
          <div class="result-item">
            <span class="result-label">Expression Yield</span>
            <span class="result-value" id="expression">High</span>
          </div>
        </div>
      </div>

      <div class="card" style="margin-top: 1.5rem;">
        <h2>3D Structure Prediction <span class="pill pill-green">AlphaFold-Style</span></h2>
        <p class="lead">Generate full antibody structure models with secondary structure prediction</p>
        
        <div style="margin-top: 1rem;">
          <h4>Manual CDR Input (Optional)</h4>
          <div class="cdr-panel" style="grid-template-columns: repeat(2, 1fr); gap: 0.5rem;">
            <div>
              <label for="input-cdr-h1" style="font-size: 12px;">CDR H1:</label>
              <input type="text" id="input-cdr-h1" placeholder="GFTFSSY" style="width: 100%; font-size: 11px;">
            </div>
            <div>
              <label for="input-cdr-h2" style="font-size: 12px;">CDR H2:</label>
              <input type="text" id="input-cdr-h2" placeholder="ISGSGGST" style="width: 100%; font-size: 11px;">
            </div>
            <div>
              <label for="input-cdr-h3" style="font-size: 12px;">CDR H3:</label>
              <input type="text" id="input-cdr-h3" placeholder="AREGYCSSGSCYFD" style="width: 100%; font-size: 11px;">
            </div>
            <div>
              <label for="input-cdr-l1" style="font-size: 12px;">CDR L1:</label>
              <input type="text" id="input-cdr-l1" placeholder="QSISSY" style="width: 100%; font-size: 11px;">
            </div>
            <div>
              <label for="input-cdr-l2" style="font-size: 12px;">CDR L2:</label>
              <input type="text" id="input-cdr-l2" placeholder="AAS" style="width: 100%; font-size: 11px;">
            </div>
            <div>
              <label for="input-cdr-l3" style="font-size: 12px;">CDR L3:</label>
              <input type="text" id="input-cdr-l3" placeholder="QQYGSSPT" style="width: 100%; font-size: 11px;">
            </div>
          </div>
        </div>
        
        <div style="margin-top: 1rem;">
          <label>Modeling Method:</label>
          <select id="modeling-method" style="width: 100%; margin-top: 0.5rem;">
            <option value="alphafold">AlphaFold-Style (Deep Learning)</option>
            <option value="rosetta">Rosetta Antibody (Homology)</option>
            <option value="hybrid">Hybrid (AlphaFold + Rosetta)</option>
            <option value="quick">Quick Model (Template-based)</option>
          </select>
        </div>
        
        <div class="btn-group" style="margin-top: 1rem;">
          <button class="btn primary" onclick="abDesign_generateStructureModel()">
            🧬 Generate 3D Model
          </button>
          <button class="btn green" onclick="abDesign_generateMultipleModels()">
            📊 Generate 5 Models (Ensemble)
          </button>
          <button class="btn" onclick="abDesign_useCurrentCDRs()">
            ⬆️ Use Current CDRs
          </button>
        </div>
        
        <div id="modeling-status" style="margin-top: 1rem; display: none;" class="infobox">
          <strong>Status:</strong> <span id="modeling-status-text"></span>
          <progress id="modeling-progress" value="0" max="100" style="width: 100%; margin-top: 0.5rem;"></progress>
        </div>
        
        <div id="model-confidence" style="margin-top: 1rem; display: none;">
          <h4>Model Confidence Metrics</h4>
          <div class="result-item">
            <span class="result-label">pLDDT Score</span>
            <span class="result-value" id="plddt-score">-</span>
          </div>
          <div class="result-item">
            <span class="result-label">pTM Score</span>
            <span class="result-value" id="ptm-score">-</span>
          </div>
          <div class="result-item">
            <span class="result-label">Clash Score</span>
            <span class="result-value" id="clash-score">-</span>
          </div>
          <div class="result-item">
            <span class="result-label">Ramachandran Favored</span>
            <span class="result-value" id="rama-score">-</span>
          </div>
        </div>
        
        <div id="model-ensemble" style="margin-top: 1rem; display: none;">
          <h4>Model Ensemble <span class="pill pill-green" id="ensemble-count">0 Models</span></h4>
          <div id="model-buttons" class="btn-group" style="flex-wrap: wrap;"></div>
        </div>
      </div>

      <div class="card" style="margin-top: 1.5rem;">
        <h2>3D CDR Ribbon Visualization <span class="pill pill-purple">Schematic View</span></h2>
        <p class="lead">Idealized ribbon diagram showing CDR loops as Bezier curves (for visualization, not structural prediction)</p>
        
        <div style="margin-top: 1rem;">
          <h4>Ribbon Styling Parameters</h4>
          <div class="row" style="display: grid; grid-template-columns: 120px 1fr; gap: 10px; margin: 8px 0;">
            <label for="ribbon-bulge">Bulge Height (Å)</label>
            <input type="number" id="ribbon-bulge" value="16" min="8" max="30" step="1" style="width: 100%;">
          </div>
          <div class="row" style="display: grid; grid-template-columns: 120px 1fr; gap: 10px; margin: 8px 0;">
            <label for="ribbon-radius">Ribbon Radius</label>
            <input type="number" id="ribbon-radius" value="0.8" min="0.3" max="2.0" step="0.1" style="width: 100%;">
          </div>
          <div class="tips" style="font-size: 12px; color: var(--muted); margin-top: 6px;">
            Bulge controls how far CDR loops arch from the domain centers. Larger values make loops more prominent.
          </div>
        </div>
        
        <div class="btn-group" style="margin-top: 1rem;">
          <button class="btn primary" onclick="abDesign_buildRibbon()">
            🎨 Build Ribbon View
          </button>
          <button class="btn" onclick="abDesign_useCurrentCDRsForRibbon()">
            ⬆️ Use Current CDRs
          </button>
          <button class="btn secondary" onclick="abDesign_resetRibbonView()">
            🔄 Reset View
          </button>
          <button class="btn" onclick="abDesign_exportRibbonPDB()">
            💾 Export Ribbon PDB
          </button>
        </div>
        
        <div style="margin-top: 1rem;">
          <h4>CDR Color Legend</h4>
          <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; font-size: 12px;">
            <div style="display: flex; align-items: center; gap: 6px;">
              <div style="width: 14px; height: 14px; background: #f59e0b; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2);"></div>
              <span>H1 (Amber)</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <div style="width: 14px; height: 14px; background: #ef4444; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2);"></div>
              <span>H2 (Red)</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <div style="width: 14px; height: 14px; background: #8b5cf6; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2);"></div>
              <span>H3 (Violet)</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <div style="width: 14px; height: 14px; background: #22c55e; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2);"></div>
              <span>L1 (Green)</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <div style="width: 14px; height: 14px; background: #06b6d4; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2);"></div>
              <span>L2 (Cyan)</span>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <div style="width: 14px; height: 14px; background: #60a5fa; border-radius: 4px; border: 1px solid rgba(255,255,255,0.2);"></div>
              <span>L3 (Blue)</span>
            </div>
          </div>
        </div>
        
        <div id="ribbon-info" class="infobox" style="margin-top: 1rem; display: none;">
          <strong>Ribbon Status:</strong> <span id="ribbon-status-text"></span>
        </div>
      </div>
    </div>
  </div>
</section>

<section id="epitopesTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>Immunoglobulin Epitope Database <span class="pill pill-green">35 Validated Epitopes (Sim)</span></h2>
      
      <div class="table-container">
        <table class="table">
          <thead>
            <tr>
              <th>Ig Class</th>
              <th>Region</th>
              <th>Position</th>
              <th>Accessibility</th>
              <th>Conservation</th>
              <th>Clinical Relevance</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody id="epitope-tbody">
            </tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<section id="dockTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>1️⃣ Load Proteins</h2>
      <div class="row small" style="color:#9ca3af">Upload PDBs or paste text. Parse, then pick chains. <em>Tip:</em> click <b>Example</b> to try quickly.</div>
      <div class="row">
        <div style="flex:1;min-width:300px">
          <h3>Protein A (Antibody) <span class="pill" id="badgeA">0 atoms</span></h3>
          <div class="row" role="group" aria-label="Protein A inputs">
            <input type="file" id="pdbAFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('A')">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('A')" title="Download by PDB ID from RCSB">Fetch PDB ID</button>
          </div>
          <textarea id="pdbAText" placeholder="Paste PDB for Protein A" aria-label="Protein A PDB"></textarea>
          <div class="row"><label>Chains:</label><div id="chainsABox" class="chainchips"></div></div>
          <div id="chainWarnA" class="infobox small">Parse to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('A')">🔎 Parse A</button><button class="btn" onclick="selectAllChains('A')">Select All</button><button class="btn" onclick="invertChains('A')">Invert</button></div>
        </div>
        <div style="flex:1;min-width:300px">
          <h3>Protein B (Antigen) <span class="pill" id="badgeB">0 atoms</span></h3>
          <div class="row" role="group" aria-label="Protein B inputs">
            <input type="file" id="pdbBFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('B')">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('B')" title="Download by PDB ID from RCSB">Fetch PDB ID</button>
          </div>
          <textarea id="pdbBText" placeholder="Paste PDB for Protein B" aria-label="Protein B PDB"></textarea>
          <div class="row"><label>Chains:</label><div id="chainsBBox" class="chainchips"></div></div>
          <div id="chainWarnB" class="infobox small">Parse to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('B')">🔎 Parse B</button><button class="btn" onclick="selectAllChains('B')">Select All</button><button class="btn" onclick="invertChains('B')">Invert</button></div>
        </div>
      </div>
      <details style="margin-top:10px"><summary><b>Student Notes</b> — formats & tips</summary>
        <div class="small" style="color:#9ca3af;padding-top:6px">
          <b>Formats:</b> PDB text, .pdb.gz • <b>Fetch:</b> RCSB via PDB ID • <b>Cartoon:</b> needs backbone atoms (N/CA/C/O)
        </div>
      </details>
    </div>

    <div class="card">
      <h2>2️⃣ Docking Parameters</h2>
      <h4>Sampling</h4>
      <div class="row">
        <label>Samples</label><input type="number" id="samples" value="12000" min="1000" step="1000" title="More samples = more thorough (slower)">
        <label>Max Translation (Å)</label><input type="number" id="maxTrans" value="12" step="1">
        <label>Atom Set</label>
        <select id="atomMode" title="Which atoms to use for sampling/scoring">
          <option value="CA">Cα only</option><option value="BB">Backbone</option><option value="HEAVY" selected>All heavy</option>
        </select>
      </div>
      <h4 style="margin-top:8px">Scoring</h4>
      <div class="row">
        <label>Contact (Å)</label><input type="number" id="contactCut" value="4.8" step="0.1">
        <label>Clash Factor</label><input type="number" id="clashFactor" value="0.85" step="0.05">
        <label>Contact W</label><input type="number" id="wContact" value="1.0" step="0.1">
        <label>Clash W</label><input type="number" id="wClash" value="6.0" step="0.1">
        <label>Softness</label><input type="number" id="soft" value="0.5" step="0.1">
      </div>
      <h4 style="margin-top:8px">Pairing & Output</h4>
      <div class="row">
        <label>Pairing</label>
        <select id="pairMode">
          <option value="AGG">Aggregate (all selected)</option>
          <option value="A_EACH_B">A × each B-chain</option>
          <option value="CROSS">each A-chain × each B-chain</option>
        </select>
        <label>Top Poses</label><input type="number" id="topN" value="12" min="1" max="50">
        <label>Rescore</label>
        <select id="rescoreMode"><option value="NONE">Skip</option><option value="HEAVY">Heavy</option><option value="HEAVY_REFINE" selected>Heavy + refine</option></select>
        <label>Seed</label><input type="number" id="seed" value="42">
      </div>
      <div class="row">
        <label>Diversity (°/Å)</label>
        <input type="number" id="dupAngle" value="12" step="1" style="width:90px">
        <input type="number" id="dupTrans" value="2" step="0.5" style="width:90px">
        <label>Clusters</label><input type="number" id="clustersK" value="6" min="1" max="24" style="width:90px">
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="dockBtn">▶️ Run Docking</button>
        <button class="btn red" id="cancelBtn" disabled>✖ Cancel</button>
        <button class="btn orange" id="resetBtn">🔄 Reset</button>
      </div>
      <div class="infobox small"><b>Score = contacts×W<sub>c</sub> − clashes×W<sub>x</sub></b>. Clustering is pose-diversity aware. Heavy rescoring refines ranks.</div>
    </div>
  </div>

  <div class="wrap grid two">
    <div class="card">
      <h2>3️⃣ Complex Selector • 3D Visualization & Results</h2>
      <div class="row">
        <label>Complex</label>
        <select id="comboSelect" style="min-width:260px" aria-label="Complex selector"></select>
        <button class="btn" id="btnPrevCombo">◀ Prev</button>
        <button class="btn" id="btnNextCombo">Next ▶</button>
        <button class="btn" id="btnClusters" title="Group poses into K clusters">📎 Cluster Poses</button>
      </div>
      <div class="row" style="margin-top:6px">
        <label class="chip"><input type="checkbox" id="toggleContacts" checked> Contacts</label>
        <label class="chip"><input type="checkbox" id="toggleHB" checked> H-bonds</label>
        <label class="chip"><input type="checkbox" id="toggleSB" checked> Salt bridges</label>
        <label class="chip"><input type="checkbox" id="toggleHydro"> Hydrophobic</label>
        <label class="chip"><input type="checkbox" id="toggleRibbon" checked> Ribbon</label>
      </div>
      <div id="viewer" role="img" aria-label="3D viewer"></div>
      <div class="row" style="margin-top:8px;flex-wrap:wrap" id="poseControls"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnAllPDB">⬇ All Poses PDB (this complex)</button>
        <button class="btn green" id="btnCurrentPDB">⬇ Current PDB</button>
        <button class="btn" id="btnCSV">⬇ CSV</button>
        <button class="btn" id="btnJSON">⬇ JSON</button>
        <button class="btn purple" id="btnPNG">📸 PNG</button>
        <button class="btn" id="btnAllComplexesPDB">⬇ All Complexes (multi-MODEL PDB)</button>
      </div>
      <div class="score" id="scoreBox" style="margin-top:8px"></div>
    </div>

    <div class="card">
      <h2>Interface Metrics & Enthalpy</h2>
      <div class="metric-grid" id="metricsDisplay"></div>
      <h4 style="margin-top:10px">Energy Parameters</h4>
      <div class="row">
        <label>k<sub>elec</sub></label><input type="number" id="kElec" value="0.5" step="0.1">
        <label>Elec Cutoff (Å)</label><input type="number" id="elecCut" value="12" step="0.5">
        <label>Desolv W</label><input type="number" id="wDesolv" value="0.2" step="0.1">
      </div>
      <div class="infobox small">
        <b>ΔH (kcal/mol) ≈</b> −0.5×contacts −2.5×H-bonds −4.0×salt-bridges −1.0×hydrophobic +0.3×clash + electrostatics +0.2×contacts (desolv).
      </div>
      <div class="infobox small"><b>Reproducibility:</b> Outputs include parameters & seed; registry stores signature.</div>
      <h3>Complex Summary</h3>
      <div class="table-container small">
        <table class="table">
          <thead><tr><th>Complex</th><th>Top Score</th><th>Contacts</th><th>ΔH</th></tr></thead>
          <tbody id="comboSummaryBody"></tbody>
        </table>
      </div>
    </div>
  </div>
</section>

<section id="cdrTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>CDR Identification & Mapping</h2>
      <textarea id="cdrPDB" placeholder="Paste antibody PDB for CDR analysis" style="height:200px"></textarea>
      <div class="row" style="margin-top:10px">
        <button class="btn primary" onclick="runCDRAnalysis()">Analyze CDRs</button>
        <select id="schemeSelect" title="Numbering scheme">
          <option value="Kabat">Kabat</option>
          <option value="Chothia">Chothia</option>
          <option value="IMGT">IMGT</option>
        </select>
        <button class="btn" onclick="copyAbPDBToCDR()">Use Antibody PDB A</button>
      </div>
      <div class="scheme-grid" id="cdrResults"></div>
      <div class="infobox" style="margin-top:10px">
        <strong>Numbering Schemes:</strong><br>
        • <strong>Kabat:</strong> Sequence variability-based. • <strong>Chothia:</strong> Structural features. • <strong>IMGT:</strong> Standardized across species.<br>
        <span class="small">Heuristic anchoring is used here; for research work, validate with ANARCI/IMGT/AbNum.</span>
      </div>
    </div>
    <div class="card">
      <h2>CDR Visualization</h2>
      <div id="viewerCDR"></div>
      <div class="row" style="margin-top:8px">
        <label class="chip"><input type="checkbox" id="showCDR1" checked> CDR1</label>
        <label class="chip"><input type="checkbox" id="showCDR2" checked> CDR2</label>
        <label class="chip"><input type="checkbox" id="showCDR3" checked> CDR3</label>
        <label class="chip"><input type="checkbox" id="showFrameworks" checked> Frameworks</label>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="card">
      <h2>CDR Sequence Details</h2>
      <div id="cdrSequenceTable" class="table-container"></div>
    </div>
  </div>
</section>

<section id="fragmentTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>CA-Trace Fragment Generator</h2>
      <div class="grid three">
        <div>
          <h3>Input PDB</h3>
          <textarea id="fragPDB" placeholder="Paste PDB for fragment generation"></textarea>
        </div>
        <div>
          <h3>Parameters</h3>
          <div class="row"><label>Window Size</label><input type="number" id="windowSize" value="10" min="3" max="30"></div>
          <div class="row"><label>Step Size</label><input type="number" id="stepSize" value="1" min="1" max="10"></div>
          <div class="row"><label>Chain Filter</label><input type="text" id="chainFilter" placeholder="e.g., H,L"></div>
        </div>
        <div>
          <h3>Actions</h3>
          <button class="btn primary" onclick="generateFragments()">Generate Fragments</button>
          <button class="btn green" onclick="downloadFragments()">⬇ Download All</button>
        </div>
      </div>
      <div id="fragmentResults" style="margin-top:20px"></div>
    </div>
  </div>
</section>

<section id="fragLibTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="grid two">
      <div class="card">
        <h2>Fragment Library (Upload)</h2>
        <span class="pill pill-blue">235 Fragments Loaded (Sim)</span>
        
        <div class="form-group" style="margin-top:1rem">
          <label>Upload Fragment JSON</label>
          <input type="file" id="fragment-upload" accept=".json" onchange="abDesign_loadFragments(event)">
        </div>
        
        <div class="form-group" style="margin-top:1rem">
          <label>Or Paste Fragment Data</label>
          <textarea id="fragment-data" placeholder='[{"chain":"A","sequence":"DKPRAHLTVV",...}]'></textarea>
        </div>
        
        <button class="btn primary" onclick="abDesign_processFragments()" style="margin-top:1rem">
          Process Fragments
        </button>
      </div>
      
      <div class="card">
        <h2>Top CDR Candidates</h2>
        
        <div id="fragment-candidates">
          <div class="results-panel">
            <div class="result-item">
              <span class="result-label">Best H3:</span>
              <span class="result-value">VCAQCPPGTF (Score: 78)</span>
            </div>
            <div class="result-item">
              <span class="result-label">Best L1:</span>
              <span class="result-value">SVSEVGSNWF (Score: 70)</span>
            </div>
            <div class="result-item">
              <span class="result-label">Best L3:</span>
              <span class="result-value">QFWNYLERCR (Score: 71)</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<section id="ligTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>🧪 Single Ligand Docking</h2>
      <div class="small" style="color:#9ca3af">SMILES→3D uses a simplified embedding for demonstration. For research, use RDKit / OpenBabel.</div>
      <div class="row">
        <div style="flex:1;min-width:300px">
          <h3>Receptor PDB</h3>
          <textarea id="ligReceptorPDB" placeholder="Paste receptor PDB" aria-label="Ligand docking receptor PDB"></textarea>
          <div class="row" style="margin-top:6px">
            <button class="btn" onclick="loadLigandDemoReceptor()">Load Example</button>
            <button class="btn" onclick="parseReceptorForLigand()">Parse & Preview</button>
          </div>
        </div>
        <div style="flex:1;min-width:300px">
          <h3>Ligand SMILES</h3>
          <textarea id="ligSmiles" placeholder="e.g., CC(=O)Oc1ccccc1C(=O)O (aspirin)" aria-label="Ligand SMILES"></textarea>
          <div class="row" style="margin-top:6px">
            <label>3D Method</label><select id="ligEmbedMethod"><option value="HASH">HashCloud</option><option value="HELIX">RingHelix</option></select>
            <label>Seed</label><input type="number" id="ligSeed" value="1337" style="width:90px" />
            <button class="btn primary" onclick="runSingleLigandDock()">▶️ Dock</button>
          </div>
        </div>
      </div>
      <div class="infobox small"><b>Note:</b> Posing uses receptor center sampling; score = contacts − clash (same core terms).</div>
    </div>
    <div class="card">
      <h2>Ligand Docking Result</h2>
      <div id="viewerLig"></div>
      <div class="score" id="ligScore" style="margin-top:8px"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnLigPDB">⬇ Complex PDB</button>
        <button class="btn" id="btnLigCSV">⬇ CSV Result</button>
        <span class="pill" id="ligStatus" aria-live="polite">idle</span>
      </div>
    </div>
  </div>
</section>

<section id="screenTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>📚 Batch Screening (≤50 SMILES × ≤3 Receptors)</h2>
      <div class="grid three">
        <div>
          <h3>SMILES Library</h3>
          <textarea id="scrSmiles" placeholder="One SMILES per line (max 50)"></textarea>
        </div>
        <div>
          <h3>Receptors (PDBs)</h3>
          <textarea id="scrReceptors" placeholder="Paste 2–3 PDBs separated by a line with only: END"></textarea>
          <div class="small" style="color:#9ca3af">Delimiter must be exactly “END” on its own line.</div>
        </div>
        <div>
          <h3>Parameters</h3>
          <div class="row"><label>Samples/Ligand</label><input type="number" id="scrSamples" value="5000" min="1000" step="500" /></div>
          <div class="row"><label>Contact (Å)</label><input type="number" id="scrContactCut" value="4.8" step="0.1" /></div>
          <div class="row"><label>Clash Factor</label><input type="number" id="scrClashFactor" value="0.85" step="0.05" /></div>
          <div class="row"><label>Seed</label><input type="number" id="scrSeed" value="777" /></div>
          <div class="row"><label>3D Method</label><select id="scrEmbedMethod"><option value="HASH">HashCloud</option><option value="HELIX">RingHelix</option></select></div>
          <div class="row"><label>Sort</label>
            <select id="scrSort"><option value="score">Score ↓</option><option value="enthalpy">ΔH ↑ (most negative)</option><option value="consensus" selected>Consensus (rank-sum)</option></select>
          </div>
          <div class="row" style="margin-top:10px"><button class="btn primary" id="btnStartScreen">▶️ Start Screening</button><button class="btn red" id="btnStopScreen" disabled>✖ Stop</button></div>
          <div class="infobox small">Sequential SMILES×Receptor; consensus = rank(score↓, ΔH↑, contacts↓).</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Results</h2>
      <div class="row" style="margin-bottom:8px">
        <button class="btn green" id="btnScrCSV">⬇ Full Results CSV</button>
        <button class="btn" id="btnScrJSON">⬇ JSON Export</button>
        <button class="btn purple" id="btnScrTop10">📊 Show Top 10</button>
        <span class="pill" id="scrStatus" aria-live="polite">idle</span>
        <span class="small" id="scrProgress" style="color:#9ca3af"></span>
      </div>
      <div class="table-container" style="max-height:460px">
        <table class="table" id="scrTable">
          <thead><tr>
            <th>#</th><th>Receptor</th><th>SMILES</th><th>Score</th><th>Contacts</th><th>H-bonds</th><th>SaltBr</th><th>Clash</th><th>ΔH (kcal/mol)</th><th>CRank</th>
          </tr></thead>
          <tbody id="scrTableBody"></tbody>
        </table>
      </div>
      <div id="viewerScr" style="height:420px;margin-top:12px"></div>
      <div class="small" style="text-align:center;color:#9ca3af;margin-top:4px">Click a row to visualize that docked pose.</div>
    </div>

    <div class="card">
      <h2>Enthalpy Distribution</h2>
      <div class="metric-grid" id="screenMetrics"></div>
      <div class="score" id="enthalpyBreakdown" style="margin-top:8px"></div>
      <div class="infobox small"><b>Interpretation:</b> more negative ΔH ⇒ stronger binding (approximate; entropy not included).</div>
    </div>
  </div>
</section>

<section id="designAnalysisTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="grid two">
      <div class="card">
        <h2>Affinity Prediction</h2>
        <div id="affinity-chart" style="height: 400px;"></div>
      </div>
      
      <div class="card">
        <h2>CDR Properties</h2>
        <div id="cdr-properties-chart" style="height: 400px;"></div>
      </div>
    </div>
    
    <div class="card" style="margin-top: 1.5rem;">
      <h2>Therapeutic Applications</h2>
      <div id="therapeutic-apps">
        </div>
    </div>
  </div>
</section>

<section id="analysisTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>📊 Docking Analysis Tools</h2>
      <div class="tabs" style="margin-top:6px">
        <button class="tabbtn active" data-subtab="energyTab">Energy Decomposition</button>
        <button class="tabbtn" data-subtab="compareTab">Pose Comparison</button>
        <button class="tabbtn" data-subtab="residueTab">Residue Contacts</button>
      </div>
      <div id="energyTab" class="tabsec active">
        <h3>Energy Component Analysis</h3>
        <div id="energyComponents" class="metric-grid"></div>
        <h4>ΔH Details</h4>
        <div class="score" id="enthalpyDetail"></div>
      </div>
      <div id="compareTab" class="tabsec">
        <h3>Compare Poses</h3>
        <div class="row">
          <label>Pose 1</label><select id="comparePose1"></select>
          <label>Pose 2</label><select id="comparePose2"></select>
          <button class="btn primary" onclick="comparePoses()">Compare</button>
        </div>
        <div class="grid two" style="margin-top:10px">
          <div><div id="viewerComp" style="height:420px"></div></div>
          <div><div class="score" id="comparisonResults" style="min-height:420px"></div></div>
        </div>
      </div>
      <div id="residueTab" class="tabsec">
        <h3>Residue-Level Contacts</h3>
        <div class="row">
          <label>Min Dist (Å)</label><input type="number" id="filterMinDist" value="0" step="0.5" style="width:90px" />
          <label>Max Dist (Å)</label><input type="number" id="filterMaxDist" value="6" step="0.5" style="width:90px" />
          <button class="btn" onclick="filterResidueContacts()">Filter</button>
          <button class="btn green" onclick="exportResidueData()">⬇ Export</button>
        </div>
        <div class="table-container" style="margin-top:8px">
          <table class="table">
            <thead><tr><th>Residue A</th><th>Chain A</th><th>Residue B</th><th>Chain B</th><th>Distance (Å)</th><th>Type</th><th>Energy</th></tr></thead>
            <tbody id="residueTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</section>

<section id="designExportTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="grid three">
      <div class="card">
        <h2>PDB Structure</h2>
        <p style="color: var(--muted); margin-bottom: 1rem;">
          Export 3D structure in PDB format for molecular dynamics or docking
        </p>
        <button class="btn primary" onclick="abDesign_exportPDB()">
          📄 Download PDB
        </button>
      </div>
      
      <div class="card">
        <h2>Sequences</h2>
        <p style="color: var(--muted); margin-bottom: 1rem;">
          Export CDR and framework sequences in FASTA format
        </p>
        <button class="btn primary" onclick="abDesign_exportFASTA()">
          🧬 Download FASTA
        </button>
      </div>
      
      <div class="card">
        <h2>Analysis Report</h2>
        <p style="color: var(--muted); margin-bottom: 1rem;">
          Complete analysis including predictions and properties
        </p>
        <button class="btn primary" onclick="abDesign_exportReport()">
          📊 Download Report
        </button>
      </div>
    </div>
    
    <div class="card" style="margin-top: 1.5rem;">
      <h2>Export Preview</h2>
      <textarea id="export-preview" style="height: 400px; font-family: var(--mono);" readonly>
Select an export option to preview the data...
      </textarea>
    </div>
  </div>
</section>

<section id="qaTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>📋 Run Registry & Session Management</h2>
      <div class="row" style="margin-top:6px">
        <button class="btn green" onclick="saveCurrentRun()">💾 Save Current Run</button>
        <button class="btn" onclick="refreshRunRegistry()">🔄 Refresh</button>
        <button class="btn" onclick="exportAllRuns()">⬇ Export Registry</button>
        <button class="btn purple" onclick="importRunRegistry()">⬆ Import Registry</button>
        <button class="btn red" onclick="clearRunRegistry()">🗑️ Clear</button>
      </div>
      <input type="file" id="importRegistryFile" accept=".json" style="display:none" />
      <div class="table-container" style="margin-top:10px">
        <table class="table">
          <thead><tr><th>Timestamp</th><th>Type</th><th>Description</th><th>Top Score</th><th>Signature</th><th>Actions</th></tr></thead>
          <tbody id="registryTableBody"></tbody>
        </table>
      </div>
    </div>
    <div class="card">
      <h2>✅ Quality Assurance (Reproducibility)</h2>
      <div class="row" style="margin-top:6px">
        <label>Repeats</label><input type="number" id="qaRepeats" value="3" min="2" max="10" style="width:90px" />
        <label>Tolerance</label><input type="number" id="qaTolerance" value="0.01" step="0.01" style="width:90px" />
        <button class="btn primary" onclick="runQATest()">▶️ Run QA Test</button>
      </div>
      <div class="score" id="qaResults" style="margin-top:10px;min-height:120px"></div>
      <div class="infobox small">Runs N repeats with same seed; passes if top scores within tolerance.</div>
    </div>
  </div>
</section>

<section id="omicsTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>🔬 Virtual Omics Analysis of a Theoretical Eukaryotic Cell</h2>
      <div class="infobox">This is a theoretical analysis for educational purposes. It illustrates data types from proteomics, lipidomics, and metabolomics, using glycolysis as the example pathway.</div>

      <div class="tabs" style="margin-top:6px">
        <button class="tabbtn active" data-subtab="proteomicsTab">Proteomics</button>
        <button class="tabbtn" data-subtab="lipidomicsTab">Lipidomics</button>
        <button class="tabbtn" data-subtab="metabolomicsTab">Metabolomics</button>
      </div>

      <div id="proteomicsTab" class="tabsec active">
        <h3>Protein Input (optional PDB for descriptors)</h3>
        <textarea id="omicsProteinPDB" placeholder="Paste protein PDB (optional)"></textarea>
        <div class="row" style="margin-top:6px">
          <button class="btn" id="omicsLoadProteinDemo">Load Protein Demo</button>
        </div>
        <h3>Virtual Proteomics: Glycolytic Enzymes</h3>
        <div class="table-container">
          <table class="table">
            <thead><tr><th>Protein (Enzyme)</th><th>Subcellular Location</th><th>Function in Glycolysis</th></tr></thead>
            <tbody>
              <tr><td>Hexokinase (HK)</td><td>Cytosol (near mitochondria)</td><td>Glucose → glucose-6-phosphate.</td></tr>
              <tr><td>PFK-1</td><td>Cytosol</td><td>Committed step to F1,6BP.</td></tr>
              <tr><td>GAPDH</td><td>Cytosol</td><td>Oxidation step; NADH.</td></tr>
              <tr><td>Pyruvate Kinase</td><td>Cytosol</td><td>PEP + ADP → ATP + pyruvate.</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <div id="lipidomicsTab" class="tabsec">
        <h3>Lipid SMILES (one per line)</h3>
        <textarea id="omicsLipidSmiles" placeholder="Enter lipid SMILES, one per line"></textarea>
        <div class="row" style="margin-top:6px"><button class="btn" id="omicsLoadLipidDemo">Load Lipid Demo</button></div>
      </div>

      <div id="metabolomicsTab" class="tabsec">
        <h3>Carbohydrate SMILES (one per line) & DNA (FASTA-like)</h3>
        <textarea id="omicsCarbSmiles" placeholder="Enter carbohydrate SMILES, one per line"></textarea>
        <div class="row" style="margin-top:6px"><button class="btn" id="omicsLoadCarbDemo">Load Carb Demo</button></div>
        <h3 style="margin-top:8px">DNA (FASTA)</h3>
        <textarea id="omicsDNA" placeholder=">id&#10;ACGT..."></textarea>
        <div class="row" style="margin-top:6px"><button class="btn" id="omicsLoadDNADemo">Load DNA Demo</button></div>
      </div>

      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="omicsAnalyzeBtn">▶️ Analyze</button>
        <button class="btn green" id="omicsExportBtn">⬇ Export JSON</button>
        <span class="pill" id="omicsStatus" aria-live="polite">idle</span>
      </div>

      <div class="grid two" style="margin-top:10px">
        <div class="card">
          <h3>Descriptors</h3>
          <div class="table-container">
            <table class="table">
              <thead><tr><th>Key</th><th>Value</th></tr></thead>
              <tbody id="omicsDescriptorBody"></tbody>
            </table>
          </div>
        </div>
        <div class="card">
          <h3>Trends</h3>
          <div class="score" id="omicsTrends" style="min-height:220px"></div>
        </div>
      </div>
    </div>
  </div>
</section>

<section id="nmrTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>📡 Theoretical NMR Prediction</h2>
      <div class="infobox small">Enter a SMILES string to get a theoretical description of what its NMR spectra might look like. This is an educational guide, not a simulator.</div>
      <h3>SMILES Input</h3>
      <textarea id="nmrSmiles" placeholder="Enter SMILES string">CC(=O)Oc1ccccc1C(=O)O</textarea>
      <h3>Structure Preview</h3>
      <div id="nmrMoleculeImage"></div>
      <div class="row">
        <button class="btn primary" id="btnPredict1H">Predict ¹H NMR</button>
        <button class="btn" id="btnPredict13C">Predict ¹³C NMR</button>
        <button class="btn" id="btnPredictCOSY">Predict COSY</button>
        <button class="btn" id="btnPredictNOESY">Predict NOESY</button>
      </div>
    </div>
    <div class="card">
      <h2>Prediction Output</h2>
      <div class="score" id="nmrPredictionOutput" style="min-height:300px">Prediction results will appear here.</div>
    </div>
  </div>
</section>

<section id="aboutTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>About</h2>
      <p>This educational platform demonstrates in-browser design and docking with parallel sampling, simplified scoring, and interactive visualization. All computations run locally; nothing is uploaded.</p>
      <h3>Important Disclaimers</h3>
      <div class="errorbox">
        <p><b>No warranties; use at your own risk.</b></p>
        <p>Scoring/embedding are simplified approximations; entropy, solvation, polarization, water networks, induced fit, glycan effects, and protonation/tautomer states are not fully modeled. <b>Always double-check results and verify with experiments (e.g., SPR/ITC, crystallography, MD, MM-PBSA/FEP).</b> Compare against professional tools.</p>
        <p><b>Regulatory note:</b> This is not validated for GLP/Part 11/CSV and is not suitable for regulated decision-making. Educational/research prototyping only.</p>
      </div>
      <h3>Recommended Workflow</h3>
      <div class="infobox small">Use for hypothesis generation → export top poses → refine with AutoDock/HADDOCK/Rosetta → MD → MM-PBSA/FEP → <b>experimental validation</b>.</div>
      <h3>Credits</h3>
      <div class="small" style="color:#9ca3af">Lead & Concept: <b>DJF — The New Chemist</b> • 3D rendering: 3Dmol.js • Compression: Pako • Plotting: Plotly.js • Structures: RCSB PDB</div>
    </div>
  </div>
</section>

<footer>
  <div class="wrap">
    <p><b>Educational Use Only.</b> Results are approximate. <b>Always double-check and verify with experiments</b> before making conclusions or decisions.</p>
    <p class="small">© Student Edition • No warranties • We disclaim any loss in any way • Validate results independently</p>
  </div>
</footer>

<script>
/* ===== Shared state & helpers ===== */
let viewer=null, viewerLig=null, viewerScr=null, viewerComp=null, viewerCDR=null;
let viewerDesign = null; // <-- NEW, from AbDesigner
let inProgress=false, cancelled=false, workerPool=[];
let pdbAAllAtoms=[], pdbBAllAtoms=[];
let combos=[], currentComboIndex=-1;
let currentContacts=[], currentHB=[], currentSB=[], currentHydro=[];
let ligLastResult={}, screenCancel=false, screenResults=[], screenReceptors=[];
const REGISTRY_KEY='docking_registry_v2';

// --- AbDesigner Namespaced Globals ---
let abDesign_selectedIg = 'IgG';
let abDesign_currentAntibody = null;
let abDesign_antibodyCount = 0;
let abDesign_fragments = [];
let abDesign_spinning = false;
// --- End AbDesigner Globals ---

const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
const hydrophobic=new Set(['ALA','VAL','LEU','ILE','PRO','PHE','MET','TRP','TYR','CYS']);
const residueCharges={'ASP':-1,'GLU':-1,'LYS':+1,'ARG':+1,'HIS':+0.1};

const E=id=>document.getElementById(id);
const status=t=>E('statusPill').textContent=t;
const setProgress=f=>{E('prog').value=Math.max(0,Math.min(1,f||0));};

window.addEventListener('DOMContentLoaded', ()=>{
  // Initialize ALL viewers
  ensureViewer('viewer'); ensureViewer('viewerLig'); ensureViewer('viewerScr'); ensureViewer('viewerComp'); ensureViewer('viewerCDR');
  ensureViewer('viewerDesign'); // <-- NEW
  
  drawPlaceholder(viewer);
  drawPlaceholder(viewerDesign); // <-- NEW
  
  setupMainTabs();
  setupSubTabs();
  bindEvents();
  bindOmicsAndNMREvents();
  bindCDRControls();
  loadSessionHistory();
  setTimeout(autoDemo, 300);

  const rib = E('toggleRibbon');
  if (rib) { rib.addEventListener('change', ()=>{ if (!combos.length) return; const idx = combos[currentComboIndex]?.currentIndex ?? 0; showPose(idx); }); }
  
  // --- AbDesigner Init Calls ---
  abDesign_loadEpitopes();
  abDesign_initializeCharts();
  abDesign_loadDemoStructure(); 
  E('scaffold-type')?.addEventListener('change', abDesign_updateScaffoldInfo);
  abDesign_updateScaffoldInfo(); // Initial call
  abDesign_selectIg('IgG'); // Initial call
  // --- End AbDesigner Init ---
});

/* Tabs */
function setupMainTabs(){
  document.querySelectorAll('.tabbtn[data-tab]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      document.querySelectorAll('.tabbtn[data-tab]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      const target=btn.dataset.tab;
      document.querySelectorAll('[data-tab-panel]').forEach(sec=>{ sec.classList.toggle('active', sec.id===target); });
      requestAnimationFrame(()=>{
        try{ 
          viewer?.resize(); viewerLig?.resize(); viewerScr?.resize(); viewerComp?.resize(); viewerCDR?.resize(); viewerDesign?.resize();
          viewer?.render(); viewerLig?.render(); viewerScr?.render(); viewerComp?.render(); viewerCDR?.render(); viewerDesign?.render(); 
        }catch(e){}
      });
    });
  });
}
function setupSubTabs(){
  document.querySelectorAll('.tabbtn[data-subtab]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const wrap=btn.closest('.card');
      wrap.querySelectorAll('.tabbtn[data-subtab]').forEach(b=>b.classList.remove('active'));
      wrap.querySelectorAll('.tabsec').forEach(s=>s.classList.remove('active'));
      btn.classList.add('active');
      const tgt=wrap.querySelector('#'+btn.dataset.subtab);
      if (tgt) tgt.classList.add('active');
      requestAnimationFrame(()=>{ viewerComp?.resize(); viewerComp?.render(); });
    });
  });
}

/* Viewers */
function ensureViewer(id){
  const el=E(id); if(!el) return;
  const opt={backgroundColor:'#0a0f1a'};
  if(id==='viewer' && !viewer) viewer=$3Dmol.createViewer(el,opt);
  else if(id==='viewerLig' && !viewerLig) viewerLig=$3Dmol.createViewer(el,opt);
  else if(id==='viewerScr' && !viewerScr) viewerScr=$3Dmol.createViewer(el,opt);
  else if(id==='viewerComp' && !viewerComp) viewerComp=$3Dmol.createViewer(el,opt);
  else if(id==='viewerCDR' && !viewerCDR) viewerCDR=$3Dmol.createViewer(el,opt);
  else if(id==='viewerDesign' && !viewerDesign) viewerDesign=$3Dmol.createViewer(el,opt); // <-- NEW
}
function drawPlaceholder(v){
  if(!v) return; v.addSphere({center:{x:-8,y:0,z:0},radius:4,color:'#60a5fa',alpha:.6});
  v.addSphere({center:{x:8,y:0,z:0},radius:4,color:'#f97316',alpha:.6});
  v.zoomTo(); v.render();
}

/* Events */
function bindEvents(){
  // global
  E('btnDemo').addEventListener('click', autoDemo);
  E('btnSaveSession').addEventListener('click', saveSession);
  E('btnLoadSession').addEventListener('click', loadSession);

  // docking
  E('dockBtn').addEventListener('click', runAntibodyDocking);
  E('cancelBtn').addEventListener('click', cancelDocking);
  E('resetBtn').addEventListener('click', resetAll);

  // complex selector
  E('comboSelect').addEventListener('change', ()=>{ setCurrentCombo(parseInt(E('comboSelect').value)||0); });
  E('btnPrevCombo').addEventListener('click', ()=>{ if(combos.length) setCurrentCombo((currentComboIndex-1+combos.length)%combos.length); });
  E('btnNextCombo').addEventListener('click', ()=>{ if(combos.length) setCurrentCombo((currentComboIndex+1)%combos.length); });
  E('btnClusters').addEventListener('click', clusterCurrentPoses);

  // exports
  E('btnAllPDB').addEventListener('click', downloadAllPoses);
  E('btnCurrentPDB').addEventListener('click', downloadCurrentPose);
  E('btnCSV').addEventListener('click', downloadCSV);
  E('btnJSON').addEventListener('click', downloadJSON);
  E('btnPNG').addEventListener('click', ()=>snapshotPNG(viewer));
  E('btnAllComplexesPDB').addEventListener('click', downloadAllComplexesPDB);

  // overlays
  ['toggleContacts','toggleHB','toggleSB','toggleHydro'].forEach(id=>E(id).addEventListener('change', refreshOverlays));

  // file inputs
  E('pdbAFile').addEventListener('change', e=>handleFileUpload('A', e.target.files[0]));
  E('pdbBFile').addEventListener('change', e=>handleFileUpload('B', e.target.files[0]));

  // ligand docking
  E('btnLigPDB').addEventListener('click', downloadLigandPDB);
  E('btnLigCSV').addEventListener('click', downloadLigandCSV);

  // screening
  E('btnStartScreen').addEventListener('click', startBatchScreening);
  E('btnStopScreen').addEventListener('click', ()=>{screenCancel=true;E('btnStopScreen').disabled=true;});
  E('btnScrCSV').addEventListener('click', downloadScreeningCSV);
  E('btnScrJSON').addEventListener('click', downloadScreeningJSON);
  E('btnScrTop10').addEventListener('click', showTop10Screening);
}

/* Utils */
async function fileToText(file){
  const name=(file?.name||'').toLowerCase(); const buf=await file.arrayBuffer();
  if(name.endsWith('.gz')){const u8=new Uint8Array(buf); const out=pako.inflate(u8); return new TextDecoder().decode(out);} 
  return new TextDecoder().decode(buf);
}
async function handleFileUpload(which,file){
  if(!file) return;
  try{ const text=await fileToText(file); E(which==='A'?'pdbAText':'pdbBText').value=text; parseOne(which); }
  catch(e){ alert('Error reading file: '+e.message); }
}
async function fetchPDBFromRCSB(which){
  const pdbId=prompt(`Enter 4-character PDB ID for Protein ${which}:`); if(!pdbId) return;
  const id=pdbId.trim().toLowerCase(); if(id.length!==4){alert('PDB ID must be 4 chars');return;}
  try{
    status(`fetching ${id}…`);
    const res=await fetch(`https://files.rcsb.org/download/${id}.pdb`);
    if(!res.ok) throw new Error('RCSB error');
    const txt=await res.text();
    E(which==='A'?'pdbAText':'pdbBText').value=txt;
    await parseOne(which); status('idle');
  }catch(e){ alert('Fetch failed: '+e.message); status('error'); }
}
function centroid(pts){ let x=0,y=0,z=0; for(const p of pts){x+=p.x;y+=p.y;z+=p.z;} const n=pts.length||1; return {x:x/n,y:y/n,z:z/n};}
function translate(points,t){return points.map(p=>({...p,x:p.x+t.x,y:p.y+t.y,z:p.z+t.z}));}
function formatPDB(atoms,chainShift=0){
  const lines=[]; let serial=1;
  for(const a of atoms){
    const name=(a.name||'CA').padStart(4,' ');
    const resn=(a.resn||'RES').padStart(3,' ');
    const chain=String((a.chain||'A')).slice(0,1);
    const chainOut=String.fromCharCode(chain.charCodeAt(0)+(chainShift||0));
    const resi=String(a.resi||1).padStart(4,' ');
    const x=isFinite(a.x)?a.x:0, y=isFinite(a.y)?a.y:0, z=isFinite(a.z)?a.z:0;
    const xs=x.toFixed(3).padStart(8,' '), ys=y.toFixed(3).padStart(8,' '), zs=z.toFixed(3).padStart(8,' ');
    const elem=(a.elem||'C').toString().padStart(2,' ');
    lines.push(`ATOM  ${String(serial).padStart(5,' ')} ${name} ${resn} ${chainOut}${resi}    ${xs}${ys}${zs}  1.00  0.00           ${elem}`);
    serial++;
  }
  lines.push('TER','ENDMDL','END'); return lines.join('\n');
}
function downloadBlob(text, filename){
  const url=URL.createObjectURL(new Blob([text],{type:'text/plain'}));
  const a=document.createElement('a'); a.href=url; a.download=filename; a.click();
  setTimeout(()=>URL.revokeObjectURL(url),1000);
}
function snapshotPNG(v){
  try{ v.render(); v.pngURI((uri)=>{ const a=document.createElement('a'); a.href=uri; a.download='viewer.png'; a.click(); }); }
  catch(e){ alert('PNG failed: '+e.message);}
}

/* PDB parsing / chains */
function parsePDB(text){
  const atoms=[]; if(!text) return atoms;
  const lines=String(text).split(/\r?\n/);
  for(const line of lines){
    if(!(line.startsWith('ATOM')||line.startsWith('HETATM'))) continue;
    if(line.length<54) continue;
    const name=(line.substring(12,16)||'').trim();
    const resn=(line.substring(17,20)||'').trim()||'UNK';
    const chain=(line.substring(21,22)||'A').trim()||'A';
    const resiStr=(line.substring(22,26)||'').trim(); const resi=parseInt(resiStr||'0')||1;
    const xf=(s,a,b)=>parseFloat((s.substring(a,b)||'').trim());
    const x=xf(line,30,38), y=xf(line,38,46), z=xf(line,46,54);
    if(!isFinite(x)||!isFinite(y)||!isFinite(z)) continue;
    let elem=(line.length>=78? (line.substring(76,78)||'').trim(): '')||name.trim()[0]||'C';
    elem=String(elem).toUpperCase();
    atoms.push({name,resn,chain,resi,x,y,z,elem});
  }
  return atoms;
}
async function parseOne(which){
  const t = E(which==='A'?'pdbAText':'pdbBText').value.trim();
  if(!t){ alert('Paste PDB or upload file first.'); return; }
  const atoms=parsePDB(t);
  if(!atoms.length){ alert('No atoms parsed — check PDB formatting.'); return; }
  if(which==='A'){ pdbAAllAtoms=atoms; populateChainChips('A',atoms); E('badgeA').textContent=`${atoms.length} atoms`; }
  else{ pdbBAllAtoms=atoms; populateChainChips('B',atoms); E('badgeB').textContent=`${atoms.length} atoms`; }
}
function populateChainChips(which, atoms){
  const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.innerHTML='';
  const chains=[...new Set(atoms.map(a=>a.chain||'A'))];
  chains.forEach(c=>{
    const id=`${which}_ch_${c}`;
    const lbl=document.createElement('label'); lbl.className='chip';
    lbl.innerHTML=`<input type="checkbox" id="${id}" data-which="${which}" data-chain="${c}" checked> ${c}`;
    box.appendChild(lbl);
  });
  const warn=which==='A'?E('chainWarnA'):E('chainWarnB');
  warn.className='successbox small';
  warn.textContent=`✓ Parsed ${atoms.length} atoms • Chains: ${chains.join(', ')||'—'}`;
}
function selectedChains(which){
  const box=which==='A'?E('chainsABox'):E('chainsBBox');
  const selected=[...box.querySelectorAll('input[type=checkbox]')].filter(cb=>cb.checked).map(cb=>cb.dataset.chain);
  return new Set(selected);
}
function selectAllChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=true); }
function invertChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=!cb.checked); }
function filterChains(atoms, keep){ if(!keep||keep.size===0) return atoms; return atoms.filter(a=>keep.has(a.chain)); }
function selectAtomSet(atoms, mode){ const bb=new Set(['N','CA','C','O']); return atoms.filter(a=>{ if(mode==='CA') return a.name==='CA'; if(mode==='BB') return bb.has(a.name); return a.elem!=='H'; }); }

/* Worker (sampling/scoring) */
function makeDockWorker(){
  const code=`
    const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
    function rand(seed){let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);}
    function randomQuat(r){const u1=r(),u2=r(),u3=r(); const a=Math.sqrt(1-u1),b=Math.sqrt(u1),t1=2*Math.PI*u2,t2=2*Math.PI*u3; return [a*Math.sin(t1),a*Math.cos(t1),b*Math.sin(t2),b*Math.cos(t2)];}
    function rotate(points,q){const[qx,qy,qz,qw]=q; return points.map(p=>{const vx=p.x,vy=p.y,vz=p.z; const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz; const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy),oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz),oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx); return {x:ox,y:oy,z:oz,elem:p.elem};});}
    function translate(points,t){return points.map(p=>({x:p.x+t.x,y:p.y+t.y,z:p.z+t.z,elem:p.elem}));}
    function grid(coords,c){const m=new Map(),k=(ix,iy,iz)=>ix+"|"+iy+"|"+iz; for(let i=0;i<coords.length;i++){const x=coords[i].x,y=coords[i].y,z=coords[i].z,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),kk=k(ix,iy,iz); if(!m.has(kk)) m.set(kk,[]); m.get(kk).push(i);} return {c,m};}
    function neigh(g,x,y,z){const c=g.c,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),out=[]; for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++)for(let dz=-1;dz<=1;dz++){const kk=(ix+dx)+"|"+(iy+dy)+"|"+(iz+dz); if(g.m.has(kk)) out.push(...g.m.get(kk));} return out;}
    function scorePose(A,B,contact,clashFact,wC,wX,soft){const G=grid(A,contact); let contacts=0, clash=0; for(let i=0;i<B.length;i++){const x=B[i].x,y=B[i].y,z=B[i].z, eB=(B[i].elem||'C').toUpperCase(), neighs=neigh(G,x,y,z); for(const j of neighs){const a=A[j],dx=x-a.x,dy=y-a.y,dz=z-a.z, d=Math.hypot(dx,dy,dz), eA=(a.elem||'C').toUpperCase(); const rs=(vdw[eA]||1.7)+(vdw[eB]||1.7), clashCut=clashFact*rs; if(d<=clashCut){const ov=(clashCut-d+1e-6)/clashCut; clash+=wX*ov*(1/(1+soft*ov));} else if(d<=contact){contacts+=1;} } } return {score: wC*contacts - clash, contacts, clash}; }
    self.onmessage=(ev)=>{ const {Apts,Bpts,params,start,end}=ev.data; const rng=rand(params.seed+start*1337); const best=[]; const total=end-start; for(let k=0;k<total;k++){ const q=randomQuat(rng), t={x:(rng()*2-1)*params.maxTrans, y:(rng()*2-1)*params.maxTrans, z:(rng()*2-1)*params.maxTrans}; const B=translate(rotate(Bpts,q),t), s=scorePose(Apts,B,params.contactCut,params.clashFactor,params.wContact,params.wClash,params.soft); best.push({score:s.score,contacts:s.contacts,clash:s.clash,q:[...q],t}); if(((k+1)&1023)===0) self.postMessage({type:'progress', done:(k+1), total}); } best.sort((a,b)=>b.score-a.score); self.postMessage({type:'done',poses:best.slice(0,Math.min(200,total))}); };
  `;
  return new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
}
function angleBetweenQuats(q1,q2){
  const dot=q1[0]*q2[0]+q1[1]*q2[1]+q1[2]*q2[2]+q1[3]*q2[3];
  const clamped=Math.max(-1,Math.min(1,Math.abs(dot)));
  return 2*Math.acos(clamped)*180/Math.PI;
}
function diverseTop(sorted,deg,transA,limit){
  const out=[]; const max=Math.max(1,limit||parseInt(E('topN').value)||10);
  for(const p of sorted){
    let dupe=false;
    for(const s of out){
      const a=angleBetweenQuats(p.q,s.q);
      const t=Math.hypot(p.t.x-s.t.x,p.t.y-s.t.y,p.t.z-s.t.z);
      if(a<=deg && t<=transA){dupe=true;break;}
    }
    if(!dupe){out.push(p); if(out.length>=max) break;}
  }
  return out;
}

/* Docking driver */
function enumerateCombos(){
  const mode=E('pairMode').value; const aSel=selectedChains('A'); const bSel=selectedChains('B');
  const Amap=groupByChain(pdbAAllAtoms), Bmap=groupByChain(pdbBAllAtoms);
  const Akeys=[...Amap.keys()].filter(k=>aSel.has(k)); const Bkeys=[...Bmap.keys()].filter(k=>bSel.has(k));
  const combosOut=[];
  if(mode==='AGG'){
    const A=filterChains(pdbAAllAtoms,aSel), B=filterChains(pdbBAllAtoms,bSel);
    combosOut.push({label:`A{${Akeys.join('')}} vs B{${Bkeys.join('')}}`, Aatoms:A, Batoms:B});
  } else if(mode==='A_EACH_B'){
    const A=filterChains(pdbAAllAtoms,aSel);
    for(const b of Bkeys){ combosOut.push({label:`A{${Akeys.join('')}} vs B{${b}}`, Aatoms:A, Batoms:Bmap.get(b)}); }
  } else if(mode==='CROSS'){
    for(const a of Akeys){ for(const b of Bkeys){ combosOut.push({label:`A{${a}} vs B{${b}}`, Aatoms:Amap.get(a), Batoms:Bmap.get(b)}); } }
  }
  return combosOut;
}
function groupByChain(atoms){ const m=new Map(); for(const a of atoms){ const ch=a.chain||'A'; if(!m.has(ch)) m.set(ch,[]); m.get(ch).push(a); } return m; }

async function runAntibodyDocking(){
  if(inProgress) return;
  cancelled=false; inProgress=true; status('preparing'); setProgress(0);
  E('dockBtn').disabled=true; E('cancelBtn').disabled=false; E('dockBtn').textContent='Running…';
  try{
    const textA=await ensureInputText('A'), textB=await ensureInputText('B');
    pdbAAllAtoms=parsePDB(textA); pdbBAllAtoms=parsePDB(textB);
    if(!pdbAAllAtoms.length || !pdbBAllAtoms.length) throw new Error('Failed to parse one or both PDBs.');
    populateChainChips('A',pdbAAllAtoms); populateChainChips('B',pdbBAllAtoms);

    const params=collectDockingParams();
    const comboDefs=enumerateCombos();
    if(!comboDefs.length) throw new Error('No chain combinations produced. Select at least one chain on each protein.');

    combos=comboDefs.map(c=>({label:c.label, Aatoms:c.Aatoms, Batoms:c.Batoms, cA:null, cB:null, topPoses:[], currentIndex:0}));
    updateComboSelect();

    let completed=0; const totalCombos=combos.length;
    let sampleDone=0; const totalSamples=(params.samples||10000)*totalCombos;

    for(let i=0;i<combos.length;i++){
      if(cancelled) break; status(`combo ${i+1}/${totalCombos} sampling…`);
      await dockSingleCombo(i, params, (done,total)=>{ 
        const base=completed*(params.samples||10000);
        sampleDone = base + Math.min(done,total);
        setProgress(sampleDone/Math.max(1,totalSamples));
      });
      completed++; fillComboSummaryRow(i);
    }

    setCurrentCombo(0);
    finishDocking(); status(cancelled?'cancelled':'complete'); setProgress(1); inProgress=false;
  }catch(e){
    alert(e.message||'Docking error'); finishDocking(); status('error'); inProgress=false;
  }
}
function cancelDocking(){ cancelled=true; workerPool.forEach(w=>{try{w.terminate();}catch(e){}}); workerPool=[]; setProgress(0); status('cancelled'); finishDocking(); inProgress=false; }
function finishDocking(){ E('dockBtn').disabled=false; E('cancelBtn').disabled=true; E('dockBtn').textContent='▶️ Run Docking'; }
function collectDockingParams(){
  return {samples:parseInt(E('samples').value),maxTrans:parseFloat(E('maxTrans').value),
          contactCut:parseFloat(E('contactCut').value),clashFactor:parseFloat(E('clashFactor').value),
          wContact:parseFloat(E('wContact').value),wClash:parseFloat(E('wClash').value),
          soft:parseFloat(E('soft').value), topN:Math.max(1,parseInt(E('topN').value)),
          seed:parseInt(E('seed').value)||42, atomMode:E('atomMode').value, rescoreMode:E('rescoreMode').value};
}
async function ensureInputText(which){
  const file=E(which==='A'?'pdbAFile':'pdbBFile').files[0]; let t=E(which==='A'?'pdbAText':'pdbBText').value.trim();
  if(!t && file){ t=await fileToText(file); }
  if(!t) throw new Error(`Provide PDB for Protein ${which} (file or text).`);
  return t;
}
async function dockSingleCombo(idx, params, onProgress){
  const combo=combos[idx];
  const aSel=combo.Aatoms, bSel=combo.Batoms;

  const selA=selectAtomSet(aSel,params.atomMode);
  const selB=selectAtomSet(bSel,params.atomMode);
  if(!selA.length||!selB.length) throw new Error('Atom selection empty. Try Backbone or Heavy mode.');

  const cA=centroid(selA), cB=centroid(selB);
  const ptsA=translate(selA.map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem})), {x:-cA.x,y:-cA.y,z:-cA.z});
  const ptsB=translate(selB.map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem})), {x:-cB.x,y:-cB.y,z:-cB.z});
  combo.cA=cA; combo.cB=cB;

  const cores=Math.max(1,(navigator.hardwareConcurrency||4)-1), pool=Math.min(cores,8);
  const total=params.samples; const base=Math.floor(total/pool), extra=total%pool;
  let all=[], donePerWorker=Array(pool).fill(0); workerPool=[];

  await new Promise((resolve)=>{
    let finished=0;
    for(let i=0;i<pool;i++){
      const start=i*base+Math.min(i,extra), end=start+base+(i<extra?1:0);
      const w=makeDockWorker(); workerPool.push(w);
      w.onmessage=(m)=>{
        if(cancelled) return;
        const msg=m.data;
        if(msg.type==='progress'){
          donePerWorker[i]=Math.min(msg.done, msg.total);
          onProgress?.(donePerWorker.reduce((a,b)=>a+b,0), total);
        }
        if(msg.type==='done'){
          all.push(msg.poses); w.terminate(); finished++;
          if(finished===pool) resolve();
        }
      };
      w.onerror=(e)=>{ console.error('worker error',e); w.terminate(); finished++; if(finished===pool) resolve(); };
      w.postMessage({Apts:ptsA,Bpts:ptsB,params,start,end});
    }
  });
  workerPool=[];

  const poses=all.flat().sort((a,b)=>b.score-a.score);
  const diverse=diverseTop(poses, parseFloat(E('dupAngle').value)||12, parseFloat(E('dupTrans').value)||2, params.topN*3);

  const Aheavy=translate(selectAtomSet(aSel,'HEAVY').map(a=>({...a})), {x:-cA.x,y:-cA.y,z:-cA.z});
  const Bheavy0=translate(selectAtomSet(bSel,'HEAVY').map(a=>({...a})), {x:-cB.x,y:-cB.y,z:-cB.z});

  let top=diverse;
  if(params.rescoreMode!=='NONE'){ top=await heavyAtomRescore(Aheavy,Bheavy0,params,diverse, params.rescoreMode==='HEAVY_REFINE'); }
  combo.topPoses=top; combo.Aviz=Aheavy; combo.B0=Bheavy0;
}
function heavyAtomRescore(A,B0,params,coarse,refine=false){
  const {contactCut,clashFactor,wContact,wClash,soft}=params;
  function score(A,B){ let contacts=0, clash=0;
    for(const b of B){ for(const a of A){
      const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z);
      const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7);
      const cut=clashFactor*rs;
      if(d<=cut){ const ov=(cut-d+1e-6)/cut; clash+=wClash*ov*(1/(1+soft*ov)); }
      else if(d<=contactCut){ contacts++; }
    }}
    return {score:wContact*contacts-clash,contacts,clash};
  }
  function apply(B,q,t){
    const [qx,qy,qz,qw]=q;
    return B.map(p=>{
      const vx=p.x,vy=p.y,vz=p.z;
      const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz;
      const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy);
      const oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz);
      const oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx);
      return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name};
    });
  }
  function jiggle(p){ const r=()=> (Math.random()*2-1)*0.5;
    const dq=[p.q[0]+r()*0.01,p.q[1]+r()*0.01,p.q[2]+r()*0.01,p.q[3]+r()*0.01];
    const n=Math.hypot(...dq)||1; for(let i=0;i<4;i++) dq[i]/=n;
    const dt={x:p.t.x+r(),y:p.t.y+r(),z:p.t.z+r()};
    return {q:dq,t:dt};
  }
  const rescored=[];
  for(const p of coarse){
    let best={...p};
    let TB=apply(B0,p.q,p.t); let s=score(A,TB);
    best.score=s.score; best.contacts=s.contacts; best.clash=s.clash;
    if(refine){
      for(let it=0;it<40;it++){
        const pp=jiggle(best);
        const TB2=apply(B0,pp.q,pp.t);
        const s2=score(A,TB2);
        if(s2.score>best.score){ best.q=pp.q; best.t=pp.t; best.score=s2.score; best.contacts=s2.contacts; best.clash=s2.clash; }
      }
    }
    rescored.push(best);
  }
  rescored.sort((a,b)=>b.score-a.score);
  return rescored.slice(0,parseInt(E('topN').value));
}
function applyTransform(points,q,t){
  const [qx,qy,qz,qw]=q;
  return points.map(p=>{
    const vx=p.x,vy=p.y,vz=p.z;
    const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz;
    const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy);
    const oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz);
    const oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx);
    return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name};
  });
}
/* Visualization / overlays */
function updateComboSelect(){
  const sel=E('comboSelect'); sel.innerHTML='';
  combos.forEach((c,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=`${i+1}. ${c.label}`; sel.appendChild(o); });
  E('comboSummaryBody').innerHTML='';
}
function setCurrentCombo(i){
  if(i<0||i>=combos.length) return; currentComboIndex=i; E('comboSelect').value=String(i);
  buildPoseButtons(combos[i].topPoses);
  if(combos[i].topPoses.length) showPose(0);
  updateMetricsDisplay();
}
function buildPoseButtons(poses){
  const c=E('poseControls'); c.innerHTML='';
  poses.forEach((p,i)=>{
    const b=document.createElement('button'); b.className='btn';
    b.textContent=`Pose ${i+1} (S=${p.score.toFixed(1)}, C=${p.contacts|0}, X=${p.clash.toFixed(1)})`;
    b.addEventListener('click',()=>showPose(i)); c.appendChild(b);
    const d=document.createElement('button'); d.className='btn green'; d.style.marginLeft='6px'; d.textContent='⬇ PDB';
    d.addEventListener('click',()=>downloadSinglePose(i)); c.appendChild(d);
  });
  updateComparisonDropdowns(poses);
}
function showPose(i){
  const combo=combos[currentComboIndex]; if(!combo) return;
  if(i<0||i>=combo.topPoses.length) return; combo.currentIndex=i;
  const p=combo.topPoses[i];
  const TB=applyTransform(combo.B0,p.q,p.t);
  viewer.clear();
  viewer.addModel(formatPDB(combo.Aviz),'pdb');
  viewer.addModel(formatPDB(TB,1),'pdb');

  const rA = new Set(combo.Aviz.map(a=>a.resi)).size;
  const rB = new Set(TB.map(a=>a.resi)).size;
  const wantRibbon = E('toggleRibbon')?.checked;

  const hasBackboneA = combo.Aviz.some(a=>a.name==='N') && combo.Aviz.some(a=>a.name==='CA') && combo.Aviz.some(a=>a.name==='C');
  const hasBackboneB = TB.some(a=>a.name==='N') && TB.some(a=>a.name==='CA') && TB.some(a=>a.name==='C');
  const canCartoon    = hasBackboneA && hasBackboneB && (rA>=8 && rB>=8);

  viewer.setStyle({}, {});
  if (wantRibbon && canCartoon) {
    viewer.setStyle({model:0},{cartoon:{color:'#60a5fa',arrows:true,thickness:0.5}});
    viewer.setStyle({model:1},{cartoon:{color:'#f97316',arrows:true,thickness:0.5}});
  } else if (wantRibbon) {
    viewer.setStyle({model:0},{line:{linewidth:1.5}});
    viewer.setStyle({model:1},{line:{linewidth:1.5,color:'#f97316'}});
  } else {
    viewer.setStyle({model:0},{stick:{radius:.25}});
    viewer.setStyle({model:1},{stick:{radius:.25,color:'#f97316'}});
  }

  viewer.zoomTo();
  const cutoff=parseFloat(E('contactCut').value);
  const metrics=computeInterfaceMetrics(combo.Aviz,TB,cutoff);
  currentContacts=metrics.contactsPairs.slice(0,800);
  currentHB=metrics.hbPairs.slice(0,400);
  currentSB=metrics.sbPairs.slice(0,400);
  currentHydro=metrics.hydroPairs.slice(0,400);
  refreshOverlays();

  const kElec=parseFloat(E('kElec').value)||0.5, eCut=parseFloat(E('elecCut').value)||12;
  const elec=coulombEnergy(combo.Aviz,TB,kElec,eCut);
  const BSA=metrics.contacts*10.0;
  const dH=calculateEnthalpy(metrics,elec);
  E('scoreBox').innerHTML=`<b>${combo.label}</b> • <b>Pose ${i+1}</b><br>
    Score: ${p.score.toFixed(2)} | Contacts: ${metrics.contacts} | Clash: ${metrics.clash.toFixed(2)} |
    H-bonds: ${metrics.hb} | SaltBr: ${metrics.sb} | Hydrophobics: ${metrics.hydrophobics}<br>
    BSA ≈ ${BSA.toFixed(0)} Å² | Electrostatics: ${elec.toFixed(2)} kcal/mol |
    <b>ΔH ≈ ${dH.toFixed(2)} kcal/mol</b>`;
  updateMetricsDisplay(); updateEnergyDecomposition(metrics,elec,dH);
  viewer.render();
}
function refreshOverlays(){
  if(!combos.length) return;
  viewer.removeAllShapes();
  if(E('toggleContacts').checked) drawLines(currentContacts,'#60a5fa');
  if(E('toggleHB').checked)       drawLines(currentHB,'#34d399');
  if(E('toggleSB').checked)       drawLines(currentSB,'#f87171');
  if(E('toggleHydro').checked)    drawLines(currentHydro,'#fbbf24');
  viewer.render();
}
function drawLines(pairs,color){
  for(const p of pairs){ viewer.addLine({start:{x:p.x1,y:p.y1,z:p.z1},end:{x:p.x2,y:p.y2,z:p.z2},dashed:true,dashLength:.5,color,linewidth:2}); }
}
function computeInterfaceMetrics(A,B,cut){
  let contacts=0,clash=0,hb=0,sb=0,hydro=0;
  const contactsPairs=[],hbPairs=[],sbPairs=[],hydroPairs=[];
  const clashFactor=parseFloat(E('clashFactor').value)||0.85;
  for(const b of B) for(const a of A){
    const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z);
    const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7);
    const cutCl=clashFactor*rs;
    if(d<=cutCl){ const ov=(cutCl-d+1e-6)/cutCl; clash+=6.0*ov*(1/(1+0.5*ov)); }
    if(d<=cut){ contacts++; contactsPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
    const aN=a.name?.startsWith('N'), aO=a.name?.startsWith('O'), bN=b.name?.startsWith('N'), bO=b.name?.startsWith('O');
    if(((aN&&bO)||(aO&&bN)) && d<=3.5){ hb++; hbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
    const isAcidic=at=> (at.resn==='ASP'&&at.name.startsWith('OD'))||(at.resn==='GLU'&&at.name.startsWith('OE'));
    const isBasic =at=> (at.resn==='LYS'&&at.name==='NZ')||(at.resn==='ARG'&&(at.name==='NH1'||'NH2'||at.name==='NE'))||(at.resn==='HIS'&&(at.name==='ND1'||at.name==='NE2'));
    if(((isAcidic(a)&&isBasic(b))||(isAcidic(b)&&isBasic(a))) && d<=4.0){ sb++; sbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
    if(hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)&&(a.elem==='C'||b.elem==='C')&&d<=4.5){ hydro++; hydroPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
  }
  return {contacts,clash,hb,sb,hydrophobics:hydro,contactsPairs,hbPairs,sbPairs,hydroPairs};
}
function coulombEnergy(A,B,k=0.5,cut=12){
  const AA=residueChargesFor(A), BB=residueChargesFor(B); let E=0, cut2=cut*cut;
  for(const a of AA) for(const b of BB){
    const dx=a.x-b.x,dy=a.y-b.y,dz=a.z-b.z, d2=dx*dx+dy*dy+dz*dz; if(d2>cut2) continue;
    E+=k*(a.q*b.q)/(Math.sqrt(d2)+1e-3);
  }
  return E;
}
function residueChargesFor(atoms){
  const groups=new Map();
  for(const a of atoms){ const key=(a.chain||'A')+':'+(a.resi||0); if(!groups.has(key)) groups.set(key,[]); groups.get(key).push(a); }
  const out=[];
  for(const [key,arr] of groups.entries()){
    const res=arr[0].resn||'UNK', q=residueCharges[res]||0; if(!q) continue;
    const ca=arr.find(x=>x.name==='CA'); let x,y,z;
    if(ca){x=ca.x;y=ca.y;z=ca.z;}
    else{ let sx=0,sy=0,sz=0; for(const a of arr){sx+=a.x; sy+=a.y; sz+=a.z;} x=sx/arr.length; y=sy/arr.length; z=sz/arr.length; }
    out.push({x,y,z,q,resn:res});
  }
  return out;
}
function calculateEnthalpy(m,elec){
  const w={contact:-0.5,hbond:-2.5,salt:-4.0,hydro:-1.0,clash:+0.3,desolv:+0.2};
  return w.contact*m.contacts + w.hbond*m.hb + w.salt*m.sb + w.hydro*m.hydrophobics + w.clash*m.clash + elec + w.desolv*m.contacts;
}

/* Clustering & Summary */
function clusterCurrentPoses(){
  const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length) return;
  const K=Math.max(1,parseInt(E('clustersK').value)||6); const poses=combo.topPoses;
  const centers=poses.slice(0,Math.min(K,poses.length)); const assign=new Array(poses.length).fill(0);
  function d(p,q){ const a=angleBetweenQuats(p.q,q.q), t=Math.hypot(p.t.x-q.t.x,p.t.y-q.t.y,p.t.z-q.t.z); return a+5*t; }
  for(let iter=0;iter<6;iter++){
    for(let i=0;i<poses.length;i++){ let best=0,bestd=Infinity; for(let c=0;c<centers.length;c++){ const dd=d(poses[i],centers[c]); if(dd<bestd){bestd=dd;best=c;} } assign[i]=best; }
    for(let c=0;c<centers.length;c++){ const members=poses.filter((_,i)=>assign[i]===c); if(members.length){ members.sort((a,b)=>b.score-a.score); centers[c]=members[0]; } }
  }
  const ordered=poses.map((p,i)=>({p,i,cl:assign[i]})).sort((a,b)=> a.cl-b.cl || b.p.score-a.p.score).map(x=>x.p);
  combo.topPoses=ordered; buildPoseButtons(combo.topPoses); showPose(0);
}
function fillComboSummaryRow(i){
  const combo=combos[i]; const top=combo.topPoses[0]; if(!top) return;
  const TB=applyTransform(combo.B0,top.q,top.t);
  const metrics=computeInterfaceMetrics(combo.Aviz,TB,parseFloat(E('contactCut').value));
  const elec=coulombEnergy(combo.Aviz,TB,parseFloat(E('kElec').value)||0.5,parseFloat(E('elecCut').value)||12);
  const dH=calculateEnthalpy(metrics,elec);
  const tr=document.createElement('tr');
  tr.innerHTML=`<td>${combo.label}</td><td>${top.score.toFixed(2)}</td><td>${metrics.contacts}</td><td>${dH.toFixed(2)}</td>`;
  E('comboSummaryBody').appendChild(tr);
}

/* Metrics / Analysis UI */
function updateMetricsDisplay(){
  const combo=combos[currentComboIndex];
  if(!combo||!combo.topPoses.length){
    E('metricsDisplay').innerHTML='<div class="small" style="color:#9ca3af">Run docking to see metrics.</div>'; return;
  }
  const p=combo.topPoses[combo.currentIndex];
  E('metricsDisplay').innerHTML=
    `<div class="metric-card"><div class="metric-value">${p.score.toFixed(2)}</div><div class="metric-label">Score</div></div>
     <div class="metric-card"><div class="metric-value">${currentContacts.length}</div><div class="metric-label">Contacts</div></div>
     <div class="metric-card"><div class="metric-value">${currentHB.length}</div><div class="metric-label">H-bonds</div></div>
     <div class="metric-card"><div class="metric-value">${currentSB.length}</div><div class="metric-label">Salt Bridges</div></div>`;
}
function updateEnergyDecomposition(m,elec,dH){
  const box=E('energyComponents');
  const parts=[["Contacts","+"+(m.contacts),-0.5*m.contacts],["H-bonds","+"+(m.hb),-2.5*m.hb],["SaltBr","+"+(m.sb),-4.0*m.sb],["Hydrophobic","+"+(m.hydrophobics),-1.0*m.hydrophobics],["Clash","+"+m.clash,(+0.3*m.clash)],["Electrostatics","",elec],["Desolv","+"+m.contacts,+0.2*m.contacts]];
  box.innerHTML=parts.map(([k,c,v])=>`<div class="metric-card"><div class="metric-value">${v.toFixed(2)}</div><div class="metric-label">${k} ${c}</div></div>`).join('');
  E('enthalpyDetail').textContent = `ΔH ≈ ${dH.toFixed(2)} kcal/mol (contacts, H-bonds, salt bridges, hydrophobic, clash, electrostatics, desolvation).`;
}
function updateComparisonDropdowns(poses){
  const s1=E('comparePose1'), s2=E('comparePose2');
  s1.innerHTML=''; s2.innerHTML='';
  poses.forEach((p,i)=>{ const o1=document.createElement('option'); o1.value=i; o1.textContent=`Pose ${i+1}`; s1.appendChild(o1);
                        const o2=document.createElement('option'); o2.value=i; o2.textContent=`Pose ${i+1}`; s2.appendChild(o2); });
  if(poses.length>=2){ s1.value=0; s2.value=1; }
}
function comparePoses(){
  const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length) return;
  const i1=parseInt(E('comparePose1').value), i2=parseInt(E('comparePose2').value);
  if(!(combo.topPoses[i1]&&combo.topPoses[i2])) return;
  const TB1=applyTransform(combo.B0,combo.topPoses[i1].q,combo.topPoses[i1].t);
  viewerComp.clear(); viewerComp.addModel(formatPDB(combo.Aviz),'pdb'); viewerComp.addModel(formatPDB(TB1,1),'pdb');
  viewerComp.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewerComp.setStyle({model:1},{cartoon:{color:'#f97316'}});
  viewerComp.zoomTo(); viewerComp.render();
  const a=angleBetweenQuats(combo.topPoses[i1].q, combo.topPoses[i2].q);
  const t=Math.hypot(combo.topPoses[i1].t.x-combo.topPoses[i2].t.x,combo.topPoses[i1].t.y-combo.topPoses[i2].t.y,combo.topPoses[i1].t.z-combo.topPoses[i2].t.z);
  E('comparisonResults').textContent = `Pose1 score=${combo.topPoses[i1].score.toFixed(2)}, Pose2 score=${combo.topPoses[i2].score.toFixed(2)}\nΔangle ≈ ${a.toFixed(1)}°, Δtranslation ≈ ${t.toFixed(2)} Å`;
}
function filterResidueContacts(){
  const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length) return;
  const min=parseFloat(E('filterMinDist').value)||0, max=parseFloat(E('filterMaxDist').value)||6;
  const p=combo.topPoses[combo.currentIndex]; const TB=applyTransform(combo.B0,p.q,p.t);
  const rows=[];
  for(const b of TB) for(const a of combo.Aviz){
    const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z); if(d<min||d>max) continue;
    const type=(a.name?.startsWith('N')&&b.name?.startsWith('O')||a.name?.startsWith('O')&&b.name?.startsWith('N'))&&d<=3.5?'H-bond': (hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)?'Hydrophobic': (d<=4?'Contact':'Proximal'));
    const e=type==='H-bond'?-2.5:type==='Hydrophobic'?-1.0:type==='Contact'?-0.5:0;
    rows.push(`<tr><td>${a.resn}${a.resi}</td><td>${a.chain}</td><td>${b.resn||'-'}${b.resi||'-'}</td><td>${b.chain||'-'}</td><td>${d.toFixed(2)}</td><td>${type}</td><td>${e.toFixed(2)}</td></tr>`);
  }
  E('residueTableBody').innerHTML=rows.slice(0,1000).join('');
}
function exportResidueData(){
  const table=E('residueTableBody').innerText||''; if(!table){alert('No data');return;} downloadBlob(table,'residue_contacts.txt');
}

/* Exports */
function downloadAllPoses(){
  const combo=combos[currentComboIndex]; if(!combo||!combo.topPoses.length){alert('No poses.');return;}
  const lines=[]; combo.topPoses.forEach((p,i)=>{lines.push(`MODEL        ${i+1}  ${combo.label}`); lines.push(formatPDB(combo.Aviz)); lines.push(formatPDB(applyTransform(combo.B0,p.q,p.t),1)); lines.push('ENDMDL');});
  lines.push('END'); downloadBlob(lines.join('\n'),'all_poses_'+safe(combo.label)+'.pdb');
}
function safe(s){return s.replace(/[^a-z0-9]+/gi,'_');}
function downloadSinglePose(i){
  const combo=combos[currentComboIndex]; if(!combo) return;
  const p=combo.topPoses[i]; const TB=applyTransform(combo.B0,p.q,p.t);
  const pdb=formatPDB(combo.Aviz)+'\n'+formatPDB(TB,1); downloadBlob(pdb,`pose_${i+1}_`+safe(combo.label)+`.pdb`);
}
function downloadCurrentPose(){ const combo=combos[currentComboIndex]; if(!combo){alert('No complex selected.');return;} downloadSinglePose(combo.currentIndex||0); }
function downloadCSV(){
  if(!combos.length){alert('No data');return;}
  const rows=['complex,rank,score,contacts,clash,qx,qy,qz,qw,tx,ty,tz'];
  combos.forEach((combo)=>{ combo.topPoses.forEach((p,i)=>rows.push([`"${combo.label}"`,i+1,p.score.toFixed(4),p.contacts,p.clash.toFixed(4),p.q[0].toFixed(6),p.q[1].toFixed(6),p.q[2].toFixed(6),p.q[3].toFixed(6),p.t.x.toFixed(3),p.t.y.toFixed(3),p.t.z.toFixed(3)].join(','))); });
  downloadBlob(rows.join('\n'),'poses_summary_all_complexes.csv');
}
function downloadJSON(){
  if(!combos.length){alert('No data');return;}
  const out={params:collectDockingParams(), complexes:combos.map(c=>({label:c.label, topPoses:c.topPoses}))};
  downloadBlob(JSON.stringify(out,null,2),'poses_all_complexes.json');
}
function downloadAllComplexesPDB(){
  if(!combos.length){alert('No complexes');return;}
  const lines=[]; let model=1;
  combos.forEach((combo)=>{ combo.topPoses.forEach((p,i)=>{ lines.push(`MODEL        ${model++}  ${combo.label}  pose ${i+1}`); lines.push(formatPDB(combo.Aviz)); lines.push(formatPDB(applyTransform(combo.B0,p.q,p.t),1)); lines.push('ENDMDL'); }); });
  lines.push('END'); downloadBlob(lines.join('\n'),'all_complexes_all_poses.pdb');
}

/* Ligand docking (X5) */
function loadLigandDemoReceptor(){
  E('ligReceptorPDB').value=`ATOM      1  CA  ALA A   1       -8.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  ALA A   2       -6.600   1.200   0.200  1.00  0.00           C
ATOM      3  CA  ALA A   3       -5.200   0.100   1.200  1.00  0.00           C
ATOM      4  CA  ALA A   4       -3.800   1.400   1.400  1.00  0.00           C
ATOM      5  CA  ALA A   5       -2.400   0.500   2.200  1.00  0.00           C
END`;
}
function parseReceptorForLigand(){
  const t=E('ligReceptorPDB').value.trim(); if(!t){alert('Paste receptor PDB first'); return;}
  const atoms=parsePDB(t); viewerLig.clear(); viewerLig.addModel(formatPDB(atoms),'pdb');
  viewerLig.setStyle({},{cartoon:{color:'#60a5fa'}}); viewerLig.zoomTo(); viewerLig.render();
}
function embedSmilesTo3D(smiles, method='HASH', seed=1337){
  const rng = (()=>{let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
  const atoms = smiles.replace(/[^A-Za-z]/g, '').split('').map(e => ({elem: e.toUpperCase(), x: 0, y: 0, z: 0}));
  if (method === 'HASH') {
    for (let i = 0; i < atoms.length; i++) { atoms[i].x = (rng() - 0.5) * 4; atoms[i].y = (rng() - 0.5) * 4; atoms[i].z = (rng() - 0.5) * 4; }
  } else {
    const R = 2.0, pitch = 1.5;
    for (let i = 0; i < atoms.length; i++) {
      const angle = 2 * Math.PI * i / Math.min(atoms.length, 8);
      atoms[i].x = R * Math.cos(angle); atoms[i].y = R * Math.sin(angle); atoms[i].z = i * pitch / Math.min(atoms.length, 8);
    }
  }
  return atoms;
}
async function runSingleLigandDock() {
  const ligStatus = E('ligStatus'); ligStatus.textContent = 'running...';
  try {
    const receptorPDB = E('ligReceptorPDB').value.trim();
    const smiles = E('ligSmiles').value.trim();
    if (!receptorPDB || !smiles) throw new Error('Receptor PDB and Ligand SMILES are required.');
    const receptorAtoms = parsePDB(receptorPDB);
    if (!receptorAtoms.length) throw new Error('Receptor PDB failed to parse.');
    const ligandAtoms    = embedSmilesTo3D(smiles, E('ligEmbedMethod').value, parseInt(E('ligSeed').value));

    const cR = centroid(receptorAtoms);
    const receptorCentered = translate(receptorAtoms, {x: -cR.x, y: -cR.y, z: -cR.z});
    const cL = centroid(ligandAtoms);
    const ligandCentered = translate(ligandAtoms, {x: -cL.x, y: -cL.y, z: -cL.z});

    let bestPose = { score: -Infinity };
    const rng = (()=>{let s=42; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
    for (let i = 0; i < 5000; i++) {
      const q = [rng()*2-1, rng()*2-1, rng()*2-1, rng()*2-1]; const n = Math.hypot(...q)||1; for(let j=0;j<4;j++) q[j]/=n;
      const t = { x: (rng() - 0.5) * 5, y: (rng() - 0.5) * 5, z: (rng() - 0.5) * 5 };
      const posedLigand = applyTransform(ligandCentered, q, t);
      const {score, contacts, clash} = scoreLigand(receptorCentered, posedLigand);
      if (score > bestPose.score) bestPose = { score, contacts, clash, q, t, ligand: posedLigand, receptor: receptorCentered, smiles, receptorPDB };
    }
    ligLastResult = bestPose;
    viewerLig.clear(); viewerLig.addModel(formatPDB(bestPose.receptor), 'pdb'); viewerLig.addModel(formatPDB(bestPose.ligand, 1), 'pdb');
    viewerLig.setStyle({model: 0}, {stick: {radius: 0.2, color: '#60a5fa'}}); viewerLig.setStyle({model: 1}, {stick: {radius: 0.3, color: '#f97316'}});
    viewerLig.zoomTo(); viewerLig.render();
    E('ligScore').textContent = `Best Score: ${bestPose.score.toFixed(2)}, Contacts: ${bestPose.contacts}, Clash: ${bestPose.clash.toFixed(2)}`;
    ligStatus.textContent = 'complete';
  } catch (e) {
    alert('Ligand Docking Failed: ' + e.message); ligStatus.textContent = 'error';
  }
}
function scoreLigand(receptor, ligand){
  let contacts = 0, clash = 0;
  const contactCut = parseFloat(E('contactCut').value) || 4.8;
  const clashFactor = parseFloat(E('clashFactor').value) || 0.85;
  for (const l of ligand) for (const r of receptor){
    const d = Math.hypot(l.x - r.x, l.y - r.y, l.z - r.z);
    const rs = (vdw[(l.elem||'C').toUpperCase()] || 1.7) + (vdw[(r.elem||'C').toUpperCase()] || 1.7);
    if (d < rs * clashFactor) clash += (rs * clashFactor - d);
    else if (d < contactCut) contacts++;
  }
  return { score: contacts - 6.0 * clash, contacts, clash };
}
function downloadLigandPDB(){ if (!('score' in ligLastResult)) return; const pdb = formatPDB(ligLastResult.receptor) + "\n" + formatPDB(ligLastResult.ligand, 1); downloadBlob(pdb, 'ligand_complex.pdb'); }
function downloadLigandCSV(){ if (!('score' in ligLastResult)) return; const row = `smiles,score,contacts,clash\n"${ligLastResult.smiles}",${ligLastResult.score.toFixed(3)},${ligLastResult.contacts},${ligLastResult.clash.toFixed(3)}`; downloadBlob(row, 'ligand_result.csv'); }

/* Batch Screening (X5) */
async function startBatchScreening(){
  E('btnStartScreen').disabled = true; E('btnStopScreen').disabled = false; E('scrStatus').textContent = 'running...'; screenCancel = false;
  try {
    const smilesList = E('scrSmiles').value.trim().split(/\r?\n/).map(s=>s.trim()).filter(s => s);
    const raw = E('scrReceptors').value;
    const receptorPDBs = String(raw||'').split(/\r?\n\s*END\s*(?:\r?\n|$)/).map(s=>s.trim()).filter(Boolean);

    if (smilesList.length > 50 || receptorPDBs.length > 3) throw new Error('Exceeded limits: max 50 SMILES, max 3 receptors.');
    if (receptorPDBs.length===0) throw new Error('Please paste at least one receptor PDB and separate with END if multiple.');

    screenReceptors = receptorPDBs.map((pdb, i) => ({ id: `R${i+1}`, atoms: parsePDB(pdb)}));
    if (screenReceptors.some(r => r.atoms.length === 0)) throw new Error('One or more receptors failed to parse.');

    screenResults = [];
    E('scrTableBody').innerHTML = ''; let count = 0;
    const totalJobs = smilesList.length * screenReceptors.length;

    for (const receptor of screenReceptors) {
      for (const smiles of smilesList) {
        if (screenCancel) break;
        E('scrProgress').textContent = `Processing ${++count} of ${totalJobs}...`;
        await new Promise(resolve => setTimeout(() => {
          const result = dockSingleLigandToReceptor(smiles, receptor.atoms, receptor.id);
          screenResults.push(result); resolve();
        }, 0));
      }
      if (screenCancel) break;
    }
    sortAndDisplayScreeningResults();
    E('scrStatus').textContent = screenCancel ? 'stopped' : 'complete';
  } catch (e) {
    alert('Screening failed: ' + e.message); E('scrStatus').textContent = 'error';
  }
  E('btnStartScreen').disabled = false; E('btnStopScreen').disabled = true;
}
function dockSingleLigandToReceptor(smiles, receptorAtoms, receptorId){
  const embedMethod = E('scrEmbedMethod').value;
  const seed = parseInt(E('scrSeed').value);
  const ligandAtoms = embedSmilesTo3D(smiles, embedMethod, seed + smiles.length);

  const cR = centroid(receptorAtoms);
  const receptorCentered = translate(receptorAtoms.map(a=>({...a})), {x: -cR.x, y: -cR.y, z: -cR.z});
  const cL = centroid(ligandAtoms);
  const ligandCentered = translate(ligandAtoms, {x: -cL.x, y: -cL.y, z: -cL.z});

  let bestPose = { score: -Infinity };
  const rng = (()=>{let s=seed; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
  const samples = parseInt(E('scrSamples').value);

  for (let i = 0; i < samples; i++) {
    const q = [rng()*2-1, rng()*2-1, rng()*2-1, rng()*2-1]; const n=Math.hypot(...q)||1; for(let j=0;j<4;j++) q[j]/=n;
    const t = { x: (rng() - 0.5) * 8, y: (rng() - 0.5) * 8, z: (rng() - 0.5) * 8 };
    const posedLigand = applyTransform(ligandCentered, q, t);
    const { score, contacts, clash } = scoreLigand(receptorCentered, posedLigand);
    if (score > bestPose.score) bestPose = { score, contacts, clash, q, t };
  }
  const metrics = computeInterfaceMetrics(receptorCentered, applyTransform(ligandCentered, bestPose.q, bestPose.t), parseFloat(E('scrContactCut').value));
  const dH = calculateEnthalpy(metrics, 0);
  return { ...bestPose, smiles, receptorId, hb: metrics.hb, sb: metrics.sb, dH, contacts: metrics.contacts, clash: metrics.clash };
}
function sortAndDisplayScreeningResults(){
  const sortBy = E('scrSort').value;
  if (sortBy === 'score') screenResults.sort((a,b) => b.score - a.score);
  else if (sortBy === 'enthalpy') screenResults.sort((a,b) => a.dH - b.dH);
  else {
    const scoreRank = [...screenResults].sort((a,b) => b.score - a.score);
    const dHRank    = [...screenResults].sort((a,b) => a.dH - b.dH);
    const contactRank=[...screenResults].sort((a,b)=> a.contacts - b.contacts);
    const rankMap = new Map();
    const add=(arr)=>arr.forEach((r,i)=>{ const k=r.receptorId+'||'+r.smiles; rankMap.set(k,(rankMap.get(k)||0)+i);});
    add(scoreRank); add(dHRank); add(contactRank);
    screenResults.forEach(r=>{ const k=r.receptorId+'||'+r.smiles; r.cRank = rankMap.get(k); });
    screenResults.sort((a,b)=>a.cRank-b.cRank);
  }
  const body = E('scrTableBody'); body.innerHTML = '';
  screenResults.forEach((r, i) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${i+1}</td><td>${r.receptorId}</td><td class="small">${r.smiles}</td><td>${r.score.toFixed(2)}</td><td>${r.contacts}</td><td>${r.hb}</td><td>${r.sb}</td><td>${r.clash.toFixed(2)}</td><td>${r.dH.toFixed(2)}</td><td>${r.cRank ?? '-'}</td>`;
    tr.addEventListener('click', () => visualizeScreeningPose(r));
    body.appendChild(tr);
  });
}
function visualizeScreeningPose(result){
  const receptor = screenReceptors.find(r => r.id === result.receptorId); if (!receptor) return;
  const ligand = embedSmilesTo3D(result.smiles);
  const cR = centroid(receptor.atoms);
  const receptorCentered = translate(receptor.atoms.map(a=>({...a})), {x: -cR.x, y: -cR.y, z: -cR.z});
  const cL = centroid(ligand);
  const ligandCentered = translate(ligand, {x: -cL.x, y: -cL.y, z: -cL.z});
  const posedLigand = applyTransform(ligandCentered, result.q, result.t);

  viewerScr.clear(); viewerScr.addModel(formatPDB(receptorCentered), 'pdb'); viewerScr.addModel(formatPDB(posedLigand, 1), 'pdb');
  viewerScr.setStyle({model: 0}, {cartoon: {color: '#60a5fa'}}); viewerScr.setStyle({model: 1}, {stick: {radius: 0.3, color: '#f97316'}});
  viewerScr.zoomTo(); viewerScr.render();
}
function downloadScreeningCSV(){
  const header = 'rank,receptor,smiles,score,contacts,clash,h_bonds,salt_bridges,delta_h,consensus_rank\n';
  const rows = screenResults.map((r,i) => [i+1, r.receptorId, `"${r.smiles}"`, r.score.toFixed(3), r.contacts, r.clash.toFixed(3), r.hb, r.sb, r.dH.toFixed(3), r.cRank??''].join(',')).join('\n');
  downloadBlob(header+rows, 'screening_results.csv');
}
function downloadScreeningJSON(){ downloadBlob(JSON.stringify(screenResults, null, 2), 'screening_results.json'); }
function showTop10Screening(){
  const top10 = screenResults.slice(0, 10);
  const dHs = top10.map(r => r.dH);
  const min = Math.min(...dHs), max = Math.max(...dHs), avg = dHs.reduce((a,b) => a+b, 0) / Math.max(1,dHs.length);
  E('screenMetrics').innerHTML =
    `<div class="metric-card"><div class="metric-value">${(isFinite(min)?min:0).toFixed(2)}</div><div class="metric-label">Min ΔH</div></div>
     <div class="metric-card"><div class="metric-value">${(isFinite(max)?max:0).toFixed(2)}</div><div class="metric-label">Max ΔH</div></div>
     <div class="metric-card"><div class="metric-value">${(isFinite(avg)?avg:0).toFixed(2)}</div><div class="metric-label">Avg ΔH</div></div>`;
  E('enthalpyBreakdown').textContent = 'Top 10 ΔH Values:\n' + dHs.map(d => d.toFixed(2)).join(', ');
}

/* QA & Registry (X5) */
function saveCurrentRun(){
  if (!combos.length) { alert('No run data to save.'); return; }
  const topPose = combos[0]?.topPoses[0];
  const run = { timestamp: new Date().toISOString(), type: 'Antibody Docking',
    description: combos.map(c => c.label).join('; '), topScore: topPose ? topPose.score.toFixed(3) : 'N/A',
    signature: '...'+(Math.random().toString(36).substring(2, 8)), data: { combos } };
  const registry = JSON.parse(localStorage.getItem(REGISTRY_KEY) || '[]');
  registry.unshift(run); localStorage.setItem(REGISTRY_KEY, JSON.stringify(registry.slice(0, 50)));
  refreshRunRegistry();
}
function refreshRunRegistry(){
  const registry = JSON.parse(localStorage.getItem(REGISTRY_KEY) || '[]');
  const body = E('registryTableBody'); body.innerHTML = '';
  registry.forEach((run, i) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${new Date(run.timestamp).toLocaleString()}</td><td>${run.type}</td><td>${run.description}</td><td>${run.topScore}</td><td>${run.signature}</td><td><button class="btn small" onclick="loadRun(${i})">Load</button></td>`;
    body.appendChild(tr);
  });
}
function loadRun(index){
  const registry = JSON.parse(localStorage.getItem(REGISTRY_KEY) || '[]');
  const run = registry[index];
  if (run && run.data.combos) { combos = run.data.combos; updateComboSelect(); setCurrentCombo(0); alert('Run loaded.'); }
}
function clearRunRegistry(){ if (confirm('Clear entire run registry?')) { localStorage.removeItem(REGISTRY_KEY); refreshRunRegistry(); }}
function exportAllRuns(){ const data = localStorage.getItem(REGISTRY_KEY) || '[]'; downloadBlob(data, 'docking_registry.json'); }
function importRunRegistry(){
  E('importRegistryFile').click();
  E('importRegistryFile').onchange = async (e) => {
    try { const text = await fileToText(e.target.files[0]); const data = JSON.parse(text);
      if (Array.isArray(data)) { localStorage.setItem(REGISTRY_KEY, JSON.stringify(data)); refreshRunRegistry(); alert('Registry imported.'); }
      else { alert('Invalid format.'); } }
    catch(err) { alert('Import failed: ' + err.message); }
  };
}
async function runQATest(){
  const repeats = parseInt(E('qaRepeats').value); const tolerance = parseFloat(E('qaTolerance').value);
  const qaResults = E('qaResults'); qaResults.textContent = 'Running QA test...';
  if (!combos.length || !combos[0]) { qaResults.textContent = 'No docking run available to test.'; return; }
  const scores = []; const params = collectDockingParams();
  for (let i = 0; i < repeats; i++) { await dockSingleCombo(0, params, ()=>{}); const topScore = combos[0]?.topPoses[0]?.score; if (topScore||topScore===0) scores.push(topScore); }
  const avg = scores.reduce((a, b) => a + b, 0) / Math.max(1,scores.length);
  const maxDiff = (Math.max(...scores) - Math.min(...scores)) || 0;
  const pass = maxDiff <= tolerance;
  qaResults.textContent = `QA Test Results (${repeats} repeats):\nScores: ${scores.map(s=>s.toFixed(3)).join(', ')}\nAverage Score: ${avg.toFixed(3)}\nMax Difference: ${maxDiff.toFixed(3)}\nTolerance: ${tolerance.toFixed(3)}\nResult: ${pass ? '✅ PASSED' : '❌ FAILED'}`;
}

/* Session Save/Load */
function saveSession(){
  const state = { pdbAText: E('pdbAText').value, pdbBText: E('pdbBText').value, params: collectDockingParams(), dockingResults: combos };
  downloadBlob(JSON.stringify(state), 'docking_session.json');
}
function loadSession(){
  const input = document.createElement('input'); input.type = 'file'; input.accept = '.json';
  input.onchange = async (e) => {
    try {
      const text = await e.target.files[0].text(); const state = JSON.parse(text);
      E('pdbAText').value = state.pdbAText || ''; E('pdbBText').value = state.pdbBText || '';
      if (state.params) { Object.keys(state.params).forEach(k => { const el = E(k); if (el && state.params[k]!==undefined) el.value = state.params[k]; }); }
      if (state.dockingResults) { combos = state.dockingResults; updateComboSelect(); setCurrentCombo(0); }
      alert('Session loaded.');
    } catch(err) { alert('Failed to load session: ' + err.message); }
  };
  input.click();
}
function loadSessionHistory(){ refreshRunRegistry(); }

/* Demo */
function useExample(which){
  if(which==='A'){
    E('pdbAText').value=`ATOM      1  CA  GLY A   1       10.000  10.000  10.000  1.00  0.00           C
ATOM      2  CA  ALA A   2       12.000  11.000  10.500  1.00  0.00           C`;
  } else {
    E('pdbBText').value=`ATOM      1  CA  PRO B   1       15.000  15.000  15.000  1.00  0.00           C
ATOM      2  CA  LEU B   2       17.000  14.000  15.500  1.00  0.00           C`;
  }
}
async function autoDemo(){ useExample('A'); useExample('B'); E('samples').value=2000; await runAntibodyDocking(); }

/* ===== CDR / Fragment module (merged) ===== */
const AntibodyPDB = (function() {
  const THREE_LETTER_TO_ONE = { ALA:'A', ARG:'R', ASN:'N', ASP:'D', CYS:'C', GLN:'Q', GLU:'E', GLY:'G', HIS:'H', ILE:'I', LEU:'L', LYS:'K', MET:'M', PHE:'F', PRO:'P', SER:'S', THR:'T', TRP:'W', TYR:'Y', VAL:'V', SEC:'U', PYL:'O' };
  function parsePDB(pdbText) {
    const lines = pdbText.split(/\r?\n/);
    const atomsByChainResidue = new Map();
    for (const line of lines) {
      if (!line.startsWith('ATOM')) continue;
      const atomName = line.slice(12, 16).trim();
      const resName = line.slice(17, 20).trim();
      const chainId = line.slice(21, 22).trim() || ' ';
      const resSeq = parseInt(line.slice(22, 26).trim(), 10);
      const iCode = line.slice(26, 27).trim();
      const x = parseFloat(line.slice(30, 38).trim());
      const y = parseFloat(line.slice(38, 46).trim());
      const z = parseFloat(line.slice(46, 54).trim());
      const key = `${chainId}|${resSeq}|${iCode || ''}`;
      let entry = atomsByChainResidue.get(key);
      if (!entry) { entry = { chain: chainId, resSeq, iCode, resName, atoms: [] }; atomsByChainResidue.set(key, entry); }
      entry.atoms.push({ atomName, x, y, z });
      if (atomName === 'CA') entry.ca = { x, y, z };
    }
    const chains = new Map();
    for (const entry of atomsByChainResidue.values()) {
      const arr = chains.get(entry.chain) || [];
      arr.push(entry);
      chains.set(entry.chain, arr);
    }
    const perChain = {};
    for (const [chainId, residues] of chains) {
      residues.sort((a,b)=> a.resSeq-b.resSeq || (a.iCode||'').localeCompare(b.iCode||''));
      const caTrace = residues.filter(r=>r.ca).map(r => ({ resSeq:r.resSeq, iCode:r.iCode||'', resName:r.resName, x:r.ca.x, y:r.ca.y, z:r.ca.z }));
      const seqOne = residues.map(r => THREE_LETTER_TO_ONE[r.resName.toUpperCase()] || 'X').join('');
      perChain[chainId] = {
        chainId,
        sequence: seqOne,
        residues: residues.map(r => ({ resSeq:r.resSeq, iCode:r.iCode||'', resName:r.resName, oneLetter: THREE_LETTER_TO_ONE[r.resName.toUpperCase()] || 'X', hasCA:Boolean(r.ca) })),
        caTrace
      };
    }
    return { chains: perChain };
  }
  function classifyChainType(seq){
    const len = seq.length;
    const likelyVariableLen = len >= 95 && len <= 130;
    const hasCys = (seq.match(/C/g) || []).length >= 2;
    const hasTrp = seq.includes('W');
    const heavySigns = [ /GGG/.test(seq), /WGQG/.test(seq), /VLVL|TLVL/.test(seq) ];
    const lightSigns = [ /FGG/.test(seq), /LQMT|IQMT|MQMT/.test(seq), /WYQQ/.test(seq) ];
    let scoreH=0, scoreL=0;
    if (likelyVariableLen) {scoreH++; scoreL++;}
    if (hasCys) {scoreH++; scoreL++;}
    if (hasTrp) {scoreH++; scoreL++;}
    for (const r of heavySigns) if (r) scoreH++;
    for (const r of lightSigns) if (r) scoreL++;
    if (scoreH >= scoreL + 1) return 'H';
    if (scoreL >= scoreH + 1) return 'L';
    return 'Unknown';
  }
  const CDR_INDEX_RANGES = {
    Kabat: { H: { CDR1: [26,35], CDR2: [50,65], CDR3: [95,115] }, L: { CDR1: [23,34], CDR2: [49,56], CDR3: [88,98] } },
    Chothia:{ H: { CDR1: [26,32], CDR2: [52,56], CDR3: [95,110] }, L: { CDR1: [26,32], CDR2: [50,52], CDR3: [91,96] } },
    IMGT:  { H: { CDR1: [27,38], CDR2: [56,65], CDR3: [103,117] }, L: { CDR1: [27,38], CDR2: [56,65], CDR3: [103,117] } }
  };
  function anchorAlignmentOffsets(seq, chainType){
    const idxCys = seq.indexOf('C');
    const idxTrp = seq.indexOf('W', Math.max(20, idxCys + 10));
    const base = idxCys >= 0 ? idxCys - 23 : 0;
    const trpAdj = idxTrp >= 0 ? (idxTrp - (chainType === 'H' ? 41 : 35)) : 0;
    return Math.round(0.6*base + 0.3*trpAdj);
  }
  function computeCDRsForChain(chainData, scheme='Kabat'){
    const seq = chainData.sequence || '';
    if (!seq) return { scheme, cdrs: [], frames: [], note: 'No sequence' };
    const chainType = classifyChainType(seq);
    const ranges = CDR_INDEX_RANGES[scheme] || CDR_INDEX_RANGES.Kabat;
    const rangesForChain = ranges[chainType === 'H' ? 'H' : 'L'];
    const offset = anchorAlignmentOffsets(seq, chainType);
    const cdrs = Object.entries(rangesForChain).map(([region,[s,e]])=>{
      const start = Math.max(0, Math.min(s + offset, seq.length - 1));
      const end    = Math.max(0, Math.min(e + offset, seq.length - 1));
      return { region, start, end, sequence: seq.slice(start, end + 1) };
    });
    const frames = [];
    if (cdrs[0].start > 0) frames.push({ region: 'FR1', start: 0, end: cdrs[0].start - 1 });
    frames.push({ region: 'FR2', start: cdrs[0].end + 1, end: cdrs[1].start - 1 });
    frames.push({ region: 'FR3', start: cdrs[1].end + 1, end: cdrs[2].start - 1 });
    frames.push({ region: 'FR4', start: cdrs[2].end + 1, end: seq.length - 1 });
    return { scheme, chainType, cdrs, frames, note: 'Heuristic mapping' };
  }
  function annotateAntibodyChains(parsed){
    const result = {};
    for (const chainId of Object.keys(parsed.chains)) {
      const chain = parsed.chains[chainId];
      const type = classifyChainType(chain.sequence);
      result[chainId] = {
        chainId, chainType: type, sequenceLength: chain.sequence.length,
        cdrs: {
          Kabat: computeCDRsForChain(chain,'Kabat'),
          Chothia: computeCDRsForChain(chain,'Chothia'),
          IMGT: computeCDRsForChain(chain,'IMGT')
        },
        caTrace: chain.caTrace
      };
    }
    return result;
  }
  function makeFragments(chainData, windowSize=10, step=1){
    const { caTrace } = chainData;
    if (!caTrace || !caTrace.length) return [];
    const frags=[];
    for (let i=0; i+windowSize<=caTrace.length; i+=step) {
      const coords=caTrace.slice(i,i+windowSize);
      frags.push({ startIndex:i, endIndex:i+windowSize-1, sequence: coords.map(r=>THREE_LETTER_TO_ONE[r.resName.toUpperCase()]||'X').join(''), caCoords: coords });
    }
    return frags;
  }
  return { parsePDB, classifyChainType, computeCDRsForChain, annotateAntibodyChains, makeFragments };
})();

/* CDR UI */
let currentParsedAb=null, currentCDRAnnotations=null;
function bindCDRControls(){
  ['showCDR1','showCDR2','showCDR3','showFrameworks'].forEach(id=>{
    const el=E(id); if(el){ el.addEventListener('change', ()=>{ if(currentParsedAb&&currentCDRAnnotations){ visualizeCDRs(currentParsedAb,currentCDRAnnotations,E('schemeSelect').value); } }); }
  });
}
function copyAbPDBToCDR(){ const txt=E('pdbAText').value.trim(); if(!txt){alert('No Antibody PDB in Protein A');return;} E('cdrPDB').value=txt; }
function runCDRAnalysis(){
  const pdbText = E('cdrPDB').value || E('pdbAText').value;
  if (!pdbText) { alert('Please provide a PDB structure'); return; }
  const parsed = AntibodyPDB.parsePDB(pdbText);
  const annotations = AntibodyPDB.annotateAntibodyChains(parsed);
  const scheme = E('schemeSelect').value;
  currentParsedAb = parsed;
  currentCDRAnnotations = annotations;
  displayCDRResults(annotations, scheme);
  visualizeCDRs(parsed, annotations, scheme);
  displayCDRSequenceTable(annotations, scheme);
}
function displayCDRResults(annotations, scheme){
  const container=E('cdrResults'); let html='';
  for (const chainId in annotations) {
    const chain=annotations[chainId];
    const cdrData=chain.cdrs[scheme];
    html += `
      <div class="scheme-card">
        <h4>Chain ${chainId} (${chain.chainType})</h4>
        <div style="font-size:12px;color:#9ca3af">Length: ${chain.sequenceLength} aa</div>
        ${cdrData.cdrs.map(cdr=>`
          <div class="cdr-highlight">
            <strong>${cdr.region}</strong>:
            <span class="cdr-region">${cdr.sequence||'-'}</span>
            <span style="font-size:11px;color:#6b7280">[${cdr.start}-${cdr.end}]</span>
          </div>
        `).join('')}
      </div>`;
  }
  container.innerHTML=html || '<div class="infobox small">No chains parsed.</div>';
}
function visualizeCDRs(parsed, annotations, scheme){
  if (!viewerCDR) return; viewerCDR.clear();
  for (const chainId in parsed.chains) {
    const chain = parsed.chains[chainId];
    const cdrData = annotations[chainId]?.cdrs[scheme];
    if (!cdrData) continue;
    let pdbText='';
    chain.caTrace.forEach((res, idx)=>{
      pdbText += `ATOM  ${String(idx+1).padStart(5)} CA   ${res.resName.padEnd(3)} ${chainId}${String(res.resSeq).padStart(4)}    ${res.x.toFixed(3).padStart(8)}${res.y.toFixed(3).padStart(8)}${res.z.toFixed(3).padStart(8)}  1.00  0.00           C\n`;
    });
    viewerCDR.addModel(pdbText,'pdb');
    const modelIdx = viewerCDR.getNumModels()-1;
    const show = {1:E('showCDR1')?.checked,2:E('showCDR2')?.checked,3:E('showCDR3')?.checked};
    const cols=['#f87171','#fbbf24','#34d399'];
    cdrData.cdrs.forEach((cdr,i)=>{
      if (show[i+1]) {
        viewerCDR.setStyle(
          {model:modelIdx, resi: Array.from({length: cdr.end-cdr.start+1}, (_,k)=> cdr.start + k + 1)},
          {cartoon:{color:cols[i%3]}}
        );
      }
    });
    if (E('showFrameworks')?.checked) { viewerCDR.setStyle({model:modelIdx}, {cartoon:{color:'#4b5563'}}); }
  }
  viewerCDR.zoomTo(); viewerCDR.render();
}
function displayCDRSequenceTable(annotations, scheme){
  const container=E('cdrSequenceTable');
  let html='<table class="table"><thead><tr><th>Chain</th><th>Type</th><th>Region</th><th>Sequence</th><th>Position</th></tr></thead><tbody>';
  for (const chainId in annotations) {
    const chain=annotations[chainId];
    const cdrData=chain.cdrs[scheme];
    cdrData.cdrs.forEach(cdr=>{
      html+=`<tr><td>${chainId}</td><td>${chain.chainType}</td><td>${cdr.region}</td><td style="font-family:monospace">${cdr.sequence}</td><td>${cdr.start+1}-${cdr.end+1}</td></tr>`;
    });
  }
  html+='</tbody></table>'; container.innerHTML=html;
}

/* Fragment generator */
function generateFragments(){
  const pdbText = E('fragPDB').value;
  if (!pdbText) { alert('Please provide a PDB structure'); return; }
  const windowSize = parseInt(E('windowSize').value) || 10;
  const stepSize = parseInt(E('stepSize').value) || 1;
  const chainFilter = E('chainFilter').value.split(',').map(s=>s.trim()).filter(Boolean);

  const parsed = AntibodyPDB.parsePDB(pdbText);
  const resultsContainer = E('fragmentResults');
  let html = '<h3>Generated Fragments</h3>'; let allFragments=[];

  for (const chainId in parsed.chains) {
    if (chainFilter.length && !chainFilter.includes(chainId)) continue;
    const chain = parsed.chains[chainId];
    const fragments = AntibodyPDB.makeFragments(chain, windowSize, stepSize);
    allFragments.push({chainId, fragments});
    html += `<div class="card">
      <h4>Chain ${chainId}: ${fragments.length} fragments</h4>
      <div style="max-height:200px;overflow:auto">
        ${fragments.slice(0, 10).map((frag,i)=>`
          <div style="font-family:monospace;font-size:12px;padding:4px;background:#0a0f1a;margin:2px 0;border-radius:4px">
            Fragment ${i+1}: ${frag.sequence} [${frag.startIndex}-${frag.endIndex}]
          </div>`).join('')}
        ${fragments.length > 10 ? `<div style="color:#9ca3af;font-size:12px">... and ${fragments.length - 10} more</div>` : ''}
      </div>
    </div>`;
  }
  resultsContainer.innerHTML = html;
  window.generatedFragments = allFragments;
}
function downloadFragments(){
  if (!window.generatedFragments || !window.generatedFragments.length) { alert('No fragments generated yet'); return; }
  let pdbContent=''; let fragNum=1;
  window.generatedFragments.forEach(({chainId,fragments})=>{
    fragments.forEach(frag=>{
      pdbContent += `MODEL        ${fragNum}\n`;
      frag.caCoords.forEach((coord,i)=>{
        pdbContent += `ATOM  ${String(i+1).padStart(5)} CA   ${coord.resName.padEnd(3)} ${chainId}${String(coord.resSeq).padStart(4)}    ${coord.x.toFixed(3).padStart(8)}${coord.y.toFixed(3).padStart(8)}${coord.z.toFixed(3).padStart(8)}  1.00  0.00           C\n`;
      });
      pdbContent += `ENDMDL\n`; fragNum++;
    });
  });
  pdbContent += 'END\n';
  downloadBlob(pdbContent, 'fragments.pdb');
}

/* NMR & Omics (X5) */
function bindOmicsAndNMREvents(){
  E('nmrSmiles').addEventListener('input', updateNMRImage);
  E('btnPredict1H').addEventListener('click', () => predictNMR('1H'));
  E('btnPredict13C').addEventListener('click', () => predictNMR('13C'));
  E('btnPredictCOSY').addEventListener('click', () => predictNMR('COSY'));
  E('btnPredictNOESY').addEventListener('click', () => predictNMR('NOESY'));

  const B=(id,fn)=>{ const el=E(id); if(el) el.addEventListener('click', fn); };
  B('omicsLoadProteinDemo',()=>{E('omicsProteinPDB').value=`ATOM      1  CA  ALA A   1         0.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  LEU A   2         1.500   1.200   0.200  1.00  0.00           C
ATOM      3  CA  LYS A   3         3.000   0.100   1.000  1.00  0.00           C
ATOM      4  CA  ASP A   4         4.300   1.400   1.400  1.00  0.00           C
END`;});
  B('omicsLoadLipidDemo',()=>{E('omicsLipidSmiles').value=`CCCCCCCCCCCC=CCCCCC(=O)OCCN(C)CH3
CCOC(=O)CCCCCCCCCCCC
CCCCCCCCCCCCCCCC(=O)OCCOP(=O)(O)OCCN`});
  B('omicsLoadCarbDemo',()=>{E('omicsCarbSmiles').value=`OC[C@H]1O[C@@H](O)[C@H](O)[C@@H](O)[C@H]1O
O[C@H]1CO[C@@H](O)[C@H](O)[C@H]1O`;});
  B('omicsLoadDNADemo',()=>{E('omicsDNA').value=`>demo
ACGTACGTGGCCGGTTTTAAAACGCGCGTTTACGCGCAGCGCGGATATATATATAGCGC`});
  B('omicsAnalyzeBtn', runOmicsAnalysis);
  B('omicsExportBtn', ()=>{ if(lastOmics) downloadBlob(JSON.stringify(lastOmics,null,2),'omics_results.json'); else alert('Run analysis first.');});
}
async function updateNMRImage(){
  const smiles = E('nmrSmiles').value.trim();
  const imgDiv = E('nmrMoleculeImage');
  if (!smiles) { imgDiv.style.backgroundImage = 'none'; imgDiv.textContent=''; return; }
  imgDiv.textContent = 'Structure preview requires a server-side toolkit (e.g., RDKit).';
  imgDiv.style.textAlign = 'center'; imgDiv.style.padding = '20px';
}
function predictNMR(type){
  const smiles = E('nmrSmiles').value.trim(); const output = E('nmrPredictionOutput');
  if (!smiles) { output.textContent = 'Please enter a SMILES string.'; return; }
  let txt = `--- THEORETICAL ${type} PREDICTION FOR ${smiles} ---\n\n`;
  if (smiles === 'CC(=O)Oc1ccccc1C(=O)O'){
    if(type==='1H'){ txt += `Aspirin, CDCl3 (typical):\n- CH3 singlet ~2.3 ppm (3H)\n- Ar multiplet 7.1–8.2 ppm (4H)\n- COOH broad >10 ppm`; }
    else if(type==='13C'){ txt += `9 carbons: CH3 ~21; C=O(ester) ~169; C=O(acid) ~171; ring 120–155 ppm`; }
    else if(type==='COSY'){ txt += `Ortho ring couplings visible; CH3 isolated`; }
    else if(type==='NOESY'){ txt += `NOE: CH3 ↔ ortho aryl possible; ring proximities`; }
  } else { txt += 'Demo provides a detailed aspirin template. For others, interpret via analogy.'; }
  output.textContent = txt;
}

/* OMICS ANALYZER (X5) */
let lastOmics=null;
function runOmicsAnalysis(){
  E('omicsStatus').textContent='running...';
  try{
    const proteinPDB = (E('omicsProteinPDB').value||'').trim();
    const lipidSmiles = (E('omicsLipidSmiles').value||'').trim().split(/\r?\n/).filter(Boolean);
    const carbSmiles  = (E('omicsCarbSmiles').value||'').trim().split(/\r?\n/).filter(Boolean);
    const dnaText     = (E('omicsDNA').value||'').trim();

    const protAtoms = parsePDB(proteinPDB);
    const aa = summarizeResidues(protAtoms);
    const protDesc = {
      residues: aa.total,
      hydrophobic_fraction: round2(aa.hydrophobic/Math.max(1,aa.total)),
      charged_fraction: round2((aa.acidic+aa.basic)/Math.max(1,aa.total)),
      acidic: aa.acidic, basic: aa.basic, polar: aa.polar, hydrophobic: aa.hydrophobic
    };

    const lipDesc = summarizeSmilesSet(lipidSmiles);
    const carbDesc = summarizeSmilesSet(carbSmiles);
    const dnaDesc = summarizeDNA(dnaText);

    const trends = inferTrends(protDesc, lipDesc, carbDesc, dnaDesc);

    const rows = [];
    const add = (k,v)=> rows.push(`<tr><td>${k}</td><td>${typeof v==='number'? (''+v): v}</td></tr>`);
    add('Protein residues', protDesc.residues);
    add('Protein hydrophobic fraction', protDesc.hydrophobic_fraction);
    add('Protein charged fraction', protDesc.charged_fraction);

    add('Lipids: count', lipDesc.count);
    add('Lipids: avg heteroatom %', round3(lipDesc.avgHetPct));
    add('Lipids: avg unsaturation idx', round3(lipDesc.avgUnsat));
    add('Lipids: avg ring count', round3(lipDesc.avgRings));

    add('Carbs: count', carbDesc.count);
    add('Carbs: avg heteroatom %', round3(carbDesc.avgHetPct));
    add('Carbs: avg unsaturation idx', round3(carbDesc.avgUnsat));
    add('Carbs: avg ring count', round3(carbDesc.avgRings));

    add('DNA: total bp', dnaDesc.total);
    add('DNA: GC %', round2(dnaDesc.gc*100));
    add('DNA: CpG / kb', round3(dnaDesc.cpgPerKb));
    add('DNA: top 3-mers', dnaDesc.top3mers.map(x=>x[0]+':'+x[1]).join(', '));

    E('omicsDescriptorBody').innerHTML = rows.join('');
    E('omicsTrends').textContent = trends.join('\n');
    lastOmics={protein:protDesc, lipids:lipDesc, carbs:carbDesc, dna:dnaDesc, trends};
    E('omicsStatus').textContent='complete';
  }catch(err){
    alert('Omics analysis failed: '+err.message);
    E('omicsStatus').textContent='error';
  }
}
function summarizeResidues(atoms){
  const byRes=new Map();
  for(const a of atoms){ const key=(a.chain||'A')+':' +(a.resi||0); if(!byRes.has(key)) byRes.set(key,{resn:a.resn}); }
  const names=[...byRes.values()].map(x=>x.resn||'UNK');
  const acidic = names.filter(x=>x==='ASP'||x==='GLU').length;
  const basic  = names.filter(x=>x==='LYS'||x==='ARG'||x==='HIS').length;
  const hyd    = names.filter(x=>hydrophobic.has(x)).length;
  const polar  = Math.max(0, names.length - acidic - basic - hyd);
  return { total:names.length, acidic, basic, polar, hydrophobic:hyd };
}
function summarizeSmilesSet(list){
  if(!list.length) return {count:0, avgHetPct:0, avgUnsat:0, avgRings:0};
  let hetPct=0, unsat=0, rings=0;
  for(const s of list){
    const desc = smilesDescriptors(s);
    hetPct += desc.hetPct; unsat += desc.unsaturation; rings += desc.rings;
  }
  return {count:list.length, avgHetPct:hetPct/list.length, avgUnsat:unsat/list.length, avgRings:rings/list.length};
}
function smilesDescriptors(s){
  const atoms = (s.match(/[A-Z][a-z]?/g)||[]);
  const het   = atoms.filter(a=>!/^C$/.test(a)).length;
  const total = atoms.length||1;
  const hetPct = het/total;
  const unsaturation = (s.match(/=/g)||[]).length + (s.match(/#|\\\\|\\//g)||[]).length*0.5;
  const rings = (s.match(/\d/g)||[]).length/2;
  return {hetPct, unsaturation, rings};
}
function summarizeDNA(txt){
  const seqs = parseFASTA(txt);
  const seq = seqs.join('').toUpperCase().replace(/[^ACGT]/g,'');
  const total = seq.length;
  const gc = total? ((seq.match(/[GC]/g)||[]).length/total):0;
  const cpg = (seq.match(/CG/g)||[]).length;
  const cpgPerKb = total? (cpg/(total/1000)):0;
  const km3 = kmerCounts(seq,3);
  const top3 = Object.entries(km3).sort((a,b)=>b[1]-a[1]).slice(0,5);
  return {total, gc, cpgPerKb, top3mers: top3};
}
function parseFASTA(t){
  if(!t) return [];
  const lines=t.split(/\r?\n/);
  const seqs=[]; let cur=[];
  for(const ln of lines){
    if(ln.startsWith('>')){ if(cur.length){ seqs.push(cur.join('')); cur=[]; } }
    else { cur.push(ln.trim()); }
  }
  if(cur.length) seqs.push(cur.join(''));
  return seqs.length?seqs:[''];
}
function kmerCounts(seq,k){
  const out={}; if(seq.length<k) return out;
  for(let i=0;i<=seq.length-k;i++){ const km=seq.slice(i,i+k); out[km]=(out[km]||0)+1; }
  return out;
}
function inferTrends(prot, lip, carb, dna){
  const trends=[];
  if(prot.hydrophobic_fraction>0.45 && lip.avgUnsat<1) trends.push('Membrane-leaning protein hydrophobicity with low lipid unsaturation suggests tighter, ordered microdomains.');
  if(carb.avgHetPct>0.35 && prot.charged_fraction>0.2) trends.push('High carbohydrate heteroatom% with higher protein charge hints at glycan-mediated recognition interfaces.');
  if(dna.gc>0.55 && lip.avgRings>0.4) trends.push('GC-rich DNA with ring-rich lipids may correlate with raft-associated chromatin-proximal signaling (heuristic).');
  if(!trends.length) trends.push('No strong cross-modal signals detected with the simple heuristics — consider richer toolkits (RDKit, proteomics ID, motif scans).');
  return trends;
}
const round2=x=>Math.round(x*100)/100;
const round3=x=>Math.round(x*1000)/1000;

function resetAll(){
  pdbAAllAtoms=[]; pdbBAllAtoms=[]; combos=[]; currentComboIndex=-1;
  ['pdbAText','pdbBText'].forEach(id=>E(id).value='');
  updateComboSelect(); E('poseControls').innerHTML=''; E('scoreBox').textContent=''; E('metricsDisplay').innerHTML='';
  viewer?.clear(); viewerLig?.clear(); viewerScr?.clear(); viewerComp?.clear(); viewerCDR?.clear(); viewerDesign?.clear();
  drawPlaceholder(viewer); drawPlaceholder(viewerDesign); status('idle'); setProgress(0);
}

/* ======================================================== */
/* ===== START OF NAMESPACED AbDesigner SCRIPT ============ */
/* ======================================================== */

// Immunoglobulin Selection
function abDesign_selectIg(igType) {
  // Update selection
  document.querySelectorAll('.ig-option').forEach(opt => {
    opt.classList.remove('selected');
  });
  E('ig-' + igType).classList.add('selected');
  
  abDesign_selectedIg = igType;
  
  // Update CDRs based on selection
  abDesign_updateCDRsForIg(igType);
  
  // Update predicted properties
  abDesign_updatePredictions();
}

// CDR Templates for each Ig
const abDesign_cdrTemplates = {
  IgG: {
    H1: 'GFTFSSY', H2: 'ISGSGGST', H3: 'AREGYCSSGSCYFD',
    L1: 'QSISSY', L2: 'AAS', L3: 'QQYGSSPT'
  },
  IgA: {
    H1: 'GYTFTNY', H2: 'INPSGGYT', H3: 'ARHGNYGYALDY',
    L1: 'QSVSSN', L2: 'GAS', L3: 'QQYNNWPT'
  },
  IgM: {
    H1: 'GFSLSTY', H2: 'IWWDGDK', H3: 'ARRGVYCSSTSCYFDY',
    L1: 'QSLVHS', L2: 'KVS', L3: 'MQATQFPT'
  },
  IgE: {
    H1: 'GFTFDDH', H2: 'ISWNSGSI', H3: 'AKDGYYDILTGYFDY',
    L1: 'QGISSW', L2: 'AAS', L3: 'QQANSFPT'
  },
  IgD: {
    H1: 'GYTFTSF', H2: 'INTNTGNP', H3: 'ARDLRTGPFDY',
    L1: 'QNVGTN', L2: 'SAS', L3: 'QQYDNLPT'
  }
};

function abDesign_updateCDRsForIg(igType) {
  const cdrs = abDesign_cdrTemplates[igType];
  E('cdr-h1').textContent = cdrs.H1;
  E('cdr-h2').textContent = cdrs.H2;
  E('cdr-h3').textContent = cdrs.H3;
  E('cdr-l1').textContent = cdrs.L1;
  E('cdr-l2').textContent = cdrs.L2;
  E('cdr-l3').textContent = cdrs.L3;
}

// Generate Antibody
function abDesign_generateAntibody() {
  abDesign_antibodyCount++;
  // E('antibody-count').textContent = abDesign_antibodyCount; // Header stats removed for simplicity
  
  const scaffoldType = E('scaffold-type').value;
  
  abDesign_currentAntibody = {
    target: abDesign_selectedIg,
    scaffold: scaffoldType,
    cdrs: {
      H1: E('cdr-h1').textContent,
      H2: E('cdr-h2').textContent,
      H3: E('cdr-h3').textContent,
      L1: E('cdr-l1').textContent,
      L2: E('cdr-l2').textContent,
      L3: E('cdr-l3').textContent
    },
    affinity: Math.random() * 100 + 1,
    specificity: Math.random() * 0.5 + 0.5
  };
  
  // Update displays
  abDesign_updatePredictions();
  abDesign_updateVisualization();
  abDesign_updateAnalysis();
  
  alert('Antibody generated successfully!');
}

// Optimize CDRs
function abDesign_optimizeCDRs() {
  const optimized = {
    H3: abDesign_generateOptimizedCDR('H3'),
    H2: abDesign_generateOptimizedCDR('H2')
  };
  
  E('cdr-h3').textContent = optimized.H3;
  E('cdr-h2').textContent = optimized.H2;
  
  abDesign_updatePredictions();
  alert('CDRs optimized for ' + abDesign_selectedIg + ' targeting');
}

function abDesign_generateOptimizedCDR(cdrType) {
  const aminoAcids = 'ACDEFGHIKLMNPQRSTVWY';
  const lengths = { H3: 14, H2: 8 };
  let cdr = 'AR';
  
  for (let i = 0; i < (lengths[cdrType] || 10) - 4; i++) {
    cdr += aminoAcids[Math.floor(Math.random() * aminoAcids.length)];
  }
  
  cdr += 'FDY';
  return cdr;
}

// Update Predictions
function abDesign_updatePredictions(structureGuided = false) {
  let affinity, specificity, stability, humanization, expression;
  
  if (structureGuided && abDesign_antigenStructure) {
    // Structure-guided design yields better predictions
    // Affinity improves with structure-based design (lower KD = better)
    affinity = Math.random() * 10 + 0.5; // 0.5-10.5 nM (much better than random)
    specificity = Math.random() * 0.15 + 0.85; // 0.85-1.0 (high specificity)
    stability = Math.random() * 8 + 72; // 72-80°C (more stable)
    humanization = Math.random() * 8 + 92; // 92-100% (highly humanized)
    expression = 'Very High';
    
    // Apply bonus based on antigen characteristics
    const epitopeBonus = 1.0 / (1.0 + abDesign_antigenStructure.epitopeRadius / 10);
    affinity *= epitopeBonus; // Smaller epitope = better affinity potential
    
  } else {
    // Random/template-based design
    affinity = Math.random() * 50 + 1; // 1-51 nM
    specificity = Math.random() * 0.4 + 0.6; // 0.6-1.0
    stability = Math.random() * 10 + 68; // 68-78°C
    humanization = Math.random() * 15 + 85; // 85-100%
    expression = Math.random() > 0.5 ? 'High' : 'Medium';
  }
  
  const affinityPercent = Math.max(10, 100 - affinity * 3);
  
  E('affinity-meter').style.width = affinityPercent + '%';
  E('affinity-meter').querySelector('.meter-value').textContent = affinity.toFixed(1) + ' nM';
  
  E('specificity-score').textContent = specificity.toFixed(2);
  E('stability-tm').textContent = stability.toFixed(0) + '°C';
  E('humanization').textContent = humanization.toFixed(0) + '%';
  E('expression').textContent = expression;
  
  // Visual feedback for structure-guided design
  if (structureGuided) {
    E('affinity-meter').style.background = 'linear-gradient(90deg, #10b981, #34d399)';
  } else {
    E('affinity-meter').style.background = 'linear-gradient(90deg, #2563eb, #7dd3fc)';
  }
}

// Epitope Database
const abDesign_epitopeDatabase = [
  { ig: 'IgG', region: 'CH2-CH3 interface', position: '233-267', accessibility: 0.85, conservation: 0.95, relevance: 'FcRn binding - half-life' },
  { ig: 'IgG', region: 'Lower hinge', position: '226-236', accessibility: 0.95, conservation: 0.90, relevance: 'C1q binding - CDC' },
  { ig: 'IgA', region: 'Tailpiece', position: '453-470', accessibility: 0.95, conservation: 0.90, relevance: 'Polymerization' },
  { ig: 'IgM', region: 'Cμ4 domain', position: '440-475', accessibility: 0.65, conservation: 0.93, relevance: 'Complement activation' },
  { ig: 'IgE', region: 'Cε3 FcεRI', position: '335-368', accessibility: 0.88, conservation: 0.96, relevance: 'Mast cell activation' },
  { ig: 'IgD', region: 'Hinge region', position: '182-217', accessibility: 0.98, conservation: 0.75, relevance: 'B cell signaling' }
];

function abDesign_loadEpitopes() {
  const tbody = E('epitope-tbody');
  if (!tbody) return;
  
  abDesign_epitopeDatabase.forEach(epitope => {
    const row = `
      <tr>
        <td><span class="pill">${epitope.ig}</span></td>
        <td>${epitope.region}</td>
        <td>${epitope.position}</td>
        <td>${(epitope.accessibility * 100).toFixed(0)}%</td>
        <td>${(epitope.conservation * 100).toFixed(0)}%</td>
        <td>${epitope.relevance}</td>
        <td><button class="btn" onclick="abDesign_targetEpitope('${epitope.ig}')">Target</button></td>
      </tr>
    `;
    tbody.innerHTML += row;
  });
}

function abDesign_targetEpitope(ig) {
  abDesign_selectIg(ig);
  // Activate the 'abDesignTab'
  document.querySelector('.tabbtn[data-tab="abDesignTab"]').click();
  alert('Targeting ' + ig + ' epitope. Switched to Ab Design tab.');
}

// 3D Visualization
function abDesign_loadDemoStructure() {
  if (!viewerDesign) return;
  
  const pdbData = abDesign_generateDemoPDB();
  viewerDesign.clear();
  viewerDesign.addModel(pdbData, 'pdb');
  viewerDesign.setStyle({}, {cartoon: {color: 'spectrum'}});
  viewerDesign.zoomTo();
  viewerDesign.render();
}

function abDesign_generateDemoPDB() {
  let pdb = 'HEADER    IMMUNOGLOBULIN SCFV\n';
  let atomNum = 1;
  
  for (let i = 0; i < 252; i++) {
    const x = Math.sin(i * 0.1) * 20;
    const y = Math.cos(i * 0.1) * 20;
    const z = i * 0.5;
    
    pdb += `ATOM  ${String(atomNum).padStart(5)} CA   GLY A ${String(i+1).padStart(3)}     `;
    pdb += `${x.toFixed(3).padStart(8)}${y.toFixed(3).padStart(8)}${z.toFixed(3).padStart(8)}`;
    pdb += '  1.00  0.00           C\n';
    atomNum++;
  }
  
  pdb += 'END\n';
  return pdb;
}

function abDesign_updateVisualization() {
  if (!viewerDesign) return;
  
  viewerDesign.clear();
  const pdbData = abDesign_generateDemoPDB();
  viewerDesign.addModel(pdbData, 'pdb');
  viewerDesign.setStyle({}, {cartoon: {color: 'spectrum'}});
  
  // Highlight CDRs
  viewerDesign.setStyle({resi: [26, 35]}, {cartoon: {color: 'blue'}}); // H1
  viewerDesign.setStyle({resi: [50, 65]}, {cartoon: {color: 'green'}}); // H2
  viewerDesign.setStyle({resi: [95, 102]}, {cartoon: {color: 'red'}}); // H3
  
  viewerDesign.zoomTo();
  viewerDesign.render();
}

function abDesign_resetView() {
  if (viewerDesign) {
    viewerDesign.zoomTo();
    viewerDesign.render();
  }
}

function abDesign_toggleSpin() {
  abDesign_spinning = !abDesign_spinning;
  if (viewerDesign) {
    if (abDesign_spinning) {
      viewerDesign.spin('y');
    } else {
      viewerDesign.spin(false);
    }
  }
}

function abDesign_changeStyle(style) {
  if (!viewerDesign) return;
  
  viewerDesign.setStyle({}, {[style]: {color: 'spectrum'}});
  viewerDesign.render();
}

function abDesign_highlightCDR(cdr) {
  if (!viewerDesign) return;
  
  const regions = {
    H1: [26, 35], H2: [50, 65], H3: [95, 102],
    L1: [150, 160], L2: [170, 177], L3: [210, 220]
  };
  
  viewerDesign.setStyle({}, {cartoon: {color: 'grey'}});
  viewerDesign.setStyle({resi: regions[cdr]}, {cartoon: {color: 'red', thickness: 1.5}});
  viewerDesign.render();
}

// Charts
function abDesign_initializeCharts() {
  if (typeof Plotly === 'undefined') {
    console.warn('Plotly not loaded, skipping chart initialization.');
    return;
  }
  
  // Affinity comparison chart
  const affinityData = {
    x: ['IgG', 'IgA', 'IgM', 'IgD', 'IgE'],
    y: [15, 25, 45, 30, 8],
    type: 'bar',
    marker: {
      color: ['#7dd3fc', '#34d399', '#a78bfa', '#fb923c', '#f87171']
    }
  };
  
  const layout = {
    title: 'Predicted Affinity by Target (KD, nM)',
    paper_bgcolor: 'var(--panel)',
    plot_bgcolor: 'var(--panel)',
    font: { color: 'var(--text)' },
    xaxis: { gridcolor: 'var(--line)' },
    yaxis: { gridcolor: 'var(--line)' }
  };
  
  const affinityChartDiv = E('affinity-chart');
  if (affinityChartDiv) {
    Plotly.newPlot(affinityChartDiv, [affinityData], layout, {responsive: true});
  }
  
  // CDR properties radar chart
  const cdrData = {
    type: 'scatterpolar',
    r: [0.8, 0.6, 0.9, 0.7, 0.85],
    theta: ['Hydrophobicity', 'Charge', 'Aromaticity', 'Size', 'Flexibility'],
    fill: 'toself',
    marker: { color: 'var(--green)' }
  };
  
  const cdrLayout = {
    title: 'CDR Property Analysis',
    polar: {
      radialaxis: {
        visible: true,
        range: [0, 1],
        gridcolor: 'var(--line)',
        tickfont: { color: 'var(--muted)' }
      },
      bgcolor: 'var(--panel)'
    },
    paper_bgcolor: 'var(--panel)',
    font: { color: 'var(--text)' }
  };
  
  const cdrPropsChartDiv = E('cdr-properties-chart');
  if(cdrPropsChartDiv) {
    Plotly.newPlot(cdrPropsChartDiv, [cdrData], cdrLayout, {responsive: true});
  }
}

function abDesign_updateAnalysis() {
  const apps = {
    IgG: ['Fc engineering', 'Half-life extension', 'ADC development'],
    IgA: ['Mucosal immunity', 'Secretory IgA', 'Microbiome modulation'],
    IgM: ['Complement control', 'Primary response', 'Pentamer targeting'],
    IgE: ['Allergy treatment', 'Asthma therapy', 'Mast cell blocking'],
    IgD: ['B cell biology', 'Autoimmunity', 'BCR signaling']
  };
  
  const appDiv = E('therapeutic-apps');
  if (appDiv) {
    appDiv.innerHTML = '<div class="infobox" style="background:var(--bg)">' +
      (apps[abDesign_selectedIg] || []).map(app => 
        `<div class="result-item" style="border-color:var(--line)">
          <span class="result-label" style="color:var(--green)">✓</span>
          <span class="result-value" style="color:var(--text); font-family:var(--sans)">${app}</span>
        </div>`
      ).join('') + '</div>';
  }
}

// Export Functions
function abDesign_exportPDB() {
  const pdbData = abDesign_generateDemoPDB();
  E('export-preview').value = pdbData;
  downloadBlob(pdbData, `anti_${abDesign_selectedIg}_antibody.pdb`, 'text/plain');
}

function abDesign_exportFASTA() {
  const cdrs = abDesign_cdrTemplates[abDesign_selectedIg];
  const fasta = `>Anti-${abDesign_selectedIg}_Heavy_Chain
${cdrs.H1}${cdrs.H2}${cdrs.H3}
>Anti-${abDesign_selectedIg}_Light_Chain
${cdrs.L1}${cdrs.L2}${cdrs.L3}`;
  
  E('export-preview').value = fasta;
  downloadBlob(fasta, `anti_${abDesign_selectedIg}_sequences.fasta`, 'text/plain');
}

function abDesign_exportReport() {
  const report = `IMMUNOGLOBULIN ANTIBODY DESIGN REPORT
=====================================
Date: ${new Date().toLocaleString()}

TARGET: ${abDesign_selectedIg}
SCAFFOLD: ${E('scaffold-type').value}

CDR SEQUENCES:
- H1: ${E('cdr-h1').textContent}
- H2: ${E('cdr-h2').textContent}
- H3: ${E('cdr-h3').textContent}
- L1: ${E('cdr-l1').textContent}
- L2: ${E('cdr-l2').textContent}
- L3: ${E('cdr-l3').textContent}

PREDICTED PROPERTIES:
- Affinity: ${E('affinity-meter').querySelector('.meter-value').textContent}
- Specificity: ${E('specificity-score').textContent}
- Stability: ${E('stability-tm').textContent}
- Humanization: ${E('humanization').textContent}

THERAPEUTIC APPLICATIONS:
${abDesign_selectedIg === 'IgG' ? '- Fc engineering\n- Half-life modulation\n- ADC development' : ''}
${abDesign_selectedIg === 'IgE' ? '- Allergy treatment (Omalizumab-like)\n- Asthma therapy\n- Mast cell inhibition' : ''}
${abDesign_selectedIg === 'IgA' ? '- Mucosal immunity enhancement\n- Secretory IgA targeting' : ''}
${abDesign_selectedIg === 'IgM' ? '- Complement cascade modulation\n- Pentamer-specific targeting' : ''}
${abDesign_selectedIg === 'IgD' ? '- B cell signaling studies\n- Autoimmune research' : ''}
`;
  
  E('export-preview').value = report;
  downloadBlob(report, `anti_${abDesign_selectedIg}_report.txt`, 'text/plain');
}

// Utility Functions
function abDesign_updateScaffoldInfo() {
  const scaffoldType = E('scaffold-type').value;
  const info = {
    scFv: 'Smallest functional unit (27 kDa), easy E. coli production, good tissue penetration, short half-life (2-4 hours)',
    Fab: 'Fragment antigen binding (50 kDa), better stability than scFv, no Fc functions, moderate half-life (12-24 hours)',
    IgG: 'Full antibody (150 kDa), complete effector functions, long half-life (21 days), requires mammalian expression',
    Bispecific: 'Dual targeting (150 kDa), simultaneous binding of two antigens, complex manufacturing, enhanced therapeutic potential'
  };
  
  const infoEl = E('scaffold-info');
  if(infoEl) {
    infoEl.innerHTML = `
      <p style="color: var(--muted);">
        <strong>${scaffoldType}:</strong> ${info[scaffoldType]}
      </p>
    `;
  }
}

// Fragment Processing
function abDesign_loadFragments(event) {
  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        abDesign_fragments = JSON.parse(e.target.result);
        E('fragment-data').value = JSON.stringify(abDesign_fragments, null, 2);
        abDesign_processFragments();
      } catch (error) {
        alert('Error loading fragments: ' + error.message, 'error');
      }
    };
    reader.readAsText(file);
  }
}

function abDesign_processFragments() {
  try {
    const data = E('fragment-data').value;
    if (data) {
      abDesign_fragments = JSON.parse(data);
    }
    
    const candidates = abDesign_analyzeFragments(abDesign_fragments);
    abDesign_displayCandidates(candidates);
    
    alert(`Processed ${abDesign_fragments.length} fragments`);
  } catch (error) {
    alert('Error processing fragments: ' + error.message);
  }
}

function abDesign_analyzeFragments(frags) {
  // Simple scoring algorithm
  const scored = frags.map(frag => {
    let score = 0;
    const seq = frag.sequence || '';
    
    if (seq.length >= 7 && seq.length <= 16) score += 20;
    if (seq.includes('C')) score += 10;
    const aromatics = (seq.match(/[FWY]/g) || []).length;
    score += aromatics * 5;
    const charged = (seq.match(/[RKDE]/g) || []).length;
    score += charged * 3;
    
    return { ...frag, score };
  });
  
  scored.sort((a, b) => b.score - a.score);
  
  return {
    H3: scored[0] || {sequence:'-',score:0},
    L1: scored[1] || {sequence:'-',score:0},
    L3: scored[2] || {sequence:'-',score:0}
  };
}

function abDesign_displayCandidates(candidates) {
  const html = `
    <div class="infobox" style="background:var(--bg)">
      <div class="result-item" style="border-color:var(--line)">
        <span class="result-label">Best H3:</span>
        <span class="result-value">${candidates.H3.sequence} (Score: ${candidates.H3.score})</span>
      </div>
      <div class="result-item" style="border-color:var(--line)">
        <span class="result-label">Best L1:</span>
        <span class="result-value">${candidates.L1.sequence} (Score: ${candidates.L1.score})</span>
      </div>
      <div class="result-item" style="border-color:var(--line)">
        <span class="result-label">Best L3:</span>
        <span class="result-value">${candidates.L3.sequence} (Score: ${candidates.L3.score})</span>
      </div>
    </div>
  `;
  
  E('fragment-candidates').innerHTML = html;
}

// C-Alpha Trace Functions
let abDesign_calphaCoords = [];
let abDesign_calphaPDB = '';
let abDesign_antigenStructure = null;

function abDesign_parseCAlphaTrace() {
  const input = E('calpha-trace-input').value.trim();
  
  if (!input) {
    alert('Please paste C-alpha trace coordinates');
    return;
  }
  
  abDesign_calphaCoords = [];
  const lines = input.split('\n');
  let isPDB = false;
  
  // Check if input is PDB format
  if (lines[0].startsWith('ATOM') || lines[0].startsWith('HETATM')) {
    isPDB = true;
  }
  
  for (const line of lines) {
    if (!line.trim()) continue;
    
    if (isPDB) {
      // Parse PDB format (only CA atoms)
      if ((line.startsWith('ATOM') || line.startsWith('HETATM')) && line.includes(' CA ')) {
        const x = parseFloat(line.substring(30, 38).trim());
        const y = parseFloat(line.substring(38, 46).trim());
        const z = parseFloat(line.substring(46, 54).trim());
        
        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
          abDesign_calphaCoords.push({ x, y, z });
        }
      }
    } else {
      // Parse simple XYZ format
      const parts = line.trim().split(/\s+/);
      if (parts.length >= 3) {
        const x = parseFloat(parts[0]);
        const y = parseFloat(parts[1]);
        const z = parseFloat(parts[2]);
        
        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
          abDesign_calphaCoords.push({ x, y, z });
        }
      }
    }
  }
  
  if (abDesign_calphaCoords.length === 0) {
    alert('No valid coordinates found. Format: X Y Z (one line per residue)', 'error');
    return;
  }
  
  // Generate PDB from coordinates
  abDesign_calphaPDB = abDesign_generatePDBFromCAlpha(abDesign_calphaCoords);
  
  // Calculate statistics
  const stats = abDesign_calculateCAlphaStats(abDesign_calphaCoords);
  
  // Analyze antigen structure for epitope prediction
  abDesign_antigenStructure = abDesign_analyzeAntigenStructure(abDesign_calphaCoords);
  
  // Update UI
  E('calpha-status').style.display = 'block';
  E('calpha-status-text').textContent = `Successfully parsed ${abDesign_calphaCoords.length} C-alpha atoms from antigen`;
  E('calpha-status').className = 'successbox';
  
  E('calpha-stats').style.display = 'block';
  E('calpha-count').textContent = abDesign_calphaCoords.length;
  E('calpha-length').textContent = stats.length.toFixed(2) + ' Å';
  E('calpha-rg').textContent = stats.rg.toFixed(2) + ' Å';
  E('calpha-epitope').textContent = `Res ${abDesign_antigenStructure.epitopeStart}-${abDesign_antigenStructure.epitopeEnd}`;
  
  // Visualize in 3D viewer
  abDesign_visualizeCAlpha();
  
  alert(`Parsed ${abDesign_calphaCoords.length} antigen C-alpha atoms. Click "Design CDRs from Antigen" to generate complementary CDRs!`);
}

function abDesign_analyzeAntigenStructure(coords) {
  if (coords.length === 0) return null;
  
  // Calculate center of mass
  let cx = 0, cy = 0, cz = 0;
  coords.forEach(c => {
    cx += c.x;
    cy += c.y;
    cz += c.z;
  });
  cx /= coords.length;
  cy /= coords.length;
  cz /= coords.length;
  
  // Calculate distance from center for each residue (solvent accessibility proxy)
  const distances = coords.map((c, idx) => {
    const dx = c.x - cx;
    const dy = c.y - cy;
    const dz = c.z - cz;
    return {
      idx,
      dist: Math.sqrt(dx*dx + dy*dy + dz*dz),
      coord: c
    };
  });
  
  // Sort by distance (furthest = most exposed = likely epitope)
  distances.sort((a, b) => b.dist - a.dist);
  
  // Identify epitope region (most exposed residues in a continuous stretch)
  const epitopeSize = Math.min(15, Math.floor(coords.length * 0.2));
  const topExposed = distances.slice(0, epitopeSize * 2);
  topExposed.sort((a, b) => a.idx - b.idx);
  
  // Find largest continuous stretch
  let maxStretch = { start: topExposed[0].idx, end: topExposed[0].idx, length: 1 };
  let currentStretch = { start: topExposed[0].idx, end: topExposed[0].idx, length: 1 };
  
  for (let i = 1; i < topExposed.length; i++) {
    if (topExposed[i].idx - topExposed[i-1].idx <= 3) {
      currentStretch.end = topExposed[i].idx;
      currentStretch.length = currentStretch.end - currentStretch.start + 1;
    } else {
      if (currentStretch.length > maxStretch.length) {
        maxStretch = {...currentStretch};
      }
      currentStretch = { start: topExposed[i].idx, end: topExposed[i].idx, length: 1 };
    }
  }
  
  if (currentStretch.length > maxStretch.length) {
    maxStretch = {...currentStretch};
  }
  
  // Calculate epitope center
  const epitopeCoords = coords.slice(maxStretch.start, maxStretch.end + 1);
  let ex = 0, ey = 0, ez = 0;
  epitopeCoords.forEach(c => {
    ex += c.x;
    ey += c.y;
    ez += c.z;
  });
  ex /= epitopeCoords.length;
  ey /= epitopeCoords.length;
  ez /= epitopeCoords.length;
  
  // Analyze epitope geometry
  let minDist = Infinity, maxDist = 0;
  epitopeCoords.forEach(c => {
    const d = Math.sqrt((c.x-ex)**2 + (c.y-ey)**2 + (c.z-ez)**2);
    minDist = Math.min(minDist, d);
    maxDist = Math.max(maxDist, d);
  });
  
  return {
    epitopeStart: maxStretch.start + 1,
    epitopeEnd: maxStretch.end + 1,
    epitopeCenter: { x: ex, y: ey, z: ez },
    epitopeRadius: maxDist,
    epitopeShape: maxDist / (minDist + 0.1), // convexity measure
    totalResidues: coords.length,
    compactness: abDesign_calculateCAlphaStats(coords).rg
  };
}

function abDesign_designCDRsFromAntigen() {
  if (!abDesign_selectedIg) {
    alert('Please select a target immunoglobulin first (Step 1)');
    return;
  }
  
  if (!abDesign_antigenStructure || abDesign_calphaCoords.length === 0) {
    alert('Please parse antigen C-alpha trace first');
    return;
  }
  
  // Generate CDRs based on antigen structure and Ig type
  const designedCDRs = abDesign_generateStructureGuidedCDRs(
    abDesign_antigenStructure,
    abDesign_selectedIg
  );
  
  // Update CDR display
  E('cdr-h1').textContent = designedCDRs.H1;
  E('cdr-h2').textContent = designedCDRs.H2;
  E('cdr-h3').textContent = designedCDRs.H3;
  E('cdr-l1').textContent = designedCDRs.L1;
  E('cdr-l2').textContent = designedCDRs.L2;
  E('cdr-l3').textContent = designedCDRs.L3;
  
  // Update predictions with improved affinity
  abDesign_updatePredictions(true);
  
  // Update visualization
  abDesign_updateVisualization();
  
  const msg = `CDRs designed for ${abDesign_selectedIg} targeting antigen epitope (residues ${abDesign_antigenStructure.epitopeStart}-${abDesign_antigenStructure.epitopeEnd}).\n\nDesign strategy:\n- Epitope radius: ${abDesign_antigenStructure.epitopeRadius.toFixed(1)} Å\n- Shape complementarity optimized\n- ${abDesign_selectedIg}-specific framework used`;
  
  alert(msg);
}

function abDesign_generateStructureGuidedCDRs(antigenStruct, igType) {
  // Base templates for different Ig types
  const baseTemplates = abDesign_cdrTemplates[igType];
  
  // Analyze epitope properties to guide CDR design
  const epitopeRadius = antigenStruct.epitopeRadius;
  const epitopeShape = antigenStruct.epitopeShape;
  const compactness = antigenStruct.compactness;
  
  // Design principles based on antigen structure:
  // 1. Epitope size influences CDR-H3 length
  // 2. Shape convexity influences aromatic content
  // 3. Compactness influences CDR flexibility
  
  const cdrs = {};
  
  // CDR-H3: Most variable, length based on epitope size
  const h3Length = Math.max(10, Math.min(18, Math.floor(epitopeRadius * 1.5 + 8)));
  cdrs.H3 = abDesign_generateCDR_H3(h3Length, epitopeShape, igType);
  
  // CDR-H1: Length based on Ig type + epitope accessibility
  const h1Length = 7 + (epitopeShape > 2 ? 1 : 0);
  cdrs.H1 = abDesign_generateCDR_Generic('H1', h1Length, epitopeRadius, igType);
  
  // CDR-H2: Moderate length, aromatic content based on shape
  const h2Length = 8 + (compactness < 15 ? 1 : 0);
  cdrs.H2 = abDesign_generateCDR_Generic('H2', h2Length, epitopeShape, igType);
  
  // Light chain CDRs: Complement heavy chain
  cdrs.L1 = abDesign_generateCDR_Generic('L1', 6, epitopeRadius * 0.8, igType);
  cdrs.L2 = abDesign_generateCDR_Generic('L2', 3, epitopeShape * 0.5, igType);
  
  // CDR-L3: Second most variable
  const l3Length = Math.max(7, Math.min(11, Math.floor(epitopeRadius * 0.8 + 6)));
  cdrs.L3 = abDesign_generateCDR_Generic('L3', l3Length, compactness * 0.1, igType);
  
  return cdrs;
}

function abDesign_generateCDR_H3(length, shapeComplexity, igType) {
  // H3 anchor residues based on Ig type
  const anchors = {
    IgG: { start: 'AR', end: 'FDY' },
    IgA: { start: 'AR', end: 'LDY' },
    IgM: { start: 'AR', end: 'FDY' },
    IgE: { start: 'AK', end: 'FDY' },
    IgD: { start: 'AR', end: 'FDY' }
  };
  
  const anchor = anchors[igType] || anchors.IgG;
  let cdr = anchor.start;
  
  // Variable region based on epitope shape
  const varLength = length - anchor.start.length - anchor.end.length;
  
  // Amino acid preferences based on shape complexity
  let aaPool;
  if (shapeComplexity > 2.5) {
    // Complex, convex epitope: favor aromatics and long sidechains
    aaPool = 'FYWRKHEDNQST';
  } else if (shapeComplexity > 1.5) {
    // Moderate complexity: balanced
    aaPool = 'GSTYWFVANDEKR';
  } else {
    // Flat epitope: favor small, flexible residues
    aaPool = 'GSTNAQDEVKP';
  }
  
  for (let i = 0; i < varLength; i++) {
    // Add some structure: cysteines for potential disulfides
    if (i === Math.floor(varLength / 3) && Math.random() > 0.6) {
      cdr += 'C';
    } else if (i === Math.floor(2 * varLength / 3) && cdr.includes('C') && Math.random() > 0.6) {
      cdr += 'C';
    } else {
      cdr += aaPool[Math.floor(Math.random() * aaPool.length)];
    }
  }
  
  cdr += anchor.end;
  return cdr;
}

function abDesign_generateCDR_Generic(cdrType, length, structParam, igType) {
  const frameworks = {
    H1: { IgG: 'GFTF', IgA: 'GYTF', IgM: 'GFSL', IgE: 'GFTF', IgD: 'GYTF' },
    H2: { IgG: 'IS', IgA: 'IN', IgM: 'IW', IgE: 'IS', IgD: 'IN' },
    L1: { IgG: 'QS', IgA: 'QS', IgM: 'QS', IgE: 'QG', IgD: 'QN' },
    L2: { IgG: 'A', IgA: 'G', IgM: 'K', IgE: 'A', IgD: 'S' },
    L3: { IgG: 'QQ', IgA: 'QQ', IgM: 'MQ', IgE: 'QQ', IgD: 'QQ' }
  };
  
  const framework = frameworks[cdrType][igType] || frameworks[cdrType].IgG;
  let cdr = framework;
  
  const varLength = length - framework.length - (cdrType.startsWith('L') ? 2 : 1);
  
  // Amino acid selection based on structural parameter
  let aaPool;
  if (structParam > 10) {
    aaPool = 'YWFHKREST';
  } else if (structParam > 5) {
    aaPool = 'STAGNDEKR';
  } else {
    aaPool = 'GSTNAQPV';
  }
  
  for (let i = 0; i < varLength; i++) {
    cdr += aaPool[Math.floor(Math.random() * aaPool.length)];
  }
  
  // Add C-terminal anchor
  if (cdrType === 'H1' || cdrType === 'H2') {
    cdr += cdrType === 'H1' ? 'Y' : 'T';
  } else {
    cdr += 'PT';
  }
  
  return cdr;
}

function abDesign_generatePDBFromCAlpha(coords) {
  let pdb = 'HEADER    C-ALPHA TRACE FROM USER INPUT\n';
  pdb += 'REMARK   Generated by Antibody Design Suite\n';
  
  coords.forEach((coord, i) => {
    const atomNum = i + 1;
    const resNum = i + 1;
    
    pdb += 'ATOM  ';
    pdb += String(atomNum).padStart(5) + '  ';
    pdb += 'CA  ';
    pdb += 'GLY ';
    pdb += 'A';
    pdb += String(resNum).padStart(4) + '    ';
    pdb += coord.x.toFixed(3).padStart(8);
    pdb += coord.y.toFixed(3).padStart(8);
    pdb += coord.z.toFixed(3).padStart(8);
    pdb += '  1.00  0.00           C\n';
  });
  
  pdb += 'END\n';
  return pdb;
}

function abDesign_calculateCAlphaStats(coords) {
  if (coords.length === 0) return { length: 0, rg: 0 };
  
  // Calculate total chain length
  let totalLength = 0;
  for (let i = 1; i < coords.length; i++) {
    const dx = coords[i].x - coords[i-1].x;
    const dy = coords[i].y - coords[i-1].y;
    const dz = coords[i].z - coords[i-1].z;
    totalLength += Math.sqrt(dx*dx + dy*dy + dz*dz);
  }
  
  // Calculate center of mass
  let cx = 0, cy = 0, cz = 0;
  coords.forEach(c => {
    cx += c.x;
    cy += c.y;
    cz += c.z;
  });
  cx /= coords.length;
  cy /= coords.length;
  cz /= coords.length;
  
  // Calculate radius of gyration
  let rg2 = 0;
  coords.forEach(c => {
    const dx = c.x - cx;
    const dy = c.y - cy;
    const dz = c.z - cz;
    rg2 += dx*dx + dy*dy + dz*dz;
  });
  const rg = Math.sqrt(rg2 / coords.length);
  
  return { length: totalLength, rg };
}

function abDesign_visualizeCAlpha() {
  if (!viewerDesign || abDesign_calphaCoords.length === 0) return;
  
  viewerDesign.clear();
  viewerDesign.addModel(abDesign_calphaPDB, 'pdb');
  
  // Style the antigen structure
  viewerDesign.setStyle({}, {cartoon: {color: 'lightgray', thickness: 0.8}});
  
  // Highlight epitope region if identified
  if (abDesign_antigenStructure) {
    const epitopeStart = abDesign_antigenStructure.epitopeStart;
    const epitopeEnd = abDesign_antigenStructure.epitopeEnd;
    
    // Highlight epitope in bright color
    viewerDesign.setStyle(
      {resi: Array.from({length: epitopeEnd - epitopeStart + 1}, (_, i) => epitopeStart + i)},
      {cartoon: {color: '#f87171', thickness: 1.2}}
    );
    
    // Add sphere markers on epitope
    viewerDesign.addStyle(
      {resi: Array.from({length: epitopeEnd - epitopeStart + 1}, (_, i) => epitopeStart + i)},
      {sphere: {radius: 0.5, color: '#fbbf24'}}
    );
  }
  
  // Add subtle spheres for all CA atoms
  viewerDesign.addStyle({}, {sphere: {radius: 0.2, color: 'lightblue'}});
  
  viewerDesign.zoomTo();
  viewerDesign.render();
}

function abDesign_loadCAlphaFile() {
  E('calpha-file-input').click();
}

function abDesign_handleCAlphaFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    E('calpha-trace-input').value = e.target.result;
    abDesign_parseCAlphaTrace();
  };
  reader.readAsText(file);
}

function abDesign_clearCAlphaTrace() {
  E('calpha-trace-input').value = '';
  abDesign_calphaCoords = [];
  abDesign_calphaPDB = '';
  
  E('calpha-status').style.display = 'none';
  E('calpha-stats').style.display = 'none';
  
  // Reload demo structure
  abDesign_loadDemoStructure();
  
  alert('C-alpha trace cleared');
}

/* ======================================================== */
/* ===== 3D STRUCTURE MODELING ENGINE ===================== */
/* ======================================================== */

let abDesign_structureModels = [];
let abDesign_currentModelIndex = 0;

function abDesign_useCurrentCDRs() {
  E('input-cdr-h1').value = E('cdr-h1').textContent;
  E('input-cdr-h2').value = E('cdr-h2').textContent;
  E('input-cdr-h3').value = E('cdr-h3').textContent;
  E('input-cdr-l1').value = E('cdr-l1').textContent;
  E('input-cdr-l2').value = E('cdr-l2').textContent;
  E('input-cdr-l3').value = E('cdr-l3').textContent;
  alert('Current CDRs copied to input fields');
}

async function abDesign_generateStructureModel() {
  // Get CDR sequences (use manual input if provided, otherwise use displayed CDRs)
  const cdrs = {
    H1: E('input-cdr-h1').value || E('cdr-h1').textContent,
    H2: E('input-cdr-h2').value || E('cdr-h2').textContent,
    H3: E('input-cdr-h3').value || E('cdr-h3').textContent,
    L1: E('input-cdr-l1').value || E('cdr-l1').textContent,
    L2: E('input-cdr-l2').value || E('cdr-l2').textContent,
    L3: E('input-cdr-l3').value || E('cdr-l3').textContent
  };
  
  const method = E('modeling-method').value;
  
  // Show progress
  E('modeling-status').style.display = 'block';
  E('modeling-status-text').textContent = `Running ${method} structure prediction...`;
  
  // Simulate modeling process with progress
  for (let i = 0; i <= 100; i += 10) {
    E('modeling-progress').value = i;
    await new Promise(resolve => setTimeout(resolve, 100));
    
    if (i === 20) E('modeling-status-text').textContent = 'Building framework regions...';
    if (i === 40) E('modeling-status-text').textContent = 'Modeling CDR loops...';
    if (i === 60) E('modeling-status-text').textContent = 'Predicting secondary structure...';
    if (i === 80) E('modeling-status-text').textContent = 'Energy minimization...';
  }
  
  // Generate the structure
  const model = abDesign_buildAntibodyStructure(cdrs, method, 0);
  abDesign_structureModels = [model];
  abDesign_currentModelIndex = 0;
  
  // Display the model
  abDesign_displayStructureModel(model);
  
  // Update confidence metrics
  abDesign_displayConfidenceMetrics(model);
  
  E('modeling-status-text').textContent = '✓ Structure prediction complete!';
  E('modeling-status').className = 'successbox';
  
  alert(`${method} model generated successfully! View in 3D viewer.`);
}

async function abDesign_generateMultipleModels() {
  const cdrs = {
    H1: E('input-cdr-h1').value || E('cdr-h1').textContent,
    H2: E('input-cdr-h2').value || E('cdr-h2').textContent,
    H3: E('input-cdr-h3').value || E('cdr-h3').textContent,
    L1: E('input-cdr-l1').value || E('cdr-l1').textContent,
    L2: E('input-cdr-l2').value || E('cdr-l2').textContent,
    L3: E('input-cdr-l3').value || E('cdr-l3').textContent
  };
  
  const method = E('modeling-method').value;
  
  E('modeling-status').style.display = 'block';
  E('modeling-status-text').textContent = 'Generating ensemble of 5 models...';
  
  abDesign_structureModels = [];
  
  for (let i = 0; i < 5; i++) {
    E('modeling-progress').value = (i / 5) * 100;
    E('modeling-status-text').textContent = `Generating model ${i + 1}/5...`;
    await new Promise(resolve => setTimeout(resolve, 200));
    
    const model = abDesign_buildAntibodyStructure(cdrs, method, i);
    abDesign_structureModels.push(model);
  }
  
  E('modeling-progress').value = 100;
  E('modeling-status-text').textContent = '✓ Ensemble of 5 models generated!';
  E('modeling-status').className = 'successbox';
  
  // Display model selection buttons
  abDesign_displayModelEnsemble();
  
  // Display first model
  abDesign_currentModelIndex = 0;
  abDesign_displayStructureModel(abDesign_structureModels[0]);
  abDesign_displayConfidenceMetrics(abDesign_structureModels[0]);
}

function abDesign_displayModelEnsemble() {
  E('model-ensemble').style.display = 'block';
  E('ensemble-count').textContent = `${abDesign_structureModels.length} Models`;
  
  const buttonDiv = E('model-buttons');
  buttonDiv.innerHTML = '';
  
  abDesign_structureModels.forEach((model, idx) => {
    const btn = document.createElement('button');
    btn.className = 'btn' + (idx === 0 ? ' primary' : '');
    btn.textContent = `Model ${idx + 1} (pLDDT: ${model.confidence.plddt.toFixed(1)})`;
    btn.onclick = () => abDesign_switchToModel(idx);
    buttonDiv.appendChild(btn);
  });
}

function abDesign_switchToModel(index) {
  abDesign_currentModelIndex = index;
  abDesign_displayStructureModel(abDesign_structureModels[index]);
  abDesign_displayConfidenceMetrics(abDesign_structureModels[index]);
  
  // Update button styles
  const buttons = E('model-buttons').children;
  for (let i = 0; i < buttons.length; i++) {
    buttons[i].className = i === index ? 'btn primary' : 'btn';
  }
}

function abDesign_buildAntibodyStructure(cdrs, method, seed) {
  // Build full antibody sequence with framework regions
  const heavyChain = abDesign_buildHeavyChain(cdrs);
  const lightChain = abDesign_buildLightChain(cdrs);
  
  // Predict secondary structure
  const heavySecondary = abDesign_predictSecondaryStructure(heavyChain);
  const lightSecondary = abDesign_predictSecondaryStructure(lightChain);
  
  // Generate 3D coordinates using parametric modeling
  const heavyCoords = abDesign_generateChainCoordinates(heavyChain, heavySecondary, 'H', seed);
  const lightCoords = abDesign_generateChainCoordinates(lightChain, lightSecondary, 'L', seed);
  
  // Combine and orient chains
  const allCoords = [...heavyCoords, ...lightCoords];
  
  // Generate PDB format
  const pdb = abDesign_generateAntibodyPDB(heavyChain, lightChain, heavyCoords, lightCoords, heavySecondary, lightSecondary);
  
  // Calculate confidence metrics
  const confidence = abDesign_calculateConfidenceMetrics(method, cdrs, seed);
  
  return {
    pdb,
    cdrs,
    method,
    seed,
    heavyChain,
    lightChain,
    coordinates: allCoords,
    secondary: { heavy: heavySecondary, light: lightSecondary },
    confidence
  };
}

function abDesign_buildHeavyChain(cdrs) {
  // Framework regions (consensus sequences)
  const FR1 = 'EVQLVESGGGLVQPGGSLRLSCAASGF'; // ~27 residues
  const FR2 = 'WVRQAPGKGLEWV'; // ~13 residues
  const FR3 = 'RFTISRDNSKNTLYLQMNSLRAEDTAVYYC'; // ~30 residues
  const FR4 = 'WGQGTLVTVSS'; // ~11 residues
  
  return FR1 + cdrs.H1 + FR2 + cdrs.H2 + FR3 + cdrs.H3 + FR4;
}

function abDesign_buildLightChain(cdrs) {
  const FR1 = 'DIQMTQSPSSLSASVGDRVTITC'; // ~23 residues
  const FR2 = 'WYQQKPGKAPKLLIY'; // ~15 residues
  const FR3 = 'GVPSRFSGSGSGTDFTLTISSLQPEDFATYYC'; // ~32 residues
  const FR4 = 'FGQGTKVEIK'; // ~10 residues
  
  return FR1 + cdrs.L1 + FR2 + cdrs.L2 + FR3 + cdrs.L3 + FR4;
}

function abDesign_predictSecondaryStructure(sequence) {
  // Simplified secondary structure prediction
  // H = helix, E = sheet, C = coil/loop
  const secondary = [];
  
  for (let i = 0; i < sequence.length; i++) {
    const aa = sequence[i];
    const context = sequence.substring(Math.max(0, i - 2), Math.min(sequence.length, i + 3));
    
    // Helix propensity
    const helixAA = 'AELM';
    const sheetAA = 'VIY';
    const loopAA = 'GSPD';
    
    if (i < 25 || (i > 40 && i < 70)) {
      // Framework regions tend to be beta sheets
      secondary.push(sheetAA.includes(aa) ? 'E' : 'C');
    } else if (i > 70 && i < 100) {
      // This region often has helical content
      secondary.push(helixAA.includes(aa) ? 'H' : 'C');
    } else {
      // CDR regions are typically loops
      secondary.push('C');
    }
  }
  
  // Smooth secondary structure (minimum 3 residues per element)
  for (let i = 1; i < secondary.length - 1; i++) {
    if (secondary[i] !== secondary[i-1] && secondary[i] !== secondary[i+1]) {
      secondary[i] = secondary[i-1];
    }
  }
  
  return secondary;
}

function abDesign_generateChainCoordinates(sequence, secondary, chainType, seed) {
  const coords = [];
  let x = chainType === 'H' ? 0 : 35; // Offset light chain
  let y = 0;
  let z = 0;
  
  // Direction vectors
  let dx = 1, dy = 0, dz = 0;
  
  const random = abDesign_seededRandom(seed);
  
  for (let i = 0; i < sequence.length; i++) {
    const ss = secondary[i];
    
    if (ss === 'H') {
      // Alpha helix: 3.6 residues per turn, 5.4 Å rise
      const angle = (i * 100 + seed * 10) * Math.PI / 180;
      const radius = 2.3;
      x += 1.5 * Math.cos(angle);
      y += radius * Math.sin(angle);
      z += 1.5;
    } else if (ss === 'E') {
      // Beta sheet: extended, ~3.3 Å between residues
      x += 3.3 * dx + (random() - 0.5) * 0.5;
      y += (random() - 0.5) * 0.8;
      z += 0.5;
      
      // Slight zigzag for sheet
      if (i % 2 === 0) {
        y += 0.5;
      } else {
        y -= 0.5;
      }
    } else {
      // Coil/loop: irregular
      const turnAngle = (random() - 0.5) * Math.PI / 3;
      const newDx = dx * Math.cos(turnAngle) - dy * Math.sin(turnAngle);
      const newDy = dx * Math.sin(turnAngle) + dy * Math.cos(turnAngle);
      dx = newDx;
      dy = newDy;
      
      x += 3.8 * dx + (random() - 0.5) * 1.5;
      y += 3.8 * dy + (random() - 0.5) * 1.5;
      z += (random() - 0.5) * 2.0;
    }
    
    coords.push({ x, y, z, aa: sequence[i], ss: ss });
  }
  
  return coords;
}

function abDesign_seededRandom(seed) {
  let s = seed + 12345;
  return function() {
    s = Math.sin(s) * 10000;
    return s - Math.floor(s);
  };
}

function abDesign_generateAntibodyPDB(heavySeq, lightSeq, heavyCoords, lightCoords, heavySS, lightSS) {
  let pdb = 'HEADER    ANTIBODY MODEL\n';
  pdb += `REMARK   Generated by Antibody Design Suite\n`;
  pdb += `REMARK   Method: Structure Prediction\n`;
  pdb += 'REMARK   Heavy Chain: ' + heavySeq.length + ' residues\n';
  pdb += 'REMARK   Light Chain: ' + lightSeq.length + ' residues\n';
  
  let atomNum = 1;
  
  // Heavy chain
  for (let i = 0; i < heavyCoords.length; i++) {
    const coord = heavyCoords[i];
    const resNum = i + 1;
    const aa = abDesign_aaThreeLetterCode(coord.aa);
    
    pdb += 'ATOM  ';
    pdb += String(atomNum).padStart(5) + '  ';
    pdb += 'CA  ';
    pdb += aa + ' ';
    pdb += 'H';
    pdb += String(resNum).padStart(4) + '    ';
    pdb += coord.x.toFixed(3).padStart(8);
    pdb += coord.y.toFixed(3).padStart(8);
    pdb += coord.z.toFixed(3).padStart(8);
    pdb += '  1.00';
    pdb += '  0.00';
    pdb += '           C\n';
    atomNum++;
  }
  
  pdb += 'TER\n';
  
  // Light chain
  for (let i = 0; i < lightCoords.length; i++) {
    const coord = lightCoords[i];
    const resNum = i + 1;
    const aa = abDesign_aaThreeLetterCode(coord.aa);
    
    pdb += 'ATOM  ';
    pdb += String(atomNum).padStart(5) + '  ';
    pdb += 'CA  ';
    pdb += aa + ' ';
    pdb += 'L';
    pdb += String(resNum).padStart(4) + '    ';
    pdb += coord.x.toFixed(3).padStart(8);
    pdb += coord.y.toFixed(3).padStart(8);
    pdb += coord.z.toFixed(3).padStart(8);
    pdb += '  1.00';
    pdb += '  0.00';
    pdb += '           C\n';
    atomNum++;
  }
  
  pdb += 'TER\nEND\n';
  
  return pdb;
}

function abDesign_aaThreeLetterCode(aa) {
  const codes = {
    'A': 'ALA', 'C': 'CYS', 'D': 'ASP', 'E': 'GLU', 'F': 'PHE',
    'G': 'GLY', 'H': 'HIS', 'I': 'ILE', 'K': 'LYS', 'L': 'LEU',
    'M': 'MET', 'N': 'ASN', 'P': 'PRO', 'Q': 'GLN', 'R': 'ARG',
    'S': 'SER', 'T': 'THR', 'V': 'VAL', 'W': 'TRP', 'Y': 'TYR'
  };
  return codes[aa] || 'GLY';
}

function abDesign_calculateConfidenceMetrics(method, cdrs, seed) {
  const random = abDesign_seededRandom(seed * 7);
  
  let basePLDDT, basePTM, baseClash, baseRama;
  
  if (method === 'alphafold') {
    basePLDDT = 85 + random() * 10;
    basePTM = 0.75 + random() * 0.20;
    baseClash = 0.5 + random() * 1.5;
    baseRama = 94 + random() * 4;
  } else if (method === 'rosetta') {
    basePLDDT = 75 + random() * 10;
    basePTM = 0.65 + random() * 0.20;
    baseClash = 1.0 + random() * 2.0;
    baseRama = 90 + random() * 6;
  } else if (method === 'hybrid') {
    basePLDDT = 80 + random() * 12;
    basePTM = 0.70 + random() * 0.22;
    baseClash = 0.7 + random() * 1.8;
    baseRama = 92 + random() * 5;
  } else {
    basePLDDT = 70 + random() * 15;
    basePTM = 0.60 + random() * 0.25;
    baseClash = 1.5 + random() * 2.5;
    baseRama = 88 + random() * 7;
  }
  
  // CDR H3 length affects confidence (longer = harder to predict)
  const h3Penalty = Math.max(0, (cdrs.H3.length - 12) * 0.5);
  
  return {
    plddt: Math.max(50, basePLDDT - h3Penalty),
    ptm: Math.max(0.5, basePTM - h3Penalty * 0.01),
    clash: baseClash + h3Penalty * 0.1,
    rama: Math.max(80, baseRama - h3Penalty * 0.3)
  };
}

function abDesign_displayStructureModel(model) {
  if (!viewerDesign) return;
  
  viewerDesign.clear();
  viewerDesign.addModel(model.pdb, 'pdb');
  
  // Color by secondary structure
  const heavyLen = model.heavyChain.length;
  
  // Heavy chain
  for (let i = 0; i < heavyLen; i++) {
    const ss = model.secondary.heavy[i];
    let color;
    if (ss === 'H') color = 'red'; // Helix
    else if (ss === 'E') color = 'yellow'; // Sheet
    else color = 'lightgray'; // Loop
    
    viewerDesign.setStyle({chain: 'H', resi: i + 1}, {cartoon: {color: color, thickness: 0.8}});
  }
  
  // Light chain
  for (let i = 0; i < model.lightChain.length; i++) {
    const ss = model.secondary.light[i];
    let color;
    if (ss === 'H') color = 'blue'; // Helix
    else if (ss === 'E') color = 'cyan'; // Sheet
    else color = 'lightblue'; // Loop
    
    viewerDesign.setStyle({chain: 'L', resi: i + 1}, {cartoon: {color: color, thickness: 0.8}});
  }
  
  viewerDesign.zoomTo();
  viewerDesign.render();
}

function abDesign_displayConfidenceMetrics(model) {
  E('model-confidence').style.display = 'block';
  
  const conf = model.confidence;
  E('plddt-score').textContent = conf.plddt.toFixed(1);
  E('ptm-score').textContent = conf.ptm.toFixed(2);
  E('clash-score').textContent = conf.clash.toFixed(2);
  E('rama-score').textContent = conf.rama.toFixed(1) + '%';
  
  // Color code based on quality
  E('plddt-score').style.color = conf.plddt > 80 ? 'var(--green)' : conf.plddt > 70 ? 'var(--yellow)' : 'var(--orange)';
  E('ptm-score').style.color = conf.ptm > 0.75 ? 'var(--green)' : conf.ptm > 0.65 ? 'var(--yellow)' : 'var(--orange)';
  E('clash-score').style.color = conf.clash < 1.5 ? 'var(--green)' : conf.clash < 2.5 ? 'var(--yellow)' : 'var(--red)';
  E('rama-score').style.color = conf.rama > 92 ? 'var(--green)' : conf.rama > 88 ? 'var(--yellow)' : 'var(--orange)';
}

/* ======================================================== */
/* ===== 3D RIBBON VISUALIZATION ENGINE =================== */
/* ======================================================== */

let abDesign_ribbonChunks = [];

function abDesign_useCurrentCDRsForRibbon() {
  // This will use the current CDRs from the design section for ribbon view
  alert('Ribbon will use current displayed CDRs. Click "Build Ribbon View" to visualize.');
}

function abDesign_buildRibbon() {
  if (!viewerDesign) return;
  
  const bulge = parseFloat(E('ribbon-bulge').value) || 16;
  const radius = parseFloat(E('ribbon-radius').value) || 0.8;
  
  // Get CDR sequences from the main display (or use input if available)
  const cdrs = {
    H1: E('input-cdr-h1').value || E('cdr-h1').textContent,
    H2: E('input-cdr-h2').value || E('cdr-h2').textContent,
    H3: E('input-cdr-h3').value || E('cdr-h3').textContent,
    L1: E('input-cdr-l1').value || E('cdr-l1').textContent,
    L2: E('input-cdr-l2').value || E('cdr-l2').textContent,
    L3: E('input-cdr-l3').value || E('cdr-l3').textContent
  };
  
  const colors = {
    H1: '#f59e0b', // amber
    H2: '#ef4444', // red
    H3: '#8b5cf6', // violet
    L1: '#22c55e', // green
    L2: '#06b6d4', // cyan
    L3: '#60a5fa'  // blue
  };
  
  // Domain centers for Heavy and Light chains
  const heavyCenter = {x: -15, y: 0, z: 0};
  const lightCenter = {x: 15, y: 0, z: 0};
  const domainR = 11;
  
  viewerDesign.clear();
  abDesign_ribbonChunks = [];
  
  // Build each CDR loop
  abDesign_ribbonChunks.push(abDesign_buildRibbonLoop(heavyCenter, 35, 8, colors.H1, cdrs.H1, bulge, radius, 'H1', domainR));
  abDesign_ribbonChunks.push(abDesign_buildRibbonLoop(heavyCenter, 0, 6, colors.H2, cdrs.H2, bulge, radius, 'H2', domainR));
  abDesign_ribbonChunks.push(abDesign_buildRibbonLoop(heavyCenter, -35, 4, colors.H3, cdrs.H3, bulge * 1.1, radius, 'H3', domainR));
  
  abDesign_ribbonChunks.push(abDesign_buildRibbonLoop(lightCenter, -30, -6, colors.L1, cdrs.L1, bulge, radius, 'L1', domainR));
  abDesign_ribbonChunks.push(abDesign_buildRibbonLoop(lightCenter, 0, -4, colors.L2, cdrs.L2, bulge * 0.85, radius, 'L2', domainR));
  abDesign_ribbonChunks.push(abDesign_buildRibbonLoop(lightCenter, 30, -7, colors.L3, cdrs.L3, bulge, radius, 'L3', domainR));
  
  // Add domain hub spheres
  viewerDesign.addSphere({center: heavyCenter, radius: 2.3, color: '#1f2937'});
  viewerDesign.addSphere({center: lightCenter, radius: 2.3, color: '#1f2937'});
  
  // Add domain labels
  viewerDesign.addLabel('Heavy (H)', {
    position: {x: heavyCenter.x - 3, y: heavyCenter.y - 10, z: heavyCenter.z},
    fontSize: 11,
    fontColor: '#8baad9',
    backgroundOpacity: 0
  });
  
  viewerDesign.addLabel('Light (L)', {
    position: {x: lightCenter.x + 3, y: lightCenter.y + 10, z: lightCenter.z},
    fontSize: 11,
    fontColor: '#8bd9d1',
    backgroundOpacity: 0
  });
  
  viewerDesign.zoomTo();
  viewerDesign.render();
  
  E('ribbon-info').style.display = 'block';
  E('ribbon-status-text').textContent = '✓ Ribbon visualization complete! 6 CDR loops rendered.';
  E('ribbon-info').className = 'successbox';
}

function abDesign_buildRibbonLoop(center, baseAngle, elev, color, seq, bulge, radius, label, domainR) {
  const n = seq.length;
  const split = 0.32;
  const dphi = split * 40; // degrees separation
  
  // Calculate anchor points
  const p0 = abDesign_ribbonAnchor(center, baseAngle - dphi, elev, domainR);
  const p3 = abDesign_ribbonAnchor(center, baseAngle + dphi, elev, domainR);
  
  // Control points for Bezier curve
  const outward = {
    x: (p0.x + p3.x) / 2 - center.x,
    y: (p0.y + p3.y) / 2 - center.y,
    z: (p0.z + p3.z) / 2 - center.z
  };
  const outLen = Math.sqrt(outward.x**2 + outward.y**2 + outward.z**2);
  outward.x /= outLen;
  outward.y /= outLen;
  outward.z /= outLen;
  
  const up = {x: 0, y: 0, z: 1};
  const side = {
    x: outward.y * up.z - outward.z * up.y,
    y: outward.z * up.x - outward.x * up.z,
    z: outward.x * up.y - outward.y * up.x
  };
  const sideLen = Math.sqrt(side.x**2 + side.y**2 + side.z**2);
  side.x /= sideLen;
  side.y /= sideLen;
  side.z /= sideLen;
  
  const mid = {
    x: (p0.x + p3.x) / 2,
    y: (p0.y + p3.y) / 2,
    z: (p0.z + p3.z) / 2
  };
  
  const p1 = {
    x: mid.x + outward.x * bulge + side.x * 3,
    y: mid.y + outward.y * bulge + side.y * 3,
    z: mid.z + outward.z * bulge + side.z * 3
  };
  
  const p2 = {
    x: mid.x + outward.x * bulge * 0.9 - side.x * 3,
    y: mid.y + outward.y * bulge * 0.9 - side.y * 3,
    z: mid.z + outward.z * bulge * 0.9 - side.z * 3
  };
  
  // Sample curve for drawing
  const segs = Math.max(12, n * 6);
  const curvePts = abDesign_sampleBezier(p0, p1, p2, p3, segs);
  
  // Draw the tube/ribbon using cylinder segments between points
  for (let i = 0; i < curvePts.length - 1; i++) {
    viewerDesign.addCylinder({
      start: curvePts[i],
      end: curvePts[i + 1],
      radius: radius,
      color: color,
      fromCap: 1,
      toCap: 1
    });
  }
  
  // Add anchor caps
  viewerDesign.addSphere({center: p0, radius: radius * 1.2, color: color});
  viewerDesign.addSphere({center: p3, radius: radius * 1.2, color: color});
  
  // Add label at midpoint
  const midpt = curvePts[Math.floor(curvePts.length / 2)];
  viewerDesign.addLabel(`${label} • ${n} aa`, {
    position: midpt,
    fontSize: 12,
    fontColor: color,
    backgroundOpacity: 0
  });
  
  // Sample points for PDB export (one per residue)
  const caPts = abDesign_sampleBezier(p0, p1, p2, p3, n);
  
  return {caPts, seq, label};
}

function abDesign_ribbonAnchor(center, angDeg, elevDeg, r) {
  const ang = angDeg * Math.PI / 180;
  const el = elevDeg * Math.PI / 180;
  
  return {
    x: center.x + r * Math.cos(el) * Math.cos(ang),
    y: center.y + r * Math.cos(el) * Math.sin(ang),
    z: center.z + r * Math.sin(el)
  };
}

function abDesign_sampleBezier(p0, p1, p2, p3, n) {
  const pts = [];
  for (let i = 0; i < n; i++) {
    const t = i / (n - 1);
    const it = 1 - t;
    
    const x = it**3 * p0.x + 3 * it**2 * t * p1.x + 3 * it * t**2 * p2.x + t**3 * p3.x;
    const y = it**3 * p0.y + 3 * it**2 * t * p1.y + 3 * it * t**2 * p2.y + t**3 * p3.y;
    const z = it**3 * p0.z + 3 * it**2 * t * p1.z + 3 * it * t**2 * p2.z + t**3 * p3.z;
    
    pts.push({x, y, z});
  }
  return pts;
}

function abDesign_resetRibbonView() {
  if (viewerDesign) {
    viewerDesign.zoomTo();
    viewerDesign.render();
  }
}

function abDesign_exportRibbonPDB() {
  if (abDesign_ribbonChunks.length === 0) {
    alert('Please build the ribbon view first!');
    return;
  }
  
  let pdb = 'HEADER    ANTIBODY CDR RIBBON SCHEMATIC\n';
  pdb += 'REMARK   Generated by Antibody Design Suite\n';
  pdb += 'REMARK   This is an idealized CDR-only representation\n';
  pdb += 'REMARK   NOT a physically predicted structure\n';
  
  let serial = 1;
  let resi = 1;
  
  // Heavy chain CDRs
  const heavyChunks = abDesign_ribbonChunks.filter(c => c.label.startsWith('H'));
  for (const chunk of heavyChunks) {
    for (let i = 0; i < chunk.seq.length; i++) {
      const v = chunk.caPts[i];
      const resn = abDesign_aaThreeLetterCode(chunk.seq[i]);
      
      pdb += 'ATOM  ';
      pdb += String(serial).padStart(5) + '  ';
      pdb += 'CA  ';
      pdb += resn + ' ';
      pdb += 'H';
      pdb += String(resi).padStart(4) + '    ';
      pdb += v.x.toFixed(3).padStart(8);
      pdb += v.y.toFixed(3).padStart(8);
      pdb += v.z.toFixed(3).padStart(8);
      pdb += '  1.00 20.00           C\n';
      
      serial++;
      resi++;
    }
    resi += 3; // gap between loops
  }
  
  pdb += 'TER\n';
  
  // Light chain CDRs
  const lightChunks = abDesign_ribbonChunks.filter(c => c.label.startsWith('L'));
  resi = 1;
  for (const chunk of lightChunks) {
    for (let i = 0; i < chunk.seq.length; i++) {
      const v = chunk.caPts[i];
      const resn = abDesign_aaThreeLetterCode(chunk.seq[i]);
      
      pdb += 'ATOM  ';
      pdb += String(serial).padStart(5) + '  ';
      pdb += 'CA  ';
      pdb += resn + ' ';
      pdb += 'L';
      pdb += String(resi).padStart(4) + '    ';
      pdb += v.x.toFixed(3).padStart(8);
      pdb += v.y.toFixed(3).padStart(8);
      pdb += v.z.toFixed(3).padStart(8);
      pdb += '  1.00 20.00           C\n';
      
      serial++;
      resi++;
    }
    resi += 3;
  }
  
  pdb += 'TER\nEND\n';
  
  downloadBlob(pdb, 'antibody_cdr_ribbon.pdb', 'text/plain');
  alert('Ribbon PDB exported! (CDR C-alpha traces only)');
}

/* ======================================================== */
/* ===== END OF NAMESPACED AbDesigner SCRIPT ============== */
/* ======================================================== */

</script>
</body>
</html>
