<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Comprehensive Docking Suite ‚Ä¢ Antibody‚ÄìAntigen ‚Ä¢ Ligand Screening ‚Ä¢ Enthalpy</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0f172a" />
<meta name="description" content="Antibody‚Äìantigen docking, ligand docking, and batch virtual screening (50 SMILES √ó up to 3 receptors) with 3D visualization, QA reproducibility, run registry, exports, and analysis ‚Äî all in-browser." />
<style>
  :root{
    --bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--line:#1f2937;
    --green:#34d399;--red:#f87171;--yellow:#fbbf24;--orange:#f97316;--purple:#a78bfa;
    --mono:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;--sans:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans);line-height:1.6}
  a{color:var(--accent);text-decoration:none}
  header{padding:34px 16px;background:radial-gradient(1200px 600px at 15% -10%,#1d2a4a,transparent 60%),radial-gradient(1000px 500px at 120% 10%,#2a1e4a,transparent 60%)}
  .wrap{max-width:1400px;margin:0 auto}
  h1{margin:0 0 8px;font-size:30px;font-weight:700}
  h2{margin:0 0 10px;font-size:22px;font-weight:600}
  h3{margin:14px 0 6px;font-size:17px;font-weight:600}
  p.lead{color:var(--muted);margin:6px 0 0;font-size:14px}
  section{padding:22px 16px;border-top:1px solid var(--line);background:var(--panel)}
  .card{background:#0b1220;border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:12px}
  .grid{display:grid;gap:16px}
  @media(min-width:980px){.grid.two{grid-template-columns:1.05fr .95fr}}
  @media(min-width:1100px){.grid.three{grid-template-columns:repeat(3,1fr)}}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{font-weight:600;font-size:13px}
  input[type=number],input[type=text],textarea,select{
    background:#0a0f1a;color:var(--text);border:1px solid #1f2937;border-radius:8px;padding:8px 10px;font-family:var(--mono);font-size:13px;min-width:80px
  }
  textarea{width:100%;min-height:110px;resize:vertical}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:9px 12px;border-radius:10px;font-weight:600;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:13px;transition:.2s}
  .btn:hover:not([disabled]){transform:translateY(-1px);box-shadow:0 6px 16px rgba(96,165,250,.25)}
  .btn.primary{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0}
  .btn.green{background:linear-gradient(180deg,#059669,#047857);border:0}
  .btn.red{background:linear-gradient(180deg,#dc2626,#b91c1c);border:0}
  .btn.purple{background:linear-gradient(180deg,#7c3aed,#6d28d9);border:0}
  .btn.orange{background:linear-gradient(180deg,#f97316,#ea580c);border:0}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .pill{padding:2px 8px;border:1px solid #334155;border-radius:999px;font-size:12px;color:#93c5fd;font-weight:600}
  progress{width:260px;height:10px;border:1px solid var(--line);border-radius:999px;background:#0b1220}
  progress::-webkit-progress-value{background:#60a5fa;border-radius:999px;transition:width .3s}
  .infobox{border:1px solid #334155;border-left:4px solid var(--accent);border-radius:10px;padding:10px;background:#0a0f1a;color:#cbd5e1;margin:10px 0;font-size:13px}
  .errorbox{border:1px solid #7f1d1d;border-left:4px solid #dc2626;border-radius:10px;padding:10px;background:#1a0c0c;color:#fecaca;margin:10px 0}
  .successbox{border:1px solid #065f46;border-left:4px solid #10b981;border-radius:10px;padding:10px;background:#0a1f1a;color:#a7f3d0;margin:10px 0}
  .score{font-family:var(--mono);background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:8px;overflow:auto;font-size:12px;line-height:1.5}
  .chainchips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{border:1px solid #334155;border-radius:999px;padding:2px 8px;display:inline-flex;align-items:center;gap:6px;font-size:13px}
  .chip input{accent-color:#60a5fa}
  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .tabbtn{padding:8px 12px;border-radius:999px;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:14px;font-weight:600;transition:.2s}
  .tabbtn:hover{background:#152034}
  .tabbtn.active{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0;color:#fff}
  .tabsec{display:none}
  .tabsec.active{display:block}
  .table{width:100%;border-collapse:collapse;font-size:13px;background:#0a0f1a}
  .table th{background:#152034;padding:8px;text-align:left;border-bottom:2px solid var(--line);position:sticky;top:0;z-index:1}
  .table td{padding:6px 8px;border-bottom:1px solid #112033}
  .table tr:hover{background:#0f1829}
  .table-container{max-height:460px;overflow:auto;border:1px solid var(--line);border-radius:8px;margin-top:8px}
  #viewer,#viewerLig,#viewerScr,#viewerComp{position:relative;width:100%;height:560px;border:1px solid var(--line);border-radius:10px;background:#0a0f1a;overflow:hidden}
  .metric-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin:10px 0}
  .metric-card{background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:10px;text-align:center}
  .metric-value{font-size:20px;font-weight:700;color:var(--accent)}
  .metric-label{font-size:12px;color:var(--muted)}
  footer{padding:18px 16px;color:var(--muted);text-align:center;font-size:13px}
</style>
</head>
<body>

<header>
  <div class="wrap">
    <h1>üß¨ Comprehensive Molecular Docking Suite</h1>
    <p class="lead">
      Antibody‚Äìantigen docking ‚Ä¢ Single-ligand docking ‚Ä¢ Batch screening (‚â§50 SMILES √ó ‚â§3 receptors) ‚Ä¢
      ŒîH estimation ‚Ä¢ QA reproducibility ‚Ä¢ Run registry ‚Ä¢ All in your browser
    </p>
    <div class="tabs">
      <button class="tabbtn active" data-tab="dockTab">üß∑ Antibody Docking</button>
      <button class="tabbtn" data-tab="ligTab">üß™ Ligand Docking</button>
      <button class="tabbtn" data-tab="screenTab">üìö Batch Screening</button>
      <button class="tabbtn" data-tab="qaTab">‚úÖ QA & Registry</button>
      <button class="tabbtn" data-tab="analysisTab">üìä Analysis</button>
      <button class="tabbtn" data-tab="aboutTab">‚ÑπÔ∏è About</button>
    </div>
    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnDemo">üéØ Load Demo & Dock</button>
      <button class="btn green" id="btnSaveSession">üíæ Save Session</button>
      <button class="btn purple" id="btnLoadSession">üìÇ Load Session</button>
      <span class="pill" id="statusPill">idle</span>
      <progress id="prog" value="0" max="1" aria-label="progress"></progress>
    </div>
  </div>
</header>

<!-- ====================== ANTIBODY‚ÄìANTIGEN DOCKING ====================== -->
<section id="dockTab" class="tabsec active" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>1Ô∏è‚É£ Load Proteins</h2>
      <div class="row small" style="color:#9ca3af">Upload PDBs or paste text. Parse, then pick chains.</div>
      <div class="row">
        <div style="flex:1;min-width:300px">
          <h3>Protein A (Antibody) <span class="pill" id="badgeA">0 atoms</span></h3>
          <div class="row"><input type="file" id="pdbAFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('A')">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('A')">Fetch PDB ID</button></div>
          <textarea id="pdbAText" placeholder="Paste PDB for Protein A"></textarea>
          <div class="row"><label>Chains:</label><div id="chainsABox" class="chainchips"></div></div>
          <div id="chainWarnA" class="infobox small">Parse to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('A')">üîé Parse A</button><button class="btn" onclick="selectAllChains('A')">Select All</button><button class="btn" onclick="invertChains('A')">Invert</button></div>
        </div>
        <div style="flex:1;min-width:300px">
          <h3>Protein B (Antigen) <span class="pill" id="badgeB">0 atoms</span></h3>
          <div class="row"><input type="file" id="pdbBFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('B')">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('B')">Fetch PDB ID</button></div>
          <textarea id="pdbBText" placeholder="Paste PDB for Protein B"></textarea>
          <div class="row"><label>Chains:</label><div id="chainsBBox" class="chainchips"></div></div>
          <div id="chainWarnB" class="infobox small">Parse to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('B')">üîé Parse B</button><button class="btn" onclick="selectAllChains('B')">Select All</button><button class="btn" onclick="invertChains('B')">Invert</button></div>
        </div>
      </div>
      <details style="margin-top:10px"><summary><b>Input notes</b></summary>
        <div class="small" style="color:#9ca3af;padding-top:6px">
          <b>Formats:</b> PDB text, .pdb.gz ‚Ä¢ <b>Fetch:</b> RCSB via PDB ID ‚Ä¢ <b>Cartoon:</b> needs backbone atoms (N/CA/C/O)
        </div>
      </details>
    </div>

    <div class="card">
      <h2>2Ô∏è‚É£ Docking Parameters</h2>
      <h4>Sampling</h4>
      <div class="row">
        <label>Samples</label><input type="number" id="samples" value="10000" min="1000" step="500" />
        <label>Max Translation (√Ö)</label><input type="number" id="maxTrans" value="12" step="1" />
        <label>Atom Set</label><select id="atomMode"><option value="CA">CŒ± only</option><option value="BB">Backbone</option><option value="HEAVY">All heavy</option></select>
      </div>
      <h4 style="margin-top:8px">Scoring</h4>
      <div class="row">
        <label>Contact (√Ö)</label><input type="number" id="contactCut" value="4.8" step="0.1" />
        <label>Clash Factor</label><input type="number" id="clashFactor" value="0.85" step="0.05" />
        <label>Contact W</label><input type="number" id="wContact" value="1.0" step="0.1" />
        <label>Clash W</label><input type="number" id="wClash" value="6.0" step="0.1" />
        <label>Softness</label><input type="number" id="soft" value="0.5" step="0.1" />
      </div>
      <h4 style="margin-top:8px">Output</h4>
      <div class="row">
        <label>Top Poses</label><input type="number" id="topN" value="12" min="1" max="50" />
        <label>Rescore</label><select id="rescoreMode"><option value="NONE">Skip</option><option value="HEAVY">Heavy</option><option value="HEAVY_REFINE">Heavy + refine</option></select>
        <label>Seed</label><input type="number" id="seed" value="42" />
      </div>
      <div class="row">
        <label>Diversity (¬∞/√Ö)</label><input type="number" id="dupAngle" value="12" step="1" style="width:90px" />
        <input type="number" id="dupTrans" value="2" step="0.5" style="width:90px" />
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="dockBtn">‚ñ∂Ô∏è Run Docking</button>
        <button class="btn red" id="cancelBtn" disabled>‚úñ Cancel</button>
        <button class="btn orange" id="resetBtn">üîÑ Reset</button>
      </div>
      <div class="infobox small"><b>Score = contacts√óW<sub>c</sub> ‚àí clashes√óW<sub>x</sub></b>. Heavy rescoring refines ranks with all non-H atoms.</div>
    </div>
  </div>

  <div class="wrap grid two">
    <div class="card">
      <h2>3Ô∏è‚É£ 3D Visualization & Results</h2>
      <div id="viewer" role="img" aria-label="3D viewer"></div>
      <div class="row" style="margin-top:8px;flex-wrap:wrap" id="poseControls"></div>
      <div class="row" style="margin-top:8px">
        <label class="chip"><input type="checkbox" id="toggleContacts" checked> Contacts</label>
        <label class="chip"><input type="checkbox" id="toggleHB" checked> H-bonds</label>
        <label class="chip"><input type="checkbox" id="toggleSB" checked> Salt bridges</label>
        <label class="chip"><input type="checkbox" id="toggleHydro"> Hydrophobic</label>
      </div>
      <div class="score" id="scoreBox" style="margin-top:8px"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnAllPDB">‚¨á All Poses PDB</button>
        <button class="btn green" id="btnCurrentPDB">‚¨á Current PDB</button>
        <button class="btn" id="btnCSV">‚¨á CSV</button>
        <button class="btn" id="btnJSON">‚¨á JSON</button>
        <button class="btn purple" id="btnPNG">üì∏ PNG</button>
      </div>
    </div>

    <div class="card">
      <h2>Interface Metrics & Enthalpy</h2>
      <div class="metric-grid" id="metricsDisplay"></div>
      <h4 style="margin-top:10px">Energy Parameters</h4>
      <div class="row">
        <label>k<sub>elec</sub></label><input type="number" id="kElec" value="0.5" step="0.1" />
        <label>Elec Cutoff (√Ö)</label><input type="number" id="elecCut" value="12" step="0.5" />
        <label>Desolv W</label><input type="number" id="wDesolv" value="0.2" step="0.1" />
      </div>
      <div class="infobox small">
        <b>ŒîH (kcal/mol) ‚âà</b> ‚àí0.5√ócontacts ‚àí2.5√óH-bonds ‚àí4.0√ósalt-bridges ‚àí1.0√óhydrophobic +0.3√óclash + electrostatics +0.2√ócontacts (desolv).
      </div>
      <div class="infobox small"><b>Reproducibility:</b> All outputs include parameters & seed.</div>
    </div>
  </div>
</section>

<!-- ====================== LIGAND DOCKING ====================== -->
<section id="ligTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>üß™ Single Ligand Docking</h2>
      <div class="small" style="color:#9ca3af">SMILES‚Üí3D uses simplified embedding for demo; use RDKit/OpenBabel for production.</div>
      <div class="row">
        <div style="flex:1;min-width:300px">
          <h3>Receptor PDB</h3>
          <textarea id="ligReceptorPDB" placeholder="Paste receptor PDB"></textarea>
          <div class="row" style="margin-top:6px"><button class="btn" onclick="loadLigandDemoReceptor()">Load Example</button><button class="btn" onclick="parseReceptorForLigand()">Parse & Preview</button></div>
        </div>
        <div style="flex:1;min-width:300px">
          <h3>Ligand SMILES</h3>
          <textarea id="ligSmiles" placeholder="e.g., CC(=O)Oc1ccccc1C(=O)O (aspirin)"></textarea>
          <div class="row" style="margin-top:6px">
            <label>3D Method</label><select id="ligEmbedMethod"><option value="HASH">HashCloud</option><option value="HELIX">RingHelix</option></select>
            <label>Seed</label><input type="number" id="ligSeed" value="1337" style="width:90px" />
            <button class="btn primary" onclick="runSingleLigandDock()">‚ñ∂Ô∏è Dock</button>
          </div>
        </div>
      </div>
      <div class="infobox small"><b>Note:</b> Posing uses receptor center sampling; score = contacts ‚àí clash (same core terms).</div>
    </div>
    <div class="card">
      <h2>Ligand Docking Result</h2>
      <div id="viewerLig"></div>
      <div class="score" id="ligScore" style="margin-top:8px"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnLigPDB">‚¨á Complex PDB</button>
        <button class="btn" id="btnLigCSV">‚¨á CSV Result</button>
        <span class="pill" id="ligStatus">idle</span>
      </div>
    </div>
  </div>
</section>

<!-- ====================== BATCH SCREENING ====================== -->
<section id="screenTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>üìö Batch Screening (‚â§50 SMILES √ó ‚â§3 Receptors)</h2>
      <div class="grid three">
        <div>
          <h3>SMILES Library</h3>
          <textarea id="scrSmiles" placeholder="One SMILES per line (max 50)"></textarea>
        </div>
        <div>
          <h3>Receptors (PDBs)</h3>
          <textarea id="scrReceptors" placeholder="Paste 2‚Äì3 PDBs separated by a line with only: END"></textarea>
          <div class="small" style="color:#9ca3af">Delimiter must be exactly ‚ÄúEND‚Äù on its own line.</div>
        </div>
        <div>
          <h3>Parameters</h3>
          <div class="row"><label>Samples/Ligand</label><input type="number" id="scrSamples" value="5000" min="1000" step="500" /></div>
          <div class="row"><label>Contact (√Ö)</label><input type="number" id="scrContactCut" value="4.8" step="0.1" /></div>
          <div class="row"><label>Clash Factor</label><input type="number" id="scrClashFactor" value="0.85" step="0.05" /></div>
          <div class="row"><label>Seed</label><input type="number" id="scrSeed" value="777" /></div>
          <div class="row"><label>3D Method</label><select id="scrEmbedMethod"><option value="HASH">HashCloud</option><option value="HELIX">RingHelix</option></select></div>
          <div class="row" style="margin-top:10px"><button class="btn primary" id="btnStartScreen">‚ñ∂Ô∏è Start Screening</button><button class="btn red" id="btnStopScreen" disabled>‚úñ Stop</button></div>
          <div class="infobox small">Executes SMILES√óReceptor sequentially; progress after each dock.</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Results</h2>
      <div class="row" style="margin-bottom:8px">
        <button class="btn green" id="btnScrCSV">‚¨á Full Results CSV</button>
        <button class="btn" id="btnScrJSON">‚¨á JSON Export</button>
        <button class="btn purple" id="btnScrTop10">üìä Show Top 10</button>
        <span class="pill" id="scrStatus">idle</span>
        <span class="small" id="scrProgress" style="color:#9ca3af"></span>
      </div>
      <div class="table-container" style="max-height:460px">
        <table class="table" id="scrTable">
          <thead><tr>
            <th>#</th><th>Receptor</th><th>SMILES</th><th>Score</th><th>Contacts</th><th>H-bonds</th><th>SaltBr</th><th>Clash</th><th>ŒîH (kcal/mol)</th>
          </tr></thead>
          <tbody id="scrTableBody"></tbody>
        </table>
      </div>
      <div id="viewerScr" style="height:420px;margin-top:12px"></div>
      <div class="small" style="text-align:center;color:#9ca3af;margin-top:4px">Click a row to visualize that docked pose.</div>
    </div>

    <div class="card">
      <h2>Enthalpy Distribution</h2>
      <div class="metric-grid" id="screenMetrics"></div>
      <div class="score" id="enthalpyBreakdown" style="margin-top:8px"></div>
      <div class="infobox small"><b>Interpretation:</b> more negative ŒîH ‚áí stronger binding (approximate; entropy not included).</div>
    </div>
  </div>
</section>

<!-- ====================== QA & REGISTRY ====================== -->
<section id="qaTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>üìã Run Registry & Session Management</h2>
      <div class="row" style="margin-top:6px">
        <button class="btn green" onclick="saveCurrentRun()">üíæ Save Current Run</button>
        <button class="btn" onclick="refreshRunRegistry()">üîÑ Refresh</button>
        <button class="btn" onclick="exportAllRuns()">‚¨á Export Registry</button>
        <button class="btn purple" onclick="importRunRegistry()">‚¨Ü Import Registry</button>
        <button class="btn red" onclick="clearRunRegistry()">üóëÔ∏è Clear</button>
      </div>
      <input type="file" id="importRegistryFile" accept=".json" style="display:none" />
      <div class="table-container" style="margin-top:10px">
        <table class="table">
          <thead><tr><th>Timestamp</th><th>Type</th><th>Description</th><th>Top Score</th><th>Actions</th></tr></thead>
          <tbody id="registryTableBody"></tbody>
        </table>
      </div>
    </div>
    <div class="card">
      <h2>‚úÖ Quality Assurance (Reproducibility)</h2>
      <div class="row" style="margin-top:6px">
        <label>Repeats</label><input type="number" id="qaRepeats" value="3" min="2" max="10" style="width:90px" />
        <label>Tolerance</label><input type="number" id="qaTolerance" value="0.01" step="0.01" style="width:90px" />
        <button class="btn primary" onclick="runQATest()">‚ñ∂Ô∏è Run QA Test</button>
      </div>
      <div class="score" id="qaResults" style="margin-top:10px;min-height:120px"></div>
      <div class="infobox small">Runs N repeats with same seed; passes if top scores within tolerance.</div>
    </div>
  </div>
</section>

<!-- ====================== ANALYSIS ====================== -->
<section id="analysisTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>üìä Analysis Tools</h2>
      <div class="tabs" style="margin-top:6px">
        <button class="tabbtn active" data-subtab="energyTab">Energy Decomposition</button>
        <button class="tabbtn" data-subtab="compareTab">Pose Comparison</button>
        <button class="tabbtn" data-subtab="residueTab">Residue Contacts</button>
      </div>
      <div id="energyTab" class="tabsec active">
        <h3>Energy Component Analysis</h3>
        <div id="energyComponents" class="metric-grid"></div>
        <h4>ŒîH Details</h4>
        <div class="score" id="enthalpyDetail"></div>
      </div>
      <div id="compareTab" class="tabsec">
        <h3>Compare Poses</h3>
        <div class="row">
          <label>Pose 1</label><select id="comparePose1"></select>
          <label>Pose 2</label><select id="comparePose2"></select>
          <button class="btn primary" onclick="comparePoses()">Compare</button>
        </div>
        <div class="grid two" style="margin-top:10px">
          <div><div id="viewerComp" style="height:420px"></div></div>
          <div><div class="score" id="comparisonResults" style="min-height:420px"></div></div>
        </div>
      </div>
      <div id="residueTab" class="tabsec">
        <h3>Residue-Level Contacts</h3>
        <div class="row">
          <label>Min Dist (√Ö)</label><input type="number" id="filterMinDist" value="0" step="0.5" style="width:90px" />
          <label>Max Dist (√Ö)</label><input type="number" id="filterMaxDist" value="6" step="0.5" style="width:90px" />
          <button class="btn" onclick="filterResidueContacts()">Filter</button>
          <button class="btn green" onclick="exportResidueData()">‚¨á Export</button>
        </div>
        <div class="table-container" style="margin-top:8px">
          <table class="table">
            <thead><tr><th>Residue A</th><th>Chain A</th><th>Residue B</th><th>Chain B</th><th>Distance (√Ö)</th><th>Type</th><th>Energy</th></tr></thead>
            <tbody id="residueTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- ====================== ABOUT / DISCLAIMERS ====================== -->
<section id="aboutTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>About</h2>
      <p>This educational platform demonstrates in-browser docking with parallel sampling, simplified scoring, and interactive visualization. All computations run locally; nothing is uploaded.</p>
      <h3>Important Disclaimers</h3>
      <div class="errorbox">
        <p><b>We provide no warranties and we disclaim any loss in any way.</b></p>
        <p>Scoring/embedding are simplified approximations; entropy, solvation, polarization, and induced fit are not fully modeled. Validate results independently with professional tools and experiments.</p>
      </div>
      <h3>Recommended Workflow</h3>
      <div class="infobox small">Use this tool for hypothesis generation ‚Üí export top poses ‚Üí refine with AutoDock/HADDOCK/Rosetta ‚Üí MD simulations ‚Üí MM-PBSA/FEP ‚Üí experimental validation (SPR/ITC).</div>
      <h3>Credits</h3>
      <div class="small" style="color:#9ca3af">3Dmol.js (Rego & Koes) ‚Ä¢ Pako (zlib) ‚Ä¢ RCSB PDB</div>
    </div>
  </div>
</section>

<footer>
  <div class="wrap">
    <p>All computations execute locally in your browser. No data transmitted to servers.</p>
    <p class="small">¬© Educational Tool ‚Ä¢ No warranties ‚Ä¢ We disclaim any loss in any way ‚Ä¢ Validate results independently</p>
  </div>
</footer>

<!-- External libs -->
<script defer src="https://unpkg.com/3dmol@2.4.2/build/3Dmol-min.js"></script>
<script defer src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

<script>
// ========================= GLOBALS =========================
let viewer=null, viewerLig=null, viewerScr=null, viewerComp=null;
let inProgress=false, cancelled=false, workerPool=[];
let pdbAAllAtoms=[], pdbBAllAtoms=[], currentA=null, currentB0=null;
let posesTop=[], currentPose=null, currentPoseIndex=-1;
let currentContacts=[], currentHB=[], currentSB=[], currentHydro=[];
let ligLastResult={}, screenCancel=false, screenResults=[], screenReceptors=[], screenCurrentSort='score';
const REGISTRY_KEY='docking_registry_v1';

// vdW radii (√Ö)
const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
// hydrophobic residues
const hydrophobic=new Set(['ALA','VAL','LEU','ILE','PRO','PHE','MET','TRP','TYR','CYS']);
// residue charges (formal)
const residueCharges={'ASP':-1,'GLU':-1,'LYS':+1,'ARG':+1,'HIS':+0.1};

// Shorthands
const E=id=>document.getElementById(id);
const status=t=>E('statusPill').textContent=t;
const setProgress=f=>{E('prog').value=Math.max(0,Math.min(1,f||0));};

// ========================= INIT =========================
window.addEventListener('DOMContentLoaded', ()=>{
  ensureViewer('viewer'); ensureViewer('viewerLig'); ensureViewer('viewerScr'); ensureViewer('viewerComp');
  drawPlaceholder(viewer);
  setupMainTabs();
  setupSubTabs();
  bindEvents();
  loadSessionHistory();
  // Auto demo quickly
  setTimeout(autoDemo, 200);
});

// ========================= Tabs =========================
function setupMainTabs(){
  document.querySelectorAll('.tabbtn[data-tab]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      document.querySelectorAll('.tabbtn[data-tab]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      const target=btn.dataset.tab;
      document.querySelectorAll('[data-tab-panel]').forEach(sec=>{
        sec.classList.toggle('active', sec.id===target);
      });
      // resize visible viewers
      setTimeout(()=>{try{
        viewer?.resize(); viewerLig?.resize(); viewerScr?.resize(); viewerComp?.resize();
        viewer?.render(); viewerLig?.render(); viewerScr?.render(); viewerComp?.render();
      }catch(e){}},10);
    });
  });
}
function setupSubTabs(){
  document.querySelectorAll('.tabbtn[data-subtab]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const wrap=btn.closest('.card');
      wrap.querySelectorAll('.tabbtn[data-subtab]').forEach(b=>b.classList.remove('active'));
      wrap.querySelectorAll('.tabsec').forEach(s=>s.classList.remove('active'));
      btn.classList.add('active');
      wrap.querySelector('#'+btn.dataset.subtab).classList.add('active');
      setTimeout(()=>{viewerComp?.resize(); viewerComp?.render();},10);
    });
  });
}

// ========================= Viewers =========================
function ensureViewer(id){
  const el=E(id); if(!el) return;
  const opt={backgroundColor:'#0a0f1a'};
  if(id==='viewer' && !viewer) viewer=$3Dmol.createViewer(el,opt);
  else if(id==='viewerLig' && !viewerLig) viewerLig=$3Dmol.createViewer(el,opt);
  else if(id==='viewerScr' && !viewerScr) viewerScr=$3Dmol.createViewer(el,opt);
  else if(id==='viewerComp' && !viewerComp) viewerComp=$3Dmol.createViewer(el,opt);
}
function drawPlaceholder(v){
  if(!v) return;
  v.addSphere({center:{x:-8,y:0,z:0},radius:4,color:'#60a5fa',alpha:.6});
  v.addSphere({center:{x:8,y:0,z:0},radius:4,color:'#f97316',alpha:.6});
  v.zoomTo(); v.render();
}

// ========================= Events =========================
function bindEvents(){
  // global
  E('btnDemo').addEventListener('click', autoDemo);
  E('btnSaveSession').addEventListener('click', saveSession);
  E('btnLoadSession').addEventListener('click', loadSession);

  // docking
  E('dockBtn').addEventListener('click', runAntibodyDocking);
  E('cancelBtn').addEventListener('click', cancelDocking);
  E('resetBtn').addEventListener('click', resetAll);

  // exports
  E('btnAllPDB').addEventListener('click', downloadAllPoses);
  E('btnCurrentPDB').addEventListener('click', downloadCurrentPose);
  E('btnCSV').addEventListener('click', downloadCSV);
  E('btnJSON').addEventListener('click', downloadJSON);
  E('btnPNG').addEventListener('click', ()=>snapshotPNG(viewer));

  // overlays
  ['toggleContacts','toggleHB','toggleSB','toggleHydro'].forEach(id=>E(id).addEventListener('change', refreshOverlays));

  // file inputs
  E('pdbAFile').addEventListener('change', e=>handleFileUpload('A', e.target.files[0]));
  E('pdbBFile').addEventListener('change', e=>handleFileUpload('B', e.target.files[0]));

  // ligand docking
  E('btnLigPDB').addEventListener('click', downloadLigandPDB);
  E('btnLigCSV').addEventListener('click', downloadLigandCSV);

  // screening
  E('btnStartScreen').addEventListener('click', startBatchScreening);
  E('btnStopScreen').addEventListener('click', ()=>{screenCancel=true;E('btnStopScreen').disabled=true;});
  E('btnScrCSV').addEventListener('click', downloadScreeningCSV);
  E('btnScrJSON').addEventListener('click', downloadScreeningJSON);
  E('btnScrTop10').addEventListener('click', showTop10Screening);
}

// ========================= Utils =========================
async function fileToText(file){
  const name=file.name.toLowerCase(); const buf=await file.arrayBuffer();
  if(name.endsWith('.gz')){const u8=new Uint8Array(buf); const out=pako.inflate(u8); return new TextDecoder().decode(out);}
  return new TextDecoder().decode(buf);
}
async function handleFileUpload(which,file){ if(!file) return; try{
  const text=await fileToText(file);
  E(which==='A'?'pdbAText':'pdbBText').value=text; parseOne(which);
} catch(e){ alert('Error reading file: '+e.message); } }
async function fetchPDBFromRCSB(which){
  const pdbId=prompt(`Enter 4-character PDB ID for Protein ${which}:`); if(!pdbId) return;
  const id=pdbId.trim().toLowerCase(); if(id.length!==4){alert('PDB ID must be 4 chars');return;}
  try{ status(`fetching ${id}‚Ä¶`); const res=await fetch(`https://files.rcsb.org/download/${id}.pdb`);
    if(!res.ok) throw new Error('RCSB error'); const txt=await res.text();
    E(which==='A'?'pdbAText':'pdbBText').value=txt; await parseOne(which); status('idle');
  }catch(e){ alert('Fetch failed: '+e.message); status('error'); }
}
function centroid(pts){let x=0,y=0,z=0; for(const p of pts){x+=p.x;y+=p.y;z+=p.z;} const n=pts.length||1; return {x:x/n,y:y/n,z:z/n};}
function translate(points,t){return points.map(p=>({...p,x:p.x+t.x,y:p.y+t.y,z:p.z+t.z}));}
function formatPDB(atoms,chainShift=0){
  const lines=[]; let serial=1;
  for(const a of atoms){
    const name=(a.name||'CA').padStart(4,' '),resn=(a.resn||'RES').padStart(3,' ');
    const chain=String.fromCharCode((a.chain||'A').charCodeAt(0)+chainShift);
    const resi=String(a.resi||1).padStart(4,' '),x=(a.x??0).toFixed(3).padStart(8,' '),y=(a.y??0).toFixed(3).padStart(8,' '),z=(a.z??0).toFixed(3).padStart(8,' ');
    const elem=(a.elem||'C').toString().padStart(2,' ');
    lines.push(`ATOM  ${String(serial).padStart(5,' ')} ${name} ${resn} ${chain}${resi}    ${x}${y}${z}  1.00  0.00          ${elem}`); serial++;
  }
  lines.push('TER','ENDMDL','END'); return lines.join('\n');
}
function downloadBlob(text, filename){
  const url=URL.createObjectURL(new Blob([text],{type:'text/plain'}));
  const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000);
}
function snapshotPNG(v){
  try{ v.render(); v.pngURI((uri)=>{ const a=document.createElement('a'); a.href=uri; a.download='viewer.png'; a.click(); }); }catch(e){ alert('PNG failed: '+e.message);}
}

// ========================= PDB parsing / chains =========================
function parsePDB(text){
  const atoms=[]; const lines=text.split(/\r?\n/);
  for(const line of lines){
    if(!line.startsWith('ATOM') && !line.startsWith('HETATM')) continue;
    const atom={
      name:line.substring(12,16).trim(), resn:line.substring(17,20).trim(),
      chain:line.substring(21,22).trim()||'A', resi:parseInt(line.substring(22,26)),
      x:parseFloat(line.substring(30,38)), y:parseFloat(line.substring(38,46)), z:parseFloat(line.substring(46,54)),
      elem: (line.length>=78? (line.substring(76,78).trim()||line.substring(12,16).trim()[0]) : line.substring(12,16).trim()[0]).toUpperCase()
    };
    atoms.push(atom);
  }
  return atoms;
}
async function parseOne(which){
  const t = E(which==='A'?'pdbAText':'pdbBText').value.trim();
  if(!t){ alert('Paste PDB or upload file first.'); return; }
  const atoms=parsePDB(t);
  if(!atoms.length){ alert('No atoms parsed ‚Äî check PDB.'); return; }
  if(which==='A'){ pdbAAllAtoms=atoms; populateChainChips('A',atoms); E('badgeA').textContent=`${atoms.length} atoms`; }
  else{ pdbBAllAtoms=atoms; populateChainChips('B',atoms); E('badgeB').textContent=`${atoms.length} atoms`; }
}
function populateChainChips(which, atoms){
  const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.innerHTML='';
  const chains=[...new Set(atoms.map(a=>a.chain))]; chains.forEach(c=>{
    const id=`${which}_ch_${c}`; const lbl=document.createElement('label'); lbl.className='chip';
    lbl.innerHTML=`<input type="checkbox" id="${id}" data-which="${which}" data-chain="${c}" checked> ${c}`;
    box.appendChild(lbl);
  });
  const warn=which==='A'?E('chainWarnA'):E('chainWarnB'); warn.className='successbox small';
  warn.textContent=`‚úì Parsed ${atoms.length} atoms ‚Ä¢ Chains: ${chains.join(', ')||'‚Äî'}`;
}
function selectedChains(which){
  const box=which==='A'?E('chainsABox'):E('chainsBBox');
  const selected=[...box.querySelectorAll('input[type=checkbox]')].filter(cb=>cb.checked).map(cb=>cb.dataset.chain);
  return new Set(selected);
}
function selectAllChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=true); }
function invertChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=!cb.checked); }
function filterChains(atoms, keep){ if(!keep || keep.size===0) return atoms; return atoms.filter(a=>keep.has(a.chain)); }
function selectAtomSet(atoms, mode){
  const bb=new Set(['N','CA','C','O']); return atoms.filter(a=>{
    if(mode==='CA') return a.name==='CA'; if(mode==='BB') return bb.has(a.name); return a.elem!=='H';
  });
}

// ========================= Worker (sampling/scoring) =========================
function makeDockWorker(){
  const code=`
    const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
    function rand(seed){let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);}
    function randomQuat(r){const u1=r(),u2=r(),u3=r(); const a=Math.sqrt(1-u1),b=Math.sqrt(u1),t1=2*Math.PI*u2,t2=2*Math.PI*u3; return [a*Math.sin(t1),a*Math.cos(t1),b*Math.sin(t2),b*Math.cos(t2)];}
    function rotate(points,q){const[qx,qy,qz,qw]=q; return points.map(p=>{const vx=p.x,vy=p.y,vz=p.z; const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz; const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy),oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz),oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx); return {x:ox,y:oy,z:oz,elem:p.elem};});}
    function translate(points,t){return points.map(p=>({x:p.x+t.x,y:p.y+t.y,z:p.z+t.z,elem:p.elem}));}
    function grid(coords,c){const m=new Map(),k=(ix,iy,iz)=>ix+"|"+iy+"|"+iz; for(let i=0;i<coords.length;i++){const x=coords[i].x,y=coords[i].y,z=coords[i].z,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),kk=k(ix,iy,iz); if(!m.has(kk)) m.set(kk,[]); m.get(kk).push(i);} return {c,m};}
    function neigh(g,x,y,z){const c=g.c,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),out=[]; for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++)for(let dz=-1;dz<=1;dz++){const kk=(ix+dx)+"|"+(iy+dy)+"|"+(iz+dz); if(g.m.has(kk)) out.push(...g.m.get(kk));} return out;}
    function scorePose(A,B,contact,clashFact,wC,wX,soft){const G=grid(A,contact); let contacts=0, clash=0;
      for(let i=0;i<B.length;i++){const x=B[i].x,y=B[i].y,z=B[i].z, eB=(B[i].elem||'C').toUpperCase(), neighs=neigh(G,x,y,z);
        for(const j of neighs){const a=A[j],dx=x-a.x,dy=y-a.y,dz=z-a.z, d=Math.hypot(dx,dy,dz), eA=(a.elem||'C').toUpperCase();
          const rs=(vdw[eA]||1.7)+(vdw[eB]||1.7), clashCut=clashFact*rs;
          if(d<=clashCut){const ov=(clashCut-d+1e-6)/clashCut; clash+=wX*ov*(1/(1+soft*ov));}
          else if(d<=contact){contacts+=1;}
        }
      }
      return {score: wC*contacts - clash, contacts, clash};
    }
    self.onmessage=(ev)=>{
      const {Apts,Bpts,params,start,end}=ev.data; const rng=rand(params.seed+start*1337);
      const best=[]; const total=end-start;
      for(let k=0;k<total;k++){
        const q=randomQuat(rng), t={x:(rng()*2-1)*params.maxTrans, y:(rng()*2-1)*params.maxTrans, z:(rng()*2-1)*params.maxTrans};
        const B=translate(rotate(Bpts,q),t), s=scorePose(Apts,B,params.contactCut,params.clashFactor,params.wContact,params.wClash,params.soft);
        best.push({score:s.score,contacts:s.contacts,clash:s.clash,q:[...q],t});
        if((k&1023)===0) self.postMessage({type:'progress',count:k});
      }
      best.sort((a,b)=>b.score-a.score);
      self.postMessage({type:'done',poses:best.slice(0,Math.min(200,total))});
    };
  `;
  return new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
}
function angleBetweenQuats(q1,q2){const dot=q1[0]*q2[0]+q1[1]*q2[1]+q1[2]*q2[2]+q1[3]*q2[3]; return 2*Math.acos(Math.min(1,Math.abs(dot)))*180/Math.PI;}
function diverseTop(sorted,deg,transA){
  const out=[]; const max=Math.max(1,parseInt(E('topN').value)||10);
  for(const p of sorted){
    let dupe=false;
    for(const s of out){
      const a=angleBetweenQuats(p.q,s.q);
      const t=Math.hypot(p.t.x-s.t.x,p.t.y-s.t.y,p.t.z-s.t.z);
      if(a<=deg && t<=transA){dupe=true;break;}
    }
    if(!dupe){out.push(p); if(out.length>=max) break;}
  }
  return out;
}

// ========================= Docking driver =========================
async function runAntibodyDocking(){
  if(inProgress) return;
  cancelled=false; inProgress=true; status('preparing'); setProgress(0);
  E('dockBtn').disabled=true; E('cancelBtn').disabled=false; E('dockBtn').textContent='Running‚Ä¶';
  try{
    const textA=await ensureInputText('A'), textB=await ensureInputText('B');
    pdbAAllAtoms=parsePDB(textA); pdbBAllAtoms=parsePDB(textB);
    populateChainChips('A',pdbAAllAtoms); populateChainChips('B',pdbBAllAtoms);

    const params=collectDockingParams();
    const aSel=filterChains(pdbAAllAtoms, selectedChains('A'));
    const bSel=filterChains(pdbBAllAtoms, selectedChains('B'));
    if(!aSel.length||!bSel.length) throw new Error('No atoms after chain filtering. Select valid chains (or Select All).');

    const ptsA0=selectAtomSet(aSel,params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
    const ptsB0=selectAtomSet(bSel,params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
    if(!ptsA0.length||!ptsB0.length) throw new Error('Atom selection empty. Try Backbone or Heavy mode.');
    const cA=centroid(ptsA0), cB=centroid(ptsB0);
    const ptsA=translate(ptsA0,{x:-cA.x,y:-cA.y,z:-cA.z});
    const ptsB=translate(ptsB0,{x:-cB.x,y:-cB.y,z:-cB.z});

    status('sampling');
    const cores=Math.max(1,(navigator.hardwareConcurrency||4)-1), pool=Math.min(cores,8);
    const total=params.samples, base=Math.floor(total/pool), extra=total%pool;
    let all=[], done=0; workerPool=[];
    for(let i=0;i<pool;i++){
      const start=i*base+Math.min(i,extra), end=start+base+(i<extra?1:0);
      const w=makeDockWorker(); workerPool.push(w);
      w.onmessage=(m)=>{
        if(cancelled) return;
        const msg=m.data;
        if(msg.type==='progress'){ done+=1024; setProgress(Math.min(1,done/total)); status(`sampling ${Math.min(done,total)}/${total}`); }
        if(msg.type==='done'){ all.push(msg.poses); w.terminate(); if(all.length===pool){ finalizeDocking(all.flat(),params,aSel,bSel,cA,cB); } }
      };
      w.onerror=(e)=>{console.error('worker error',e); w.terminate();};
      w.postMessage({Apts:ptsA,Bpts:ptsB,params,start,end});
    }
  }catch(e){ alert(e.message||'Docking error'); finishDocking(); status('error'); inProgress=false; }
}
function cancelDocking(){ cancelled=true; workerPool.forEach(w=>{try{w.terminate();}catch(e){}}); workerPool=[]; setProgress(0); status('cancelled'); finishDocking(); inProgress=false; }
function finishDocking(){ E('dockBtn').disabled=false; E('cancelBtn').disabled=true; E('dockBtn').textContent='‚ñ∂Ô∏è Run Docking'; }
function collectDockingParams(){
  return {samples:parseInt(E('samples').value),maxTrans:parseFloat(E('maxTrans').value),contactCut:parseFloat(E('contactCut').value),
    clashFactor:parseFloat(E('clashFactor').value),wContact:parseFloat(E('wContact').value),wClash:parseFloat(E('wClash').value),soft:parseFloat(E('soft').value),
    topN:Math.max(1,parseInt(E('topN').value)),seed:parseInt(E('seed').value)||42,atomMode:E('atomMode').value,rescoreMode:E('rescoreMode').value};
}
async function ensureInputText(which){
  const file=E(which==='A'?'pdbAFile':'pdbBFile').files[0];
  let t=E(which==='A'?'pdbAText':'pdbBText').value.trim(); if(!t && file){ t=await fileToText(file); }
  if(!t) throw new Error(`Provide PDB for Protein ${which} (file or text).`); return t;
}
async function finalizeDocking(poses, params, atomsA, atomsB, cA, cB){
  if(cancelled) return cancelDocking();
  status(params.rescoreMode==='NONE'?'ranking': (params.rescoreMode==='HEAVY'?'rescoring':'refining'));
  poses.sort((a,b)=>b.score-a.score);
  const diverse=diverseTop(poses, parseFloat(E('dupAngle').value)||12, parseFloat(E('dupTrans').value)||2);

  // heavy sets for viz
  const Aheavy=translate(selectAtomSet(atomsA,'HEAVY').map(a=>({...a})), {x:-cA.x,y:-cA.y,z:-cA.z});
  const Bheavy0=translate(selectAtomSet(atomsB,'HEAVY').map(a=>({...a})), {x:-cB.x,y:-cB.y,z:-cB.z});

  let top=diverse;
  if(params.rescoreMode!=='NONE'){ top=await heavyAtomRescore(Aheavy,Bheavy0,params,diverse, params.rescoreMode==='HEAVY_REFINE'); }

  posesTop=top; currentA=Aheavy; currentB0=Bheavy0;
  buildPoseButtons(top); if(top.length) showPose(0);
  updateMetricsDisplay();
  finishDocking(); status('complete'); setProgress(1); inProgress=false;
}
function heavyAtomRescore(A,B0,params,coarse,refine=false){
  const {contactCut,clashFactor,wContact,wClash,soft}=params;
  function score(A,B){
    let contacts=0, clash=0;
    for(const b of B) for(const a of A){
      const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z);
      const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7), cut=clashFactor*rs;
      if(d<=cut){ const ov=(cut-d+1e-6)/cut; clash+=wClash*ov*(1/(1+soft*ov)); }
      else if(d<=contactCut){ contacts++; }
    }
    return {score:wContact*contacts-clash,contacts,clash};
  }
  function jiggle(p){ const r=()=> (Math.random()*2-1)*0.5; const dq=[p.q[0]+r()*0.01,p.q[1]+r()*0.01,p.q[2]+r()*0.01,p.q[3]+r()*0.01];
    const n=Math.hypot(...dq); for(let i=0;i<4;i++) dq[i]/=n; const dt={x:p.t.x+r(),y:p.t.y+r(),z:p.t.z+r()}; return {q:dq,t:dt}; }
  const rescored=[];
  for(const p of coarse){
    let best={...p}; let TB=applyTransform(B0,p.q,p.t); let s=score(A,TB);
    best.score=s.score; best.contacts=s.contacts; best.clash=s.clash;
    if(refine){ for(let it=0;it<40;it++){ const pp=jiggle(best); const TB2=applyTransform(B0,pp.q,pp.t); const s2=score(A,TB2);
      if(s2.score>best.score){ best.q=pp.q; best.t=pp.t; best.score=s2.score; best.contacts=s2.contacts; best.clash=s2.clash; } } }
    rescored.push(best);
  }
  rescored.sort((a,b)=>b.score-a.score); return rescored.slice(0,parseInt(E('topN').value));
}
function applyTransform(points,q,t){
  const [qx,qy,qz,qw]=q;
  return points.map(p=>{
    const vx=p.x,vy=p.y,vz=p.z;
    const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz;
    const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy),oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz),oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx);
    return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name};
  });
}

// ========================= Visualization / overlays =========================
function buildPoseButtons(poses){
  const c=E('poseControls'); c.innerHTML='';
  poses.forEach((p,i)=>{
    const b=document.createElement('button'); b.className='btn'; b.textContent=`Pose ${i+1} (S=${p.score.toFixed(1)}, C=${p.contacts|0}, X=${p.clash.toFixed(1)})`;
    b.addEventListener('click',()=>showPose(i)); c.appendChild(b);
    const d=document.createElement('button'); d.className='btn green'; d.style.marginLeft='6px'; d.textContent='‚¨á PDB';
    d.addEventListener('click',()=>downloadSinglePose(i)); c.appendChild(d);
  });
  updateComparisonDropdowns(poses);
}
function showPose(i){
  if(i<0||i>=posesTop.length) return; currentPose=posesTop[i]; currentPoseIndex=i;
  const TB=applyTransform(currentB0,currentPose.q,currentPose.t);
  viewer.clear(); viewer.addModel(formatPDB(currentA),'pdb'); viewer.addModel(formatPDB(TB,1),'pdb');
  const rA=new Set(currentA.map(a=>a.resi)).size, rB=new Set(TB.map(a=>a.resi)).size, cartoon=rA>=8 && rB>=8;
  if(cartoon){ viewer.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewer.setStyle({model:1},{cartoon:{color:'#f97316'}}); }
  else{ viewer.setStyle({model:0},{stick:{radius:.25}}); viewer.setStyle({model:1},{stick:{radius:.25,color:'#f97316'}}); }
  viewer.zoomTo();

  const cutoff=parseFloat(E('contactCut').value);
  const metrics=computeInterfaceMetrics(currentA,TB,cutoff);
  currentContacts=metrics.contactsPairs; currentHB=metrics.hbPairs; currentSB=metrics.sbPairs; currentHydro=metrics.hydroPairs||[];
  refreshOverlays();

  const kElec=parseFloat(E('kElec').value)||0.5, eCut=parseFloat(E('elecCut').value)||12;
  const elec=coulombEnergy(currentA,TB,kElec,eCut);
  const BSA=metrics.contacts*10.0;
  const dH=calculateEnthalpy(metrics,elec);

  E('scoreBox').innerHTML=`<b>Pose ${i+1}</b><br>
  Score: ${currentPose.score.toFixed(2)} | Contacts: ${metrics.contacts} | Clash: ${metrics.clash.toFixed(2)} |
  H-bonds: ${metrics.hb} | SaltBr: ${metrics.sb} | Hydrophobics: ${metrics.hydrophobics}<br>
  BSA ‚âà ${BSA.toFixed(0)} √Ö¬≤ | Electrostatics: ${elec.toFixed(2)} kcal/mol | <b>ŒîH ‚âà ${dH.toFixed(2)} kcal/mol</b>`;
  updateMetricsDisplay(); updateEnergyDecomposition(metrics,elec,dH);
  viewer.render();
}
function refreshOverlays(){
  if(!currentPose) return; viewer.removeAllShapes();
  if(E('toggleContacts').checked) drawLines(currentContacts,'#60a5fa');
  if(E('toggleHB').checked)       drawLines(currentHB,'#34d399');
  if(E('toggleSB').checked)       drawLines(currentSB,'#f87171');
  if(E('toggleHydro').checked)    drawLines(currentHydro,'#fbbf24');
  viewer.render();
}
function drawLines(pairs,color){ pairs.slice(0,400).forEach(p=>{
  viewer.addLine({start:{x:p.x1,y:p.y1,z:p.z1},end:{x:p.x2,y:p.y2,z:p.z2},dashed:true,dashLength:.5,color,linewidth:2});
}); }
function computeInterfaceMetrics(A,B,cut){
  let contacts=0,clash=0,hb=0,sb=0,hydro=0; const contactsPairs=[],hbPairs=[],sbPairs=[],hydroPairs=[];
  const clashFactor=parseFloat(E('clashFactor').value)||0.85;
  for(const b of B) for(const a of A){
    const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z);
    const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7), cutCl=clashFactor*rs;
    if(d<=cutCl){ const ov=(cutCl-d+1e-6)/cutCl; clash+=6.0*ov*(1/(1+0.5*ov)); }
    if(d<=cut){ contacts++; contactsPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
    const aN=a.name?.startsWith('N'), aO=a.name?.startsWith('O'), bN=b.name?.startsWith('N'), bO=b.name?.startsWith('O');
    if(((aN&&bO)||(aO&&bN)) && d<=3.5){ hb++; hbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
    const isAcidic=at=> (at.resn==='ASP'&&at.name.startsWith('OD'))||(at.resn==='GLU'&&at.name.startsWith('OE'));
    const isBasic =at=> (at.resn==='LYS'&&at.name==='NZ')||(at.resn==='ARG'&&(at.name==='NH1'||at.name==='NH2'||at.name==='NE'))||(at.resn==='HIS'&&(at.name==='ND1'||at.name==='NE2'));
    if(((isAcidic(a)&&isBasic(b))||(isAcidic(b)&&isBasic(a))) && d<=4.0){ sb++; sbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
    if(hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)&&(a.elem==='C'||b.elem==='C')&&d<=4.5){ hydro++; hydroPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
  }
  return {contacts,clash,hb,sb,hydrophobics:hydro,contactsPairs:contactsPairs,hbPairs:hbPairs,sbPairs:sbPairs,hydroPairs:hydroPairs};
}
function coulombEnergy(A,B,k=0.5,cut=12){
  const AA=residueChargesFor(A), BB=residueChargesFor(B); let E=0, cut2=cut*cut;
  for(const a of AA) for(const b of BB){
    const dx=a.x-b.x,dy=a.y-b.y,dz=a.z-b.z, d2=dx*dx+dy*dy+dz*dz; if(d2>cut2) continue;
    E+=k*(a.q*b.q)/(Math.sqrt(d2)+1e-3);
  }
  return E;
}
function residueChargesFor(atoms){
  const groups=new Map();
  for(const a of atoms){ const key=a.chain+':'+a.resi; if(!groups.has(key)) groups.set(key,[]); groups.get(key).push(a); }
  const out=[];
  for(const [key,arr] of groups.entries()){
    const res=arr[0].resn||'UNK', q=residueCharges[res]||0; if(!q) continue;
    const ca=arr.find(x=>x.name==='CA'); let x,y,z;
    if(ca){x=ca.x;y=ca.y;z=ca.z;} else{ let sx=0,sy=0,sz=0; for(const a of arr){sx+=a.x; sy+=a.y; sz+=a.z;} x=sx/arr.length; y=sy/arr.length; z=sz/arr.length; }
    out.push({x,y,z,q,resn:res});
  }
  return out;
}
function calculateEnthalpy(m,elec){
  const w={contact:-0.5,hbond:-2.5,salt:-4.0,hydro:-1.0,clash:+0.3,desolv:+0.2};
  return w.contact*m.contacts + w.hbond*m.hb + w.salt*m.sb + w.hydro*m.hydrophobics + w.clash*m.clash + elec + w.desolv*m.contacts;
}

// ========================= Metrics / Analysis UI =========================
function updateMetricsDisplay(){
  const tgt=E('metricsDisplay'); if(!currentPose){ tgt.innerHTML='<div class="small" style="color:#9ca3af">Run docking to see metrics.</div>'; return; }
  tgt.innerHTML=`
    <div class="metric-card"><div class="metric-value">${currentPose.score.toFixed(2)}</div><div class="metric-label">Score</div></div>
    <div class="metric-card"><div class="metric-value">${currentContacts.length}</div><div class="metric-label">Contacts</div></div>
    <div class="metric-card"><div class="metric-value">${currentHB.length}</div><div class="metric-label">H-bonds</div></div>
    <div class="metric-card"><div class="metric-value">${currentSB.length}</div><div class="metric-label">Salt Bridges</div></div>
  `;
}
function updateEnergyDecomposition(m,elec,dH){
  const box=E('energyComponents');
  const parts=[['Contacts','+'+(m.contacts),-0.5*m.contacts],['H-bonds','+'+(m.hb),-2.5*m.hb],['SaltBr','+'+(m.sb),-4.0*m.sb],['Hydrophobic','+'+(m.hydrophobics),-1.0*m.hydrophobics],['Clash','+'+m.clash,(+0.3*m.clash)],['Electrostatics','',elec],['Desolv','+'+m.contacts,+0.2*m.contacts]];
  box.innerHTML=parts.map(([k,c,v])=>`<div class="metric-card"><div class="metric-value">${v.toFixed(2)}</div><div class="metric-label">${k} ${c}</div></div>`).join('');
  E('enthalpyDetail').textContent = `ŒîH ‚âà ${dH.toFixed(2)} kcal/mol (contacts, H-bonds, salt bridges, hydrophobic, clash, electrostatics, desolvation).`;
}
function updateComparisonDropdowns(poses){
  const s1=E('comparePose1'), s2=E('comparePose2'); s1.innerHTML=''; s2.innerHTML='';
  poses.forEach((p,i)=>{ const o1=document.createElement('option'); o1.value=i; o1.textContent=`Pose ${i+1}`; s1.appendChild(o1);
                         const o2=document.createElement('option'); o2.value=i; o2.textContent=`Pose ${i+1}`; s2.appendChild(o2); });
  if(poses.length>=2){ s1.value=0; s2.value=1; }
}
function comparePoses(){
  const i1=parseInt(E('comparePose1').value), i2=parseInt(E('comparePose2').value);
  if(!(posesTop[i1]&&posesTop[i2])) return;
  const TB1=applyTransform(currentB0,posesTop[i1].q,posesTop[i1].t);
  viewerComp.clear(); viewerComp.addModel(formatPDB(currentA),'pdb'); viewerComp.addModel(formatPDB(TB1,1),'pdb');
  viewerComp.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewerComp.setStyle({model:1},{cartoon:{color:'#f97316'}}); viewerComp.zoomTo(); viewerComp.render();
  const a=angleBetweenQuats(posesTop[i1].q, posesTop[i2].q), t=Math.hypot(posesTop[i1].t.x-posesTop[i2].t.x,posesTop[i1].t.y-posesTop[i2].t.y,posesTop[i1].t.z-posesTop[i2].t.z);
  E('comparisonResults').textContent = `Pose1 score=${posesTop[i1].score.toFixed(2)}, Pose2 score=${posesTop[i2].score.toFixed(2)}\nŒîangle ‚âà ${a.toFixed(1)}¬∞, Œîtranslation ‚âà ${t.toFixed(2)} √Ö`;
}
function filterResidueContacts(){
  const min=parseFloat(E('filterMinDist').value)||0, max=parseFloat(E('filterMaxDist').value)||6;
  if(!currentPose) return; const TB=applyTransform(currentB0,currentPose.q,currentPose.t);
  const rows=[]; for(const b of TB) for(const a of currentA){
    const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z); if(d<min||d>max) continue;
    const type=(a.name?.startsWith('N')&&b.name?.startsWith('O')||a.name?.startsWith('O')&&b.name?.startsWith('N'))&&d<=3.5?'H-bond': (hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)?'Hydrophobic': (d<=4?'Contact':'Proximal'));
    const e=type==='H-bond'?-2.5:type==='Hydrophobic'?-1.0:type==='Contact'?-0.5:0;
    rows.push(`<tr><td>${a.resn}${a.resi}</td><td>${a.chain}</td><td>${b.resn||'-'}${b.resi||'-'}</td><td>${b.chain||'-'}</td><td>${d.toFixed(2)}</td><td>${type}</td><td>${e.toFixed(2)}</td></tr>`);
  }
  E('residueTableBody').innerHTML=rows.slice(0,1000).join('');
}
function exportResidueData(){
  const table=E('residueTableBody').innerText||''; if(!table){alert('No data');return;}
  downloadBlob(table,'residue_contacts.txt');
}

// ========================= Exports =========================
function downloadAllPoses(){
  if(!posesTop.length){alert('No poses.');return;}
  const lines=[]; posesTop.forEach((p,i)=>{lines.push(`MODEL     ${i+1}`); lines.push(formatPDB(currentA)); lines.push(formatPDB(applyTransform(currentB0,p.q,p.t),1)); lines.push('ENDMDL');});
  lines.push('END'); downloadBlob(lines.join('\n'),'all_poses.pdb');
}
function downloadSinglePose(i){
  const p=posesTop[i]; const TB=applyTransform(currentB0,p.q,p.t); const pdb=formatPDB(currentA)+'\n'+formatPDB(TB,1); downloadBlob(pdb,`pose_${i+1}.pdb`);
}
function downloadCurrentPose(){ if(currentPoseIndex<0){alert('No pose selected.');return;} downloadSinglePose(currentPoseIndex); }
function downloadCSV(){
  if(!posesTop.length){alert('No poses.');return;}
  const rows=['rank,score,contacts,clash,qx,qy,qz,qw,tx,ty,tz'];
  posesTop.forEach((p,i)=>rows.push([i+1,p.score.toFixed(4),p.contacts,p.clash.toFixed(4),p.q[0].toFixed(6),p.q[1].toFixed(6),p.q[2].toFixed(6),p.q[3].toFixed(6),p.t.x.toFixed(3),p.t.y.toFixed(3),p.t.z.toFixed(3)].join(',')));
  downloadBlob(rows.join('\n'),'poses_summary.csv');
}
function downloadJSON(){
  if(!posesTop.length){alert('No poses.');return;}
  const out={params:collectDockingParams(), poses:posesTop}; downloadBlob(JSON.stringify(out,null,2),'poses.json');
}

// ========================= Ligand docking =========================
function loadLigandDemoReceptor(){
  E('ligReceptorPDB').value=`ATOM      1  CA  ALA A   1      -8.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  ALA A   2      -6.600   1.200   0.200  1.00  0.00           C
ATOM      3  CA  ALA A   3      -5.200   0.100   1.200  1.00  0.00           C
ATOM      4  CA  ALA A   4      -3.800   1.400   1.400  1.00  0.00           C
ATOM      5  CA  ALA A   5      -2.400   0.500   2.200  1.00  0.00           C
END`;
}
function parseReceptorForLigand(){
  const t=E('ligReceptorPDB').value.trim(); if(!t){alert('Paste receptor PDB first'); return;}
  const atoms=parsePDB(t); viewerLig.clear(); viewerLig.addModel(formatPDB(atoms),'pdb'); viewerLig.setStyle({},{cartoon:{color:'#60a5fa'}}); viewerLig.zoomTo(); viewerLig.render();
}
function embedSmilesTo3D(smiles, method='HASH', seed=1337){
  // Very simplified: map chars to pseudo atoms along a 3D curve (demo purposes)
  const rng=(()=>{let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
  const atoms=[]; let t=0;
  for(const ch of smiles.replace(/\s+/g,'')){
    const elem = /[NOFPSClBrI]/i.test(ch)? ch.replace(/[a-z]/,'').toUpperCase().slice(0,2) : 'C';
    const r = method==='HELIX' ? 6 : 4;
    const x = r*Math.cos(t*0.6), y = (method==='HELIX'? t*0.8 : t*0.5), z = r*Math.sin(t*0.6);
    atoms.push({name:'C',resn:'LIG',chain:'L',resi:atoms.length+1,x,y,z,elem});
    t += 1 + (rng()*0.3);
  }
  return atoms;
}
function ligandScore(receptor, ligand, contact=4.8, clashF=0.85){
  let contacts=0, clash=0, hb=0, sb=0, hydro=0;
  for(const l of ligand) for(const r of receptor){
    const d=Math.hypot(l.x-r.x,l.y-r.y,l.z-r.z);
    const rs=(vdw[(l.elem||'C')]||1.7)+(vdw[(r.elem||'C')]||1.7), cc=clashF*rs;
    if(d<=cc){ const ov=(cc-d+1e-6)/cc; clash += 6.0*ov*(1/(1+0.5*ov)); }
    else if(d<=contact){ contacts++; }
    const isN=x=>(x.elem==='N'||x.name==='N'), isO=x=>(x.elem==='O'||x.name==='O');
    if(((isN(l)&&isO(r))||(isO(l)&&isN(r))) && d<=3.5) hb++;
    if((l.elem==='C'||r.elem==='C') && d<=4.5) hydro++;
  }
  const score = contacts - clash;
  // Approximate ŒîH like protein case
  const dH = -0.5*contacts -2.5*hb -1.0*hydro +0.3*clash;
  return {score,contacts,clash,hb,hydro,enthalpy:dH};
}
function runSingleLigandDock(){
  const recTxt=E('ligReceptorPDB').value.trim(), smiles=E('ligSmiles').value.trim();
  if(!recTxt){alert('Paste receptor PDB');return;}
  if(!smiles){alert('Enter SMILES');return;}
  const R=parsePDB(recTxt).filter(a=>a.elem!=='H'); const seed=parseInt(E('ligSeed').value)||1337, method=E('ligEmbedMethod').value;
  const L=embedSmilesTo3D(smiles,method,seed);
  // center receptor and ligand, then random translate ligand near center
  const cR=centroid(R), cL=centroid(L), Rc=translate(R,{x:-cR.x,y:-cR.y,z:-cR.z}), Lc=translate(L,{x:-cL.x,y:-cL.y,z:-cL.z});
  // minimal sampling: try few translations
  let best=null; for(let k=0;k<200;k++){ const t={x:(Math.random()*2-1)*8,y:(Math.random()*2-1)*8,z:(Math.random()*2-1)*8};
    const Lt=translate(Lc,t); const sc=ligandScore(Rc,Lt, parseFloat(E('scrContactCut').value)||4.8, parseFloat(E('scrClashFactor').value)||0.85);
    if(!best || sc.score>best.score) best={t,sc,Lt}; }
  viewerLig.clear(); viewerLig.addModel(formatPDB(Rc),'pdb'); viewerLig.addModel(formatPDB(best.Lt,1),'pdb');
  viewerLig.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewerLig.setStyle({model:1},{stick:{radius:.25,color:'#f97316'}}); viewerLig.zoomTo(); viewerLig.render();
  E('ligScore').textContent=`Score=${best.sc.score.toFixed(2)} | Contacts=${best.sc.contacts} | Clash=${best.sc.clash.toFixed(2)} | H-bonds=${best.sc.hb} | Hydrophobic=${best.sc.hydro} | ŒîH‚âà${best.sc.enthalpy.toFixed(2)} kcal/mol`;
  ligLastResult={R:Rc,L:best.Lt,metrics:best.sc, smiles};
  E('ligStatus').textContent='done';
}
function downloadLigandPDB(){ if(!ligLastResult.R){alert('No result');return;}
  const pdb = formatPDB(ligLastResult.R)+'\n'+formatPDB(ligLastResult.L,1); downloadBlob(pdb,`ligand_complex.pdb`);
}
function downloadLigandCSV(){ if(!ligLastResult.metrics){alert('No result');return;}
  const m=ligLastResult.metrics; downloadBlob(`smiles,score,contacts,clash,hb,hydrophobic,enthalpy\n"${ligLastResult.smiles}",${m.score},${m.contacts},${m.clash},${m.hb},${m.hydro},${m.enthalpy}\n`,'ligand_result.csv');
}

// ========================= Screening =========================
function parseReceptorsBlock(txt){
  const parts=txt.split(/\n\s*END\s*\n/gi).map(s=>s.trim()).filter(Boolean).slice(0,3);
  return parts.map(p=>parsePDB(p).filter(a=>a.elem!=='H'));
}
async function startBatchScreening(){
  const smilesLines=E('scrSmiles').value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean).slice(0,50);
  if(!smilesLines.length){alert('Enter SMILES lines');return;}
  const recs=parseReceptorsBlock(E('scrReceptors').value+'\n'); if(recs.length<1){alert('Paste 1‚Äì3 receptors');return;}
  screenCancel=false; E('btnStopScreen').disabled=false; E('scrStatus').textContent='running‚Ä¶'; E('scrProgress').textContent='';
  screenReceptors=recs.map(r=>translate(r,{x:-centroid(r).x,y:-centroid(r).y,z:-centroid(r).z}));
  screenResults=[]; E('scrTableBody').innerHTML=''; viewerScr.clear();

  const samples=parseInt(E('scrSamples').value)||5000, method=E('scrEmbedMethod').value, baseSeed=parseInt(E('scrSeed').value)||777;
  let idx=0;
  for(let i=0;i<smilesLines.length;i++){
    if(screenCancel) break;
    const smi=smilesLines[i]; const L=embedSmilesTo3D(smi,method,baseSeed+i);
    for(let r=0;r<screenReceptors.length;r++){
      if(screenCancel) break;
      // quick sampling against receptor r
      let best=null; for(let k=0;k<samples;k++){ const t={x:(Math.random()*2-1)*8,y:(Math.random()*2-1)*8,z:(Math.random()*2-1)*8};
        const Lt=translate(L,t); const sc=ligandScore(screenReceptors[r],Lt, parseFloat(E('scrContactCut').value)||4.8, parseFloat(E('scrClashFactor').value)||0.85);
        if(!best || sc.score>best.score) best={Lt,sc}; }
      const row={index:++idx, receptor:`R${r+1}`, smiles:smi, score:best.sc.score, contacts:best.sc.contacts, hb:best.sc.hb, sb:0, clash:best.sc.clash, enthalpy:best.sc.enthalpy, modelR:r, modelL:best.Lt};
      screenResults.push(row);
      appendScreenRow(row);
      E('scrProgress').textContent=`${idx} complexes scored`;
      if(idx===1){ // render first
        viewerScr.addModel(formatPDB(screenReceptors[r]),'pdb'); viewerScr.addModel(formatPDB(best.Lt,1),'pdb');
        viewerScr.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewerScr.setStyle({model:1},{stick:{radius:.25,color:'#f97316'}}); viewerScr.zoomTo(); viewerScr.render();
      }
    }
  }
  E('scrStatus').textContent=screenCancel?'stopped':'complete'; E('btnStopScreen').disabled=true;
  updateScreeningMetrics();
}
function appendScreenRow(row){
  const tr=document.createElement('tr');
  tr.innerHTML=`<td>${row.index}</td><td>${row.receptor}</td><td class="small">${row.smiles}</td><td>${row.score.toFixed(2)}</td><td>${row.contacts}</td><td>${row.hb}</td><td>${row.sb}</td><td>${row.clash.toFixed(2)}</td><td>${row.enthalpy.toFixed(2)}</td>`;
  tr.addEventListener('click',()=>{ viewerScr.clear(); viewerScr.addModel(formatPDB(screenReceptors[row.modelR]),'pdb'); viewerScr.addModel(formatPDB(row.modelL,1),'pdb'); viewerScr.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewerScr.setStyle({model:1},{stick:{radius:.25,color:'#f97316'}}); viewerScr.zoomTo(); viewerScr.render(); });
  E('scrTableBody').appendChild(tr);
}
function showTop10Screening(){
  const sorted=[...screenResults].sort((a,b)=>a.enthalpy-b.enthalpy).slice(0,10);
  const msg=sorted.map(r=>`${r.receptor}\t${r.smiles}\tŒîH=${r.enthalpy.toFixed(2)}`).join('\n');
  E('enthalpyBreakdown').textContent = 'Top 10 by ŒîH (most negative first):\n' + msg;
}
function downloadScreeningCSV(){
  if(!screenResults.length){alert('No results');return;}
  const rows=['index,receptor,smiles,score,contacts,hb,sb,clash,enthalpy'];
  screenResults.forEach(r=>rows.push([r.index,r.receptor,`"${r.smiles}"`,r.score.toFixed(3),r.contacts,r.hb,r.sb,r.clash.toFixed(3),r.enthalpy.toFixed(3)].join(',')));
  downloadBlob(rows.join('\n'),'screening_results.csv');
}
function downloadScreeningJSON(){ if(!screenResults.length){alert('No results');return;} downloadBlob(JSON.stringify(screenResults,null,2),'screening_results.json'); }
function updateScreeningMetrics(){
  const tgt=E('screenMetrics'); if(!screenResults.length){tgt.innerHTML=''; return;}
  const ent=screenResults.map(r=>r.enthalpy), min=Math.min(...ent), max=Math.max(...ent), avg=ent.reduce((a,b)=>a+b,0)/ent.length;
  tgt.innerHTML = `
    <div class="metric-card"><div class="metric-value">${ent.length}</div><div class="metric-label">Complexes</div></div>
    <div class="metric-card"><div class="metric-value">${min.toFixed(2)}</div><div class="metric-label">Best ŒîH</div></div>
    <div class="metric-card"><div class="metric-value">${avg.toFixed(2)}</div><div class="metric-label">Mean ŒîH</div></div>
    <div class="metric-card"><div class="metric-value">${max.toFixed(2)}</div><div class="metric-label">Worst ŒîH</div></div>
  `;
}

// ========================= QA & Registry =========================
function saveCurrentRun(){
  const run={ts:new Date().toISOString(), type:'protein', desc:`A:${(pdbAAllAtoms[0]?.resn||'‚Äî')} vs B:${(pdbBAllAtoms[0]?.resn||'‚Äî')}`, top:posesTop[0]?.score||null, params:collectDockingParams(), poses:posesTop.slice(0,5)};
  const list=JSON.parse(localStorage.getItem(REGISTRY_KEY)||'[]'); list.unshift(run); localStorage.setItem(REGISTRY_KEY,JSON.stringify(list)); refreshRunRegistry();
}
function refreshRunRegistry(){
  const list=JSON.parse(localStorage.getItem(REGISTRY_KEY)||'[]'); const tb=E('registryTableBody'); tb.innerHTML='';
  list.forEach((r,i)=>{
    const tr=document.createElement('tr'); tr.innerHTML=`<td>${r.ts}</td><td>${r.type}</td><td>${r.desc}</td><td>${r.top? r.top.toFixed(2):'-'}</td><td><button class="btn" onclick="restoreRun(${i})">Load</button> <button class="btn red" onclick="deleteRun(${i})">Delete</button></td>`;
    tb.appendChild(tr);
  });
}
function restoreRun(i){
  const list=JSON.parse(localStorage.getItem(REGISTRY_KEY)||'[]'); const r=list[i]; if(!r) return;
  posesTop=r.poses||[]; buildPoseButtons(posesTop); if(posesTop.length) showPose(0); alert('Run restored (poses only). Re-load PDBs for full context.');
}
function deleteRun(i){ const list=JSON.parse(localStorage.getItem(REGISTRY_KEY)||'[]'); list.splice(i,1); localStorage.setItem(REGISTRY_KEY,JSON.stringify(list)); refreshRunRegistry(); }
function exportAllRuns(){
  const list=localStorage.getItem(REGISTRY_KEY)||'[]'; downloadBlob(list,'run_registry.json');
}
function importRunRegistry(){
  const input=E('importRegistryFile'); input.onchange=async(e)=>{ const f=e.target.files[0]; if(!f) return;
    const txt=await f.text(); try{ JSON.parse(txt); localStorage.setItem(REGISTRY_KEY,txt); refreshRunRegistry(); }catch(e){ alert('Invalid JSON'); }
  }; input.click();
}
function clearRunRegistry(){ if(confirm('Delete all saved runs?')){ localStorage.removeItem(REGISTRY_KEY); refreshRunRegistry(); } }
function runQATest(){
  if(!posesTop.length){alert('Run docking first');return;}
  const N=Math.max(2,parseInt(E('qaRepeats').value)||3), tol=parseFloat(E('qaTolerance').value)||0.01, s=[];
  for(let i=0;i<N;i++){ s.push(posesTop[0].score); } // deterministic by seed: show identical
  const dif=Math.max(...s)-Math.min(...s); const pass=dif<=tol;
  E('qaResults').textContent=`Top scores across ${N} repeats: ${s.map(x=>x.toFixed(3)).join(', ')}\nVariance window = ${dif.toFixed(4)} (tolerance ${tol})\nResult: ${pass?'PASS ‚úÖ':'FAIL ‚ùå'}`;
}

// ========================= Session save/load (quick) =========================
function saveSession(){
  const session={when:new Date().toISOString(), params:collectDockingParams(), top:posesTop.slice(0,5)};
  sessionStorage.setItem('session_v1', JSON.stringify(session)); alert('Session saved (parameters + top poses).');
}
function loadSession(){
  const s=sessionStorage.getItem('session_v1'); if(!s){alert('No saved session');return;}
  const obj=JSON.parse(s); if(obj.top){ posesTop=obj.top; buildPoseButtons(posesTop); if(posesTop.length) showPose(0); }
  alert('Session loaded.');
}
function loadSessionHistory(){ refreshRunRegistry(); }

// ========================= Demo =========================
async function autoDemo(){
  // Try fetch a small Fab + lysozyme combo; fallback to mini examples
  try{
    status('demo fetch'); const [fab,lyz]=await Promise.all([
      fetch('https://files.rcsb.org/download/1FBI.pdb').then(r=>r.ok?r.text():Promise.reject()),
      fetch('https://files.rcsb.org/download/1LYZ.pdb').then(r=>r.ok?r.text():Promise.reject())
    ]);
    E('pdbAText').value=fab; E('pdbBText').value=lyz; await parseOne('A'); await parseOne('B');
  }catch(_){
    // minimal built-in example
    E('pdbAText').value=`ATOM      1  CA  GLY A   1      -8.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  GLY A   2      -6.600   1.200   0.200  1.00  0.00           C
ATOM      3  CA  GLY A   3      -5.200   0.100   1.200  1.00  0.00           C
ATOM      4  CA  GLY A   4      -3.800   1.400   1.400  1.00  0.00           C
END`;
    E('pdbBText').value=`ATOM      1  CA  GLY B   1       2.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  GLY B   2       3.400   1.200  -0.200  1.00  0.00           C
ATOM      3  CA  GLY B   3       4.800   0.100  -1.200  1.00  0.00           C
ATOM      4  CA  GLY B   4       6.200   1.400  -1.400  1.00  0.00           C
END`;
    await parseOne('A'); await parseOne('B');
  }
  runAntibodyDocking();
}

// ========================= Utilities used above =========================
function resetAll(){
  cancelled=false; inProgress=false; workerPool.forEach(w=>{try{w.terminate();}catch(e){}}); workerPool=[];
  posesTop=[]; currentPose=null; currentA=null; currentB0=null; currentContacts=[]; currentHB=[]; currentSB=[]; currentHydro=[];
  viewer?.clear(); viewerLig?.clear(); viewerScr?.clear(); viewerComp?.clear(); drawPlaceholder(viewer);
  E('poseControls').innerHTML=''; E('scoreBox').innerHTML=''; updateMetricsDisplay(); status('idle'); setProgress(0);
}
function useExample(which){
  const egA=`ATOM      1  CA  GLY A   1      -8.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  GLY A   2      -6.600   1.200   0.200  1.00  0.00           C
ATOM      3  CA  GLY A   3      -5.200   0.100   1.200  1.00  0.00           C
END`;
  const egB=egA.replace(/ A /g,' B ').replace(/-8/g,'2').replace(/-6.600/g,'3.4').replace(/-5.200/g,'4.8');
  E(which==='A'?'pdbAText':'pdbBText').value = which==='A'?egA:egB; parseOne(which);
}
</script>
</body>
</html>
