<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Antibody‚ÄìAntigen Docking ‚Ä¢ In‚ÄëBrowser 3D ‚Ä¢ Reproducible Exports</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0f172a" />
<meta name="description" content="Client‚Äëside antibody‚Äìantigen docking with a worker pool, live 3D viewer, contact analytics, reproducible exports, and an auto‚Äëdemo that shows docking immediately." />
<style>
  :root{
    --bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--line:#1f2937;--green:#34d399;--red:#f87171;--yellow:#fbbf24;--orange:#f97316;
    --mono: ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;
    --sans: Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans);line-height:1.6}
  a{color:var(--accent);text-decoration:none}
  header{padding:34px 16px;background:
    radial-gradient(1200px 600px at 15% -10%,#1d2a4a,transparent 60%),
    radial-gradient(1000px 500px at 120% 10%,#2a1e4a,transparent 60%)}
  .wrap{max-width:1200px;margin:0 auto}
  h1{margin:0 0 8px;font-size:30px}
  p.lead{color:var(--muted);margin:6px 0 0}
  section{padding:22px 16px;border-top:1px solid var(--line);background:var(--panel)}
  h2{margin:0 0 10px;font-size:22px}
  h3{margin:14px 0 6px;font-size:17px}
  .grid{display:grid;gap:16px}
  @media(min-width:980px){.grid{grid-template-columns:1.05fr .95fr}}
  .card{background:#0b1220;border:1px solid var(--line);border-radius:14px;padding:14px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{font-weight:600}
  input[type="number"], input[type="text"], textarea, select{
    background:#0a0f1a;color:var(--text);border:1px solid #1f2937;border-radius:8px;
    padding:8px 10px;font-family:var(--mono);font-size:13px;min-width:80px
  }
  textarea{width:100%;min-height:110px}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:9px 12px;border-radius:10px;font-weight:600;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:13px}
  .btn.primary{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0}
  .btn.green{background:linear-gradient(180deg,#059669,#047857);border:0}
  .btn.red{background:linear-gradient(180deg,#dc2626,#b91c1c);border:0}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .muted{color:var(--muted)}
  .small{font-size:12px;color:var(--muted)}
  .pill{padding:2px 8px;border:1px solid #334155;border-radius:999px;font-size:12px;color:#93c5fd}
  progress{width:260px;height:10px;border:1px solid #1f2937;border-radius:999px;background:#0b1220}
  progress::-webkit-progress-bar{background:#0b1220;border-radius:999px}
  progress::-webkit-progress-value{background:#60a5fa;border-radius:999px}
  #viewer{position:relative;width:100%;height:560px;border:1px solid var(--line);border-radius:10px;background:#0a0f1a;overflow:hidden}
  .score{font-family:var(--mono);background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:8px;overflow:auto;font-size:12px}
  .infobox{border:1px solid #334155;border-left:4px solid var(--accent);border-radius:10px;padding:10px;background:#0a0f1a;color:#cbd5e1;margin:10px 0}
  .errorbox{border:1px solid #7f1d1d;border-left:4px solid #dc2626;border-radius:10px;padding:10px;background:#1a0c0c;color:#fecaca;margin:10px 0}
  .chainchips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{border:1px solid #334155;border-radius:999px;padding:2px 8px;display:inline-flex;align-items:center;gap:6px}
  .chip input{accent-color:#60a5fa}
  footer{padding:18px 16px;color:var(--muted);text-align:center}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>In‚ÄëBrowser Antibody‚ÄìAntigen Docking</h1>
    <p class="lead">Parallel sampling with web workers ‚Ä¢ vdW‚Äëaware scoring ‚Ä¢ duplicate filtering ‚Ä¢ interface analytics ‚Ä¢ reproducible exports ‚Ä¢ <b>auto‚Äëdemo shows 3D immediately</b></p>
    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnDemo">üéØ Load Demo & Dock</button>
      <span class="pill" id="statusPill">idle</span>
      <progress id="prog" value="0" max="1"></progress>
    </div>
  </div>
</header>

<section>
  <div class="wrap grid">
    <div class="card">
      <h2>1) Load Proteins</h2>
      <div class="row small muted">Use files or paste PDB text. After parsing, select chains from chips below.
        <span class="pill">Tip: the demo auto‚Äëfills valid PDBs and runs docking.</span>
      </div>
      <div class="row" style="margin-top:6px">
        <div style="min-width:300px;flex:1">
          <h3>Protein A (Antibody)</h3>
          <div class="row"><input type="file" id="pdbAFile" accept=".pdb,.ent,.txt,.pdb.gz" /><button class="btn" onclick="useExample('A')">Example A</button></div>
          <textarea id="pdbAText" placeholder="Paste PDB text for Protein A"></textarea>
          <div class="row"><label>Chains</label><div id="chainsABox" class="chainchips"></div></div>
          <div id="chainWarnA" class="infobox small">Parse first to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('A')">üîé Parse A</button><button class="btn" onclick="selectAllChains('A')">All</button></div>
        </div>
        <div style="min-width:300px;flex:1">
          <h3>Protein B (Antigen)</h3>
          <div class="row"><input type="file" id="pdbBFile" accept=".pdb,.ent,.txt,.pdb.gz" /><button class="btn" onclick="useExample('B')">Example B</button></div>
          <textarea id="pdbBText" placeholder="Paste PDB text for Protein B"></textarea>
          <div class="row"><label>Chains</label><div id="chainsBBox" class="chainchips"></div></div>
          <div id="chainWarnB" class="infobox small">Parse first to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('B')">üîé Parse B</button><button class="btn" onclick="selectAllChains('B')">All</button></div>
        </div>
      </div>

      <details style="margin-top:8px"><summary><b>Accepted formats & hints</b></summary>
        <ul class="small">
          <li>Accepts PDB (also <code>.pdb.gz</code>). If your structure has few atoms, viewer falls back to sticks for visibility.</li>
          <li>If you see ‚ÄúNo atoms after chain filtering‚Äù, click <b>Parse</b> then use the chain chips (or hit <b>All</b>).</li>
          <li>Cartoons require backbone; sticks/spheres always render.</li>
        </ul>
      </details>
    </div>

    <div class="card">
      <h2>2) Docking Parameters</h2>
      <div class="row">
        <label>Samples</label><input type="number" id="samples" value="8000" min="500" step="500" />
        <label>Max Œî (√Ö)</label><input type="number" id="maxTrans" value="12" min="0" step="1" />
        <label>Atom set</label>
        <select id="atomMode">
          <option value="CA">CŒ± (fast)</option>
          <option value="BB">Backbone</option>
          <option value="HEAVY">All heavy (slow)</option>
        </select>
      </div>
      <div class="row">
        <label>Contact cutoff (√Ö)</label><input type="number" id="contactCut" value="4.8" step="0.1" />
        <label>Clash factor</label><input type="number" id="clashFactor" value="0.85" step="0.05" />
        <label>Contact wt</label><input type="number" id="wContact" value="1.0" step="0.1" />
        <label>Clash pen</label><input type="number" id="wClash" value="6.0" step="0.1" />
        <label>Soft</label><input type="number" id="soft" value="0.5" step="0.1" />
      </div>
      <div class="row">
        <label>Top poses</label><input type="number" id="topN" value="10" min="1" max="50" />
        <label>Rescore</label>
        <select id="rescoreMode">
          <option value="NONE">Skip</option>
          <option value="HEAVY">Heavy atoms</option>
          <option value="HEAVY_REFINE">Heavy + micro‚Äërefine</option>
        </select>
        <label>Seed</label><input type="number" id="seed" value="42" />
      </div>
      <div class="row">
        <label>Diversity (¬∞/√Ö)</label>
        <input type="number" id="dupAngle" value="12" step="1" title="Max rotation angle difference (degrees)" />
        <input type="number" id="dupTrans" value="2" step="0.5" title="Max translation difference (√Ö)" />
        <span class="small">Filters near‚Äëduplicates for diverse poses</span>
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn primary" id="dockBtn">‚ñ∂Ô∏è Run Docking</button>
        <button class="btn red" id="cancelBtn" disabled>‚úñ Cancel</button>
        <button class="btn" id="resetBtn">Reset</button>
      </div>
      <div class="small muted" style="margin-top:6px">Score = contacts ‚àí vdW‚Äëaware clash penalty. Use heavy re‚Äëscore for better ranking.</div>
    </div>
  </div>
</section>

<section>
  <div class="wrap grid">
    <div class="card">
      <h2>3) Results & 3D Viewer</h2>
      <div id="viewer"></div>
      <div class="row" style="margin-top:8px;flex-wrap:wrap" id="poseControls"></div>
      <div class="row" style="margin-top:8px">
        <label class="chip"><input type="checkbox" id="toggleContacts" checked> Contacts</label>
        <label class="chip"><input type="checkbox" id="toggleHB" checked> H‚Äëbonds</label>
        <label class="chip"><input type="checkbox" id="toggleSB" checked> Salt bridges</label>
      </div>
      <div class="score" id="scoreBox" style="margin-top:8px"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnAllPDB">‚¨á Multi‚Äëmodel PDB (top N)</button>
        <button class="btn" id="btnCSV">‚¨á Summary CSV</button>
        <button class="btn" id="btnJSON">‚¨á Interface JSON</button>
        <button class="btn" id="btnPNG">üì∏ PNG Snapshot</button>
      </div>
    </div>
    <div class="card">
      <h2>Interface Metrics</h2>
      <ul class="small">
        <li><b>Contacts</b>: atom pairs within cutoff.</li>
        <li><b>H‚Äëbonds</b>: N‚Ä¶O < 3.5 √Ö (geometric proxy).</li>
        <li><b>Salt bridges</b>: (Asp/Glu O*)‚Äì(Lys/Arg/His N*) < 4.0 √Ö.</li>
        <li><b>Hydrophobics</b>: C‚Ä¶C < 4.5 √Ö between hydrophobic residues.</li>
        <li><b>Electrostatics</b>: residue‚Äëlevel Coulomb (q ‚àà {‚àí1,0,+1,+0.1(HIS)}), within 12 √Ö.</li>
      </ul>
      <div class="row">
        <label>k<sub>elec</sub></label><input type="number" id="kElec" value="0.5" step="0.1" />
        <label>Elec cutoff (√Ö)</label><input type="number" id="elecCut" value="12" step="0.5" />
      </div>
      <div class="infobox small"><b>Reproducibility</b>: CSV/JSON include parameters & seed. Use the same inputs to reproduce rankings exactly.</div>
      <div class="infobox small"><b>Disclaimer</b>: Educational research tool; no warranties; you agree we disclaim any loss in any way from use of these outputs.</div>
    </div>
  </div>
</section>

<footer>
  <div class="wrap">All computations execute locally in your browser. ¬© You.</div>
</footer>

<!-- Libraries (load 3Dmol first). Using defer to ensure DOM is ready. -->
<script defer src="https://unpkg.com/3dmol@2.4.2/build/3Dmol-min.js"></script>
<script defer src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

<script>
// ========================= State & DOM refs =========================
let viewer=null; let inProgress=false; let cancelled=false; let workerPool=[];
let pdbAAtoms=[], pdbBAtoms=[], pdbAAllAtoms=[], pdbBAllAtoms=[];
let posesTop=[], currentPose=null, currentA=null, currentB0=null, heavyUsed=false;
let currentContacts=[], currentHB=[], currentSB=[];
const vdw = {H:1.2, C:1.7, N:1.55, O:1.52, S:1.8, P:1.8, F:1.47, CL:1.75, BR:1.85, I:1.98};
const hydrophobic = new Set(['ALA','VAL','LEU','ILE','PRO','PHE','MET','TRP','TYR','CYS']);

// UI helpers
const E = id => document.getElementById(id);
const status = s => { E('statusPill').textContent = s; };
const setProgress = f => { E('prog').value = Math.max(0, Math.min(1, f||0)); };

// ========================= Boot =========================
window.addEventListener('DOMContentLoaded', () => {
  // Create viewer and draw a visible placeholder immediately.
  ensureViewer();
  drawPlaceholder();
  // Wire buttons
  E('dockBtn').addEventListener('click', runDocking);
  E('cancelBtn').addEventListener('click', cancelDocking);
  E('resetBtn').addEventListener('click', resetAll);
  E('btnAllPDB').addEventListener('click', downloadAllPoses);
  E('btnCSV').addEventListener('click', downloadCSV);
  E('btnJSON').addEventListener('click', downloadJSON);
  E('btnPNG').addEventListener('click', snapshotPNG);
  E('toggleContacts').addEventListener('change', refreshOverlays);
  E('toggleHB').addEventListener('change', refreshOverlays);
  E('toggleSB').addEventListener('change', refreshOverlays);
  E('btnDemo').addEventListener('click', autoDemo);
  // Auto‚Äëdemo on first load to guarantee a visible 3D docking.
  autoDemo();
});

function ensureViewer(){
  if (viewer) return;
  const el = E('viewer');
  viewer = $3Dmol.createViewer(el, {backgroundColor:'#0a0f1a'});
  // Give layout a tick before first render
  requestAnimationFrame(()=>{ viewer.resize(); viewer.render(); });
}

function drawPlaceholder(){
  // Draw two spheres so the user always sees something 3D on load.
  viewer.addSphere({center:{x:-8,y:0,z:0}, radius:4, color:'#60a5fa', alpha:0.6});
  viewer.addSphere({center:{x: 8,y:0,z:0}, radius:4, color:'#f97316', alpha:0.6});
  viewer.zoomTo(); viewer.render();
}

// ========================= PDB parse & chain UI =========================
async function fileToText(file){
  const name = file.name.toLowerCase();
  const buf = await file.arrayBuffer();
  if (name.endsWith('.gz')){ const u8 = new Uint8Array(buf); const out = pako.inflate(u8); return new TextDecoder().decode(out); }
  return new TextDecoder().decode(buf);
}
function parsePDB(text){
  const atoms=[]; const lines=text.split(/\r?\n/);
  for (const ln of lines){
    if (ln.startsWith('ATOM') || ln.startsWith('HETATM')){
      const name=ln.substring(12,16).trim();
      const resn=ln.substring(17,20).trim();
      const chain=(ln.substring(21,22).trim()||'A');
      const resi=parseInt(ln.substring(22,26));
      const x=parseFloat(ln.substring(30,38));
      const y=parseFloat(ln.substring(38,46));
      const z=parseFloat(ln.substring(46,54));
      const elem= ln.length>=78 ? (ln.substring(76,78).trim() || name[0]) : name[0];
      atoms.push({name,resn,chain,resi,x,y,z,elem});
    }
  }
  return atoms;
}
function populateChainChips(which, atoms){
  const box = which==='A'?E('chainsABox'):E('chainsBBox');
  box.innerHTML='';
  const chains=[...new Set(atoms.map(a=>a.chain))];
  chains.forEach(ch=>{
    const id=`${which}_ch_${ch}`;
    const span=document.createElement('label'); span.className='chip';
    span.innerHTML=`<input type="checkbox" id="${id}" data-which="${which}" data-chain="${ch}" checked> ${ch}`;
    box.appendChild(span);
    span.querySelector('input').addEventListener('change', ()=>{});
  });
  (which==='A'?E('chainWarnA'):E('chainWarnB')).textContent = `Parsed ${atoms.length} atoms ‚Ä¢ Chains: ${chains.join(', ')||'‚Äî'}`;
}
function selectedChains(which){
  const box = which==='A'?E('chainsABox'):E('chainsBBox');
  const ticks=[...box.querySelectorAll('input[type=checkbox]')].filter(c=>c.checked).map(c=>c.dataset.chain);
  return new Set(ticks);
}
function selectAllChains(which){
  const box = which==='A'?E('chainsABox'):E('chainsBBox');
  box.querySelectorAll('input[type=checkbox]').forEach(c=>c.checked=true);
}
async function parseOne(which){
  const file = E(which==='A'?'pdbAFile':'pdbBFile').files[0];
  let text = E(which==='A'?'pdbAText':'pdbBText').value.trim();
  if (!text && file) text = await fileToText(file);
  if (!text) { alert('Provide PDB text or file first.'); return; }
  const atoms = parsePDB(text);
  if (!atoms.length){ alert('No atoms parsed ‚Äî is this a valid PDB?'); return; }
  if (which==='A'){ pdbAAllAtoms=atoms; populateChainChips('A', atoms);} else { pdbBAllAtoms=atoms; populateChainChips('B', atoms);} 
}

// ========================= Atom selection & transforms =========================
function filterChains(atoms, keep){ if (!keep||keep.size===0) return atoms; return atoms.filter(a=>keep.has(a.chain)); }
function selectAtomSet(atoms, mode){ const bb=new Set(['N','CA','C','O']); return atoms.filter(a=> mode==='CA'?a.name==='CA' : mode==='BB'? bb.has(a.name) : a.elem!=='H'); }
function centroid(points){ let sx=0,sy=0,sz=0,n=points.length; for (const p of points){sx+=p.x;sy+=p.y;sz+=p.z} return {x:sx/n,y:sy/n,z:sz/n}; }
function translate(points,v){ return points.map(p=>({...p,x:p.x+v.x,y:p.y+v.y,z:p.z+v.z})); }
function applyTransform(points,q,t){ const [x,y,z,w]=q; return points.map(p=>{ const vx=p.x,vy=p.y,vz=p.z; const ix=w*vx + y*vz - z*vy; const iy=w*vy + z*vx - x*vz; const iz=w*vz + x*vy - y*vx; const iw=-x*vx - y*vy - z*vz; const ox=ix*w + iw*(-x) + iy*(-z) - iz*(-y); const oy=iy*w + iw*(-y) + iz*(-x) - ix*(-z); const oz=iz*w + iw*(-z) + ix*(-y) - iy*(-x); return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name}; }); }
function formatPDB(atoms, chainShift=0){ let lines=[]; let serial=1; for (const a of atoms){ const name=(a.name||'CA').padStart(4,' '); const resn=(a.resn||'RES').padStart(3,' '); const chain=(a.chain||'A'); const chainOut=String.fromCharCode(chain.charCodeAt(0)+chainShift); const resi=(a.resi||1).toString().padStart(4,' '); const x=(a.x??0).toFixed(3).padStart(8,' '); const y=(a.y??0).toFixed(3).padStart(8,' '); const z=(a.z??0).toFixed(3).padStart(8,' '); const occ=' 1.00'; const b=' 0.00'; const elem=(a.elem||'C').toString().padStart(2,' '); lines.push(`ATOM  ${String(serial).padStart(5,' ')} ${name} ${resn} ${chainOut}${resi}    ${x}${y}${z}${occ}${b}          ${elem}`); serial++; } lines.push('TER','ENDMDL','END'); return lines.join('\n'); }

// ========================= Sampling worker =========================
function makeDockWorker(){
  const src = `
    const vdw = {H:1.2, C:1.7, N:1.55, O:1.52, S:1.8, P:1.8, F:1.47, CL:1.75, BR:1.85, I:1.98};
    function rand(seed){ let s = seed>>>0; return ()=> (s = (1664525*s + 1013904223)>>>0, (s/0xFFFFFFFF)); }
    function randomQuat(rng){ const u1=rng(), u2=rng(), u3=rng(); const a=Math.sqrt(1-u1), b=Math.sqrt(u1), t1=2*Math.PI*u2, t2=2*Math.PI*u3; return [a*Math.sin(t1), a*Math.cos(t1), b*Math.sin(t2), b*Math.cos(t2)]; }
    function rotatePoints(pts, q){ const [x,y,z,w]=q; return pts.map(p=>{ const vx=p.x, vy=p.y, vz=p.z; const ix =  w*vx + y*vz - z*vy; const iy =  w*vy + z*vx - x*vz; const iz =  w*vz + x*vy - y*vx; const iw = -x*vx - y*vy - z*vz; const ox = ix*w + iw*(-x) + iy*(-z) - iz*(-y); const oy = iy*w + iw*(-y) + iz*(-x) - ix*(-z); const oz = iz*w + iw*(-z) + ix*(-y) - iy*(-x); return {x:ox,y:oy,z:oz,elem:p.elem}; }); }
    function translate(pts,t){ return pts.map(p=>({x:p.x+t.x,y:p.y+t.y,z:p.z+t.z,elem:p.elem})); }
    function makeGrid(coords, cell){ const map=new Map(); const key=(ix,iy,iz)=>ix+"|"+iy+"|"+iz; for(let i=0;i<coords.length;i++){ const x=coords[i].x,y=coords[i].y,z=coords[i].z; const ix=Math.floor(x/cell), iy=Math.floor(y/cell), iz=Math.floor(z/cell); const k=key(ix,iy,iz); if(!map.has(k)) map.set(k, []); map.get(k).push(i);} return {cell,map}; }
    function neighbors(g,x,y,z){ const c=g.cell; const ix=Math.floor(x/c), iy=Math.floor(y/c), iz=Math.floor(z/c); const res=[]; for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++) for(let dz=-1;dz<=1;dz++){ const k=(ix+dx)+"|"+(iy+dy)+"|"+(iz+dz); if(g.map.has(k)) res.push(...g.map.get(k)); } return res; }
    function scorePose(A,B,contactCut,clashFactor,wContact,wClash,soft){ const grid=makeGrid(A,contactCut); let contacts=0, clashPenalty=0; for(let i=0;i<B.length;i++){ const x=B[i].x,y=B[i].y,z=B[i].z; const elemB=(B[i].elem||'C').toUpperCase(); const cand=neighbors(grid,x,y,z); for(const j of cand){ const ax=A[j].x,ay=A[j].y,az=A[j].z; const elemA=(A[j].elem||'C').toUpperCase(); const dx=x-ax, dy=y-ay, dz=z-az; const d=Math.hypot(dx,dy,dz); const rv=(vdw[elemA]||1.7)+(vdw[elemB]||1.7); const clashCut=clashFactor*rv; if (d<=clashCut){ const over=(clashCut-d+1e-6)/clashCut; clashPenalty += wClash * over * (1/(1+soft*over)); } else if (d<=contactCut){ contacts += 1.0; } } } return {score: contacts - clashPenalty, contacts, clash: clashPenalty}; }
    self.onmessage = (e)=>{
      const {Apts,Bpts,params,start,end} = e.data; const rng=rand(params.seed + start*1337); let best=[]; const total=end-start; for(let k=0;k<total;k++){ const q=randomQuat(rng); const tx=(rng()*2-1)*params.maxTrans, ty=(rng()*2-1)*params.maxTrans, tz=(rng()*2-1)*params.maxTrans; const Bt=translate(rotatePoints(Bpts,q),{x:tx,y:ty,z:tz}); const sc=scorePose(Apts,Bt,params.contactCut,params.clashFactor,params.wContact,params.wClash,params.soft); best.push({score:sc.score,contacts:sc.contacts,clash:sc.clash,q:[...q],t:{x:tx,y:ty,z:tz}}); if ((k&1023)===0) self.postMessage({type:'progress',k}); }
      best.sort((a,b)=>b.score-a.score); self.postMessage({type:'done', list: best.slice(0, Math.min(200,total))});
    }`;
  const blob = new Blob([src], {type:'application/javascript'});
  return new Worker(URL.createObjectURL(blob));
}

function angleBetweenQuats(q1,q2){ const dot=q1[0]*q2[0]+q1[1]*q2[1]+q1[2]*q2[2]+q1[3]*q2[3]; return 2*Math.acos(Math.min(1,Math.abs(dot))) * 180/Math.PI; }
function diverseTop(sorted, angDeg, transA){ const out=[]; for (const p of sorted){ let dup=false; for (const q of out){ const ad=angleBetweenQuats(p.q,q.q); const td=Math.hypot(p.t.x-q.t.x,p.t.y-q.t.y,p.t.z-q.t.z); if (ad<=angDeg && td<=transA){ dup=true; break; } } if (!dup) out.push(p); if (out.length>=parseInt(E('topN').value)) break; } return out; }

// ========================= Docking driver =========================
async function runDocking(){
  if (inProgress) return; cancelled=false; inProgress=true; status('loading'); setProgress(0);
  E('dockBtn').disabled=true; E('cancelBtn').disabled=false; E('dockBtn').textContent='Running‚Ä¶';
  try{
    // Load inputs
    const Atext = await ensureInputText('A');
    const Btext = await ensureInputText('B');
    pdbAAllAtoms = parsePDB(Atext); pdbBAllAtoms = parsePDB(Btext);
    if (!pdbAAllAtoms.length || !pdbBAllAtoms.length) throw new Error('Could not parse atoms from one or both inputs.');
    populateChainChips('A', pdbAAllAtoms); populateChainChips('B', pdbBAllAtoms);

    const params = collectParams();
    // Chain filtering & atom subset
    const AchainSel = selectedChains('A'); const BchainSel = selectedChains('B');
    const _pdbAAtoms = filterChains(pdbAAllAtoms, AchainSel); const _pdbBAtoms = filterChains(pdbBAllAtoms, BchainSel);
    if (!_pdbAAtoms.length || !_pdbBAtoms.length) throw new Error('No atoms after chain filtering ‚Äî click All or select valid chains.');
    const Apts0 = selectAtomSet(_pdbAAtoms, params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
    const Bpts0 = selectAtomSet(_pdbBAtoms, params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
    if (!Apts0.length || !Bpts0.length) throw new Error('Atom selection produced empty sets; try Backbone or Heavy.');
    const cA=centroid(Apts0), cB=centroid(Bpts0);
    const Apts=translate(Apts0,{x:-cA.x,y:-cA.y,z:-cA.z});
    const Bpts=translate(Bpts0,{x:-cB.x,y:-cB.y,z:-cB.z});

    status('sampling');
    // Worker pool
    const cores=Math.max(1,(navigator.hardwareConcurrency||4)-1); const poolSize=Math.min(cores,8);
    const total=params.samples; const per=Math.floor(total/poolSize); const extra=total%poolSize;
    let lists=[]; let done=0; workerPool=[];
    for (let i=0;i<poolSize;i++){
      const start=i*per + Math.min(i,extra); const end=start + per + (i<extra?1:0);
      const w=makeDockWorker(); workerPool.push(w);
      w.onmessage=(e)=>{ if (cancelled) return; const msg=e.data; if (msg.type==='progress'){ done+=1024; setProgress(Math.min(1, done/params.samples)); status(`scan ${Math.min(done,params.samples)}/${params.samples}`); }
        if (msg.type==='done'){ lists.push(msg.list); w.terminate(); if (lists.length===poolSize){ finalizeSampling(lists.flat(), params, _pdbAAtoms, _pdbBAtoms, cA, cB); } }
      };
      w.onerror=(err)=>{ console.error(err); w.terminate(); };
      w.postMessage({Apts,Bpts,params,start,end});
    }
  }catch(err){
    alert(err.message||err);
    finishButtons(); status('error'); inProgress=false;
  }
}

function cancelDocking(){ cancelled=true; workerPool.forEach(w=>{try{w.terminate();}catch{}}); workerPool=[]; setProgress(0); status('cancelled'); finishButtons(); inProgress=false; }
function finishButtons(){ E('dockBtn').disabled=false; E('cancelBtn').disabled=true; E('dockBtn').textContent='‚ñ∂Ô∏è Run Docking'; }

function collectParams(){
  return { samples:parseInt(E('samples').value), maxTrans:parseFloat(E('maxTrans').value), contactCut:parseFloat(E('contactCut').value), clashFactor:parseFloat(E('clashFactor').value), wContact:parseFloat(E('wContact').value), wClash:parseFloat(E('wClash').value), soft:parseFloat(E('soft').value), topN:Math.max(1,parseInt(E('topN').value)), seed:parseInt(E('seed').value)||42, atomMode:E('atomMode').value, rescoreMode:E('rescoreMode').value };
}

async function ensureInputText(which){
  const file = E(which==='A'?'pdbAFile':'pdbBFile').files[0];
  let text = E(which==='A'?'pdbAText':'pdbBText').value.trim();
  if (!text && file) text = await fileToText(file);
  if (!text) throw new Error(`Provide PDB for Protein ${which} (file or pasted text).`);
  return text;
}

async function finalizeSampling(merged, params, _pdbAAtoms, _pdbBAtoms, cA, cB){
  if (cancelled) return cancelDocking(); status(params.rescoreMode==='NONE'?'ranking':(params.rescoreMode==='HEAVY'?'rescore':'refine'));
  merged.sort((a,b)=>b.score-a.score);
  const diverse = diverseTop(merged, parseFloat(E('dupAngle').value)||12, parseFloat(E('dupTrans').value)||2);

  // Heavy rescoring
  const Aheavy = translate(selectAtomSet(_pdbAAtoms,'HEAVY').map(a=>({...a})), {x:-cA.x,y:-cA.y,z:-cA.z});
  const Bheavy0 = translate(selectAtomSet(_pdbBAtoms,'HEAVY').map(a=>({...a})), {x:-cB.x,y:-cB.y,z:-cB.z});
  let top = diverse;
  if (params.rescoreMode!=='NONE'){ top = await heavyRescore(Aheavy, Bheavy0, params, diverse, params.rescoreMode==='HEAVY_REFINE'); heavyUsed=true; } else { heavyUsed=false; }
  posesTop = top; currentA=Aheavy; currentB0=Bheavy0;
  buildPoseButtons(top); if (top.length>0) showPose(0); finishButtons(); status('done'); setProgress(1); inProgress=false;
}

function heavyRescore(Aheavy, Bheavy0, params, topCoarse, refine=false){
  const contactCut=params.contactCut, clashFactor=params.clashFactor, wContact=params.wContact, wClash=params.wClash, soft=params.soft;
  function score(A,B){ let contacts=0, clashPenalty=0; for (const b of B){ for (const a of A){ const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z); const rv=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7); const clashCut=clashFactor*rv; if (d<=clashCut){ const over=(clashCut-d+1e-6)/clashCut; clashPenalty+=wClash*over*(1/(1+soft*over)); } else if (d<=contactCut){ contacts++; } } } return {score:contacts - clashPenalty, contacts, clash:clashPenalty}; }
  function jiggle(p){ const j=0.5; const r=()=> (Math.random()*2-1)*j; const dq=[p.q[0]+r()*0.01,p.q[1]+r()*0.01,p.q[2]+r()*0.01,p.q[3]+r()*0.01]; const n=Math.hypot(dq[0],dq[1],dq[2],dq[3]); for(let i=0;i<4;i++) dq[i]/=n; const dt={x:p.t.x+r(),y:p.t.y+r(),z:p.t.z+r()}; return {q:dq,t:dt}; }
  const rescored=[]; for (const p of topCoarse){ let best={...p}; let Bout=applyTransform(Bheavy0,p.q,p.t); let sc=score(Aheavy,Bout); best.score=sc.score; best.contacts=sc.contacts; best.clash=sc.clash; if (refine){ for (let i=0;i<40;i++){ const jt=jiggle(best); const Btry=applyTransform(Bheavy0,jt.q,jt.t); const sc2=score(Aheavy,Btry); if (sc2.score>best.score){ best.q=jt.q; best.t=jt.t; best.score=sc2.score; best.contacts=sc2.contacts; best.clash=sc2.clash; } } } rescored.push(best); }
  rescored.sort((a,b)=>b.score-a.score); return rescored.slice(0, parseInt(E('topN').value));
}

// ========================= Rendering & overlays =========================
function buildPoseButtons(top){ const pc=E('poseControls'); pc.innerHTML=''; top.forEach((p,i)=>{ const b=document.createElement('button'); b.className='btn'; b.textContent=`Pose ${i+1}  (S=${p.score.toFixed(1)}, C=${p.contacts|0}, X=${p.clash.toFixed(1)})`; b.addEventListener('click',()=>showPose(i)); pc.appendChild(b); const d=document.createElement('button'); d.className='btn green'; d.style.marginLeft='6px'; d.textContent='‚¨á PDB'; d.addEventListener('click',()=>downloadPose(i)); pc.appendChild(d); }); }

function showPose(i){ currentPose=posesTop[i]; const Bout=applyTransform(currentB0,currentPose.q,currentPose.t); viewer.clear();
  // Style strategy: cartoon if backbone exists and residue count is big; else sticks for visibility.
  const Ares = new Set(currentA.map(a=>a.resi)).size; const Bres = new Set(Bout.map(a=>a.resi)).size; const cartoonOK = (Ares>=8 && Bres>=8);
  viewer.addModel(formatPDB(currentA),'pdb'); viewer.addModel(formatPDB(Bout,1),'pdb');
  if (cartoonOK){ viewer.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewer.setStyle({model:1},{cartoon:{color:'#f97316'}}); }
  else { viewer.setStyle({model:0},{stick:{radius:0.25}}); viewer.setStyle({model:1},{stick:{radius:0.25,color:'#f97316'}}); }
  viewer.zoomTo();
  // Metrics & overlays
  const cut=parseFloat(E('contactCut').value); const m = computeInterfaceMetrics(currentA, Bout, cut); currentContacts=m.contactsPairs; currentHB=m.hbPairs; currentSB=m.sbPairs; refreshOverlays();
  const kElec=parseFloat(E('kElec').value)||0.5; const elecCut=parseFloat(E('elecCut').value)||12; const Eelec=coulombResidueEnergy(currentA,Bout,kElec,elecCut); const BSA = m.contacts*10.0; const enthalpyProxy = (m.contacts) - (m.clash) + (m.hb*0.5) + (m.sb*1.0) - (Eelec);
  E('scoreBox').textContent = `Pose ${i+1} ‚Äî Score=${currentPose.score.toFixed(2)}  Contacts=${m.contacts}  Clash=${m.clash.toFixed(2)}  HB=${m.hb}  SB=${m.sb}  Hydrophobics=${m.hydrophobics}  BSA‚âà${BSA.toFixed(0)} √Ö¬≤  Electrostatics‚âà${Eelec.toFixed(2)}  Pseudo‚Äëenthalpy‚âà${enthalpyProxy.toFixed(2)}`;
  viewer.render();
}
function refreshOverlays(){ if (!currentPose) return; viewer.removeAllShapes(); if (E('toggleContacts').checked) drawPairs(currentContacts,'#60a5fa'); if (E('toggleHB').checked) drawPairs(currentHB,'#34d399'); if (E('toggleSB').checked) drawPairs(currentSB,'#f87171'); viewer.render(); }
function drawPairs(pairs,color){ pairs.slice(0,400).forEach(pr=>{ viewer.addLine({start:{x:pr.x1,y:pr.y1,z:pr.z1}, end:{x:pr.x2,y:pr.y2,z:pr.z2}, dashed:true, dashLength:0.5, color, linewidth:2}); }); }

function computeInterfaceMetrics(A,B,contactCut){ let contacts=0, clash=0, hb=0, sb=0, hyd=0; const contactsPairs=[], hbPairs=[], sbPairs=[]; for (const b of B){ for (const a of A){ const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z); const rv=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7); const clashCut=parseFloat(E('clashFactor').value) * rv; if (d<=clashCut){ const over=(clashCut-d+1e-6)/clashCut; clash += 6.0*over*(1/(1+0.5*over)); } if (d<=contactCut){ contacts++; contactsPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
      const aN=a.name?.trim().startsWith('N'), bO=b.name?.trim().startsWith('O'); const aO=a.name?.trim().startsWith('O'), bN=b.name?.trim().startsWith('N'); if ((aN&&bO || aO&&bN) && d<=3.5){ hb++; hbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
      const acid=x=> (x.resn==='ASP'&&x.name.startsWith('OD')) || (x.resn==='GLU'&&x.name.startsWith('OE')); const base=x=> (x.resn==='LYS'&&x.name==='NZ') || (x.resn==='ARG'&&(x.name==='NH1'||x.name==='NH2'||x.name==='NE')) || (x.resn==='HIS'&&(x.name==='ND1'||x.name==='NE2'));
      if ((acid(a)&&base(b) || acid(b)&&base(a)) && d<=4.0){ sb++; sbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
      if (hydrophobic.has(a.resn) && hydrophobic.has(b.resn) && (a.elem==='C'||b.elem==='C') && d<=4.5) hyd++;
    } }
  return {contacts, clash, hb, sb, hydrophobics:hyd, contactsPairs, hbPairs, sbPairs}; }

function residueCharges(atoms){ const charges=new Map(); const qByResn={ASP:-1, GLU:-1, LYS:+1, ARG:+1, HIS:+0.1}; const pos=new Map(); for (const a of atoms){ const key=a.chain+':'+a.resi; if (!pos.has(key)) pos.set(key, []); pos.get(key).push(a);} for (const [key, arr] of pos.entries()){ const resn=arr[0].resn||'UNK'; const q=qByResn[resn]||0; if (q!==0){ let ca=arr.find(x=>x.name==='CA'); let x,y,z; if (ca){ x=ca.x;y=ca.y;z=ca.z;} else { let sx=0,sy=0,sz=0; for (const a of arr){sx+=a.x;sy+=a.y;sz+=a.z} x=sx/arr.length;y=sy/arr.length;z=sz/arr.length; } charges.set(key,{x,y,z,q,resn,chain:arr[0].chain,resi:arr[0].resi}); } } return Array.from(charges.values()); }
function coulombResidueEnergy(A,B,k=0.5,cut=12){ const cA=residueCharges(A), cB=residueCharges(B); let e=0, cut2=cut*cut; for (const a of cA){ for (const b of cB){ const dx=a.x-b.x, dy=a.y-b.y, dz=a.z-b.z; const d2=dx*dx+dy*dy+dz*dz; if (d2>cut2) continue; const d=Math.sqrt(d2)+1e-3; e += k*(a.q*b.q)/d; } } return e; }

// ========================= Exports =========================
function downloadPose(i){ const p=posesTop[i]; const Bout=applyTransform(currentB0,p.q,p.t); const pdbOut = formatPDB(currentA)+"\n"+formatPDB(Bout,1); downloadBlob(pdbOut, `pose_${i+1}.pdb`); }
function downloadAllPoses(){ if (!posesTop.length){ alert('No poses yet.'); return; } let out=[]; posesTop.forEach((p,i)=>{ out.push(`MODEL     ${i+1}`); out.push(formatPDB(currentA)); out.push(formatPDB(applyTransform(currentB0,p.q,p.t),1)); out.push('ENDMDL'); }); out.push('END'); downloadBlob(out.join('\n'),'top_poses.pdb'); }
function downloadCSV(){ if (!posesTop.length){ alert('No poses yet.'); return; } const rows=["rank,score,contacts,clash,qx,qy,qz,qw,tx,ty,tz"]; posesTop.forEach((p,i)=> rows.push([i+1,p.score,p.contacts,p.clash,p.q[0],p.q[1],p.q[2],p.q[3],p.t.x,p.t.y,p.t.z].join(','))); downloadBlob(rows.join('\n'),'poses_summary.csv'); }
function downloadJSON(){ if (!posesTop.length){ alert('No poses yet.'); return; } const kElec=parseFloat(E('kElec').value)||0.5; const elecCut=parseFloat(E('elecCut').value)||12; const cut=parseFloat(E('contactCut').value); const report=posesTop.map((p,i)=>{ const Bout=applyTransform(currentB0,p.q,p.t); const m=computeInterfaceMetrics(currentA,Bout,cut); return { rank:i+1, score:p.score, contacts:m.contacts, clash:m.clash, hb:m.hb, sb:m.sb, hydrophobic:m.hydrophobics, BSA_proxy_A2: m.contacts*10.0, electrostatics: coulombResidueEnergy(currentA,Bout,kElec,elecCut), transform:{q:p.q,t:p.t} };}); downloadBlob(JSON.stringify(report,null,2),'interface_report.json'); }
function snapshotPNG(){ viewer.pngURI(uri=>{ const a=document.createElement('a'); a.href=uri; a.download='viewer.png'; a.click(); }); }
function downloadBlob(text,name){ const blob=new Blob([text],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.click(); setTimeout(()=>URL.revokeObjectURL(url),0); }

function resetAll(){ ['pdbAText','pdbBText'].forEach(id=>E(id).value=''); ['chainsABox','chainsBBox','poseControls'].forEach(id=>E(id).innerHTML=''); ['chainWarnA','chainWarnB','scoreBox'].forEach(id=>E(id).textContent=''); posesTop=[]; currentPose=null; currentA=null; currentB0=null; viewer.clear(); drawPlaceholder(); setProgress(0); status('idle'); }

// ========================= Auto‚Äëdemo: guaranteed 3D docking =========================
function autoDemo(){
  // Generate two demo helices as PDB text so we can guarantee visible sticks/cartoon.
  const pdbA = buildHelixPDB(24,'H', {x:-10,y:0,z:0});
  const pdbB = buildHelixPDB(24,'A', {x: 10,y:0,z:0});
  E('pdbAText').value = pdbA; E('pdbBText').value = pdbB; parseOne('A'); parseOne('B');
  // Immediately run a quick docking so the 3D view updates with a real complex.
  runDocking();
}

function buildHelixPDB(n, chain='A', offset={x:0,y:0,z:0}){
  // Simple alpha-helix backbone (N, CA, C, O) enough for 3Dmol cartoon, with sensible geometry.
  const lines=[]; let serial=1; const rise=1.5, radius=2.2, turn=100*Math.PI/180; let z=0;
  for (let i=0;i<n;i++){
    const ang=i*turn; const cx=offset.x + radius*Math.cos(ang); const cy=offset.y + radius*Math.sin(ang); const cz=offset.z + z; z += rise;
    // Very crude backbone placement around CA direction
    const ca = {x:cx, y:cy, z:cz};
    const dirx = -Math.sin(ang), diry = Math.cos(ang), dirz = 0.2; // tangent
    const N = {x:ca.x - 1.33*dirx, y:ca.y - 1.33*diry, z:ca.z - 1.33*dirz};
    const C = {x:ca.x + 1.52*dirx, y:ca.y + 1.52*diry, z:ca.z + 1.52*dirz};
    const O = {x:C.x + 0.5*diry, y:C.y - 0.5*dirx, z:C.z + 0.3};
    const resi=(i+1).toString().padStart(4,' ');
    const resn = (['ALA','LEU','GLU','LYS','GLN','VAL'][i%6]).padStart(3,' ');
    const fmt=(coord,name,elem)=>`ATOM  ${String(serial++).padStart(5,' ')} ${name} ${resn} ${chain}${resi}    ${coord.x.toFixed(3).padStart(8,' ')}${coord.y.toFixed(3).padStart(8,' ')}${coord.z.toFixed(3).padStart(8,' ')}  1.00  0.00          ${elem}`;
    lines.push(fmt(N,' N  ',' N'), fmt(ca,' CA ',' C'), fmt(C,' C  ',' C'), fmt(O,' O  ',' O'));
  }
  lines.push('TER','END'); return lines.join('\n');
}
</script>
</body>
</html>
