<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Comprehensive Docking Suite ‚Ä¢ Antibody‚ÄìAntigen ‚Ä¢ Ligand Screening ‚Ä¢ Enthalpy</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="theme-color" content="#0f172a" />
<meta name="description" content="Antibody‚Äìantigen docking, ligand docking, and batch virtual screening (50 SMILES √ó up to 3 receptors) with 3D visualization, QA reproducibility, run registry, exports, and analysis ‚Äî all in-browser." />
<style>
  :root{
    --bg:#0b1220;--panel:#0f172a;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--line:#1f2937;
    --green:#34d399;--red:#f87171;--yellow:#fbbf24;--orange:#f97316;--purple:#a78bfa;
    --mono:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;--sans:Inter,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:var(--sans);line-height:1.6}
  a{color:var(--accent);text-decoration:none}
  header{padding:34px 16px;background:radial-gradient(1200px 600px at 15% -10%,#1d2a4a,transparent 60%),radial-gradient(1000px 500px at 120% 10%,#2a1e4a,transparent 60%)}
  .wrap{max-width:1400px;margin:0 auto}
  h1{margin:0 0 8px;font-size:30px;font-weight:700}
  h2{margin:0 0 10px;font-size:22px;font-weight:600}
  h3{margin:14px 0 6px;font-size:17px;font-weight:600}
  h4{margin:10px 0 6px;font-size:15px;font-weight:600}
  p.lead{color:var(--muted);margin:6px 0 0;font-size:14px}
  section{padding:22px 16px;border-top:1px solid var(--line);background:var(--panel)}
  .card{background:#0b1220;border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:12px}
  .grid{display:grid;gap:16px}
  @media(min-width:980px){.grid.two{grid-template-columns:1.05fr .95fr}}
  @media(min-width:1100px){.grid.three{grid-template-columns:repeat(3,1fr)}}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  label{font-weight:600;font-size:13px}
  input[type=number],input[type=text],textarea,select{
    background:#0a0f1a;color:var(--text);border:1px solid #1f2937;border-radius:8px;padding:8px 10px;font-family:var(--mono);font-size:13px;min-width:80px
  }
  textarea{width:100%;min-height:110px;resize:vertical}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:9px 12px;border-radius:10px;font-weight:600;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:13px;transition:.2s}
  .btn:hover:not([disabled]){transform:translateY(-1px);box-shadow:0 6px 16px rgba(96,165,250,.25)}
  .btn.primary{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0}
  .btn.green{background:linear-gradient(180deg,#059669,#047857);border:0}
  .btn.red{background:linear-gradient(180deg,#dc2626,#b91c1c);border:0}
  .btn.purple{background:linear-gradient(180deg,#7c3aed,#6d28d9);border:0}
  .btn.orange{background:linear-gradient(180deg,#f97316,#ea580c);border:0}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .pill{padding:2px 8px;border:1px solid #334155;border-radius:999px;font-size:12px;color:#93c5fd;font-weight:600}
  progress{width:260px;height:10px;border:1px solid var(--line);border-radius:999px;background:#0b1220}
  progress::-webkit-progress-value{background:#60a5fa;border-radius:999px;transition:width .3s}
  .infobox{border:1px solid #334155;border-left:4px solid var(--accent);border-radius:10px;padding:10px;background:#0a0f1a;color:#cbd5e1;margin:10px 0;font-size:13px}
  .errorbox{border:1px solid #7f1d1d;border-left:4px solid #dc2626;border-radius:10px;padding:10px;background:#1a0c0c;color:#fecaca;margin:10px 0}
  .successbox{border:1px solid #065f46;border-left:4px solid #10b981;border-radius:10px;padding:10px;background:#0a1f1a;color:#a7f3d0;margin:10px 0}
  .score{font-family:var(--mono);background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:8px;overflow:auto;font-size:12px;line-height:1.5}
  .chainchips{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px}
  .chip{border:1px solid #334155;border-radius:999px;padding:2px 8px;display:inline-flex;align-items:center;gap:6px;font-size:13px}
  .chip input{accent-color:#60a5fa}
  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
  .tabbtn{padding:8px 12px;border-radius:999px;border:1px solid var(--line);background:#0b1220;cursor:pointer;font-size:14px;font-weight:600;transition:.2s}
  .tabbtn:hover{background:#152034}
  .tabbtn.active{background:linear-gradient(180deg,#2563eb,#1d4ed8);border:0;color:#fff}
  .tabsec{display:none}
  .tabsec.active{display:block}
  .table{width:100%;border-collapse:collapse;font-size:13px;background:#0a0f1a}
  .table th{background:#152034;padding:8px;text-align:left;border-bottom:2px solid var(--line);position:sticky;top:0;z-index:1}
  .table td{padding:6px 8px;border-bottom:1px solid #112033}
  .table tr:hover{background:#0f1829;cursor:pointer}
  .table-container{max-height:460px;overflow:auto;border:1px solid var(--line);border-radius:8px;margin-top:8px}
  #viewer,#viewerLig,#viewerScr,#viewerComp{position:relative;width:100%;height:560px;border:1px solid var(--line);border-radius:10px;background:#0a0f1a;overflow:hidden}
  .metric-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin:10px 0}
  .metric-card{background:#0a0f1a;border:1px solid var(--line);border-radius:8px;padding:10px;text-align:center}
  .metric-value{font-size:20px;font-weight:700;color:var(--accent)}
  .metric-label{font-size:12px;color:var(--muted)}
  .small{font-size:12px;color:#9ca3af}
  footer{padding:18px 16px;color:var(--muted);text-align:center;font-size:13px}
</style>
</head>
<body>

<header>
  <div class="wrap">
    <h1>üß¨ Comprehensive Molecular Docking Suite</h1>
    <p class="lead">
      Antibody‚Äìantigen docking ‚Ä¢ Single-ligand docking ‚Ä¢ Enhanced batch screening (‚â§50 SMILES √ó ‚â§3 receptors) ‚Ä¢
      ŒîH estimation ‚Ä¢ QA reproducibility ‚Ä¢ Run registry ‚Ä¢ All in your browser
    </p>
    <div class="tabs">
      <button class="tabbtn active" data-tab="dockTab">üß∑ Antibody Docking</button>
      <button class="tabbtn" data-tab="ligTab">üß™ Ligand Docking</button>
      <button class="tabbtn" data-tab="screenTab">üìö Batch Screening</button>
      <button class="tabbtn" data-tab="qaTab">‚úÖ QA & Registry</button>
      <button class="tabbtn" data-tab="analysisTab">üìä Analysis</button>
      <button class="tabbtn" data-tab="aboutTab">‚ÑπÔ∏è About</button>
    </div>
    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnDemo">üéØ Load Demo & Dock</button>
      <button class="btn green" id="btnSaveSession">üíæ Save Session</button>
      <button class="btn purple" id="btnLoadSession">üìÇ Load Session</button>
      <span class="pill" id="statusPill">idle</span>
      <progress id="prog" value="0" max="1" aria-label="progress"></progress>
    </div>
  </div>
</header>

<!-- ====================== ANTIBODY‚ÄìANTIGEN DOCKING ====================== -->
<section id="dockTab" class="tabsec active" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>1Ô∏è‚É£ Load Proteins</h2>
      <div class="row small">Upload PDBs or paste text. Parse, then pick chains.</div>
      <div class="row">
        <div style="flex:1;min-width:300px">
          <h3>Protein A (Antibody) <span class="pill" id="badgeA">0 atoms</span></h3>
          <div class="row"><input type="file" id="pdbAFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('A')">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('A')">Fetch PDB ID</button></div>
          <textarea id="pdbAText" placeholder="Paste PDB for Protein A"></textarea>
          <div class="row"><label>Chains:</label><div id="chainsABox" class="chainchips"></div></div>
          <div id="chainWarnA" class="infobox small">Parse to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('A')">üîé Parse A</button><button class="btn" onclick="selectAllChains('A')">Select All</button><button class="btn" onclick="invertChains('A')">Invert</button></div>
        </div>
        <div style="flex:1;min-width:300px">
          <h3>Protein B (Antigen) <span class="pill" id="badgeB">0 atoms</span></h3>
          <div class="row"><input type="file" id="pdbBFile" accept=".pdb,.ent,.txt,.pdb.gz" />
            <button class="btn" onclick="useExample('B')">Example</button>
            <button class="btn" onclick="fetchPDBFromRCSB('B')">Fetch PDB ID</button></div>
          <textarea id="pdbBText" placeholder="Paste PDB for Protein B"></textarea>
          <div class="row"><label>Chains:</label><div id="chainsBBox" class="chainchips"></div></div>
          <div id="chainWarnB" class="infobox small">Parse to populate chains.</div>
          <div class="row"><button class="btn" onclick="parseOne('B')">üîé Parse B</button><button class="btn" onclick="selectAllChains('B')">Select All</button><button class="btn" onclick="invertChains('B')">Invert</button></div>
        </div>
      </div>
      <details style="margin-top:10px"><summary><b>Input notes</b></summary>
        <div class="small" style="padding-top:6px">
          <b>Formats:</b> PDB text, .pdb.gz ‚Ä¢ <b>Fetch:</b> RCSB via PDB ID ‚Ä¢ <b>Cartoon:</b> needs backbone atoms (N/CA/C/O)
        </div>
      </details>
    </div>

    <div class="card">
      <h2>2Ô∏è‚É£ Docking Parameters</h2>
      <h4>Sampling</h4>
      <div class="row">
        <label>Samples</label><input type="number" id="samples" value="10000" min="1000" step="500" />
        <label>Max Translation (√Ö)</label><input type="number" id="maxTrans" value="12" step="1" />
        <label>Atom Set</label><select id="atomMode"><option value="CA">CŒ± only</option><option value="BB">Backbone</option><option value="HEAVY">All heavy</option></select>
      </div>
      <h4 style="margin-top:8px">Scoring</h4>
      <div class="row">
        <label>Contact (√Ö)</label><input type="number" id="contactCut" value="4.8" step="0.1" />
        <label>Clash Factor</label><input type="number" id="clashFactor" value="0.85" step="0.05" />
        <label>Contact W</label><input type="number" id="wContact" value="1.0" step="0.1" />
        <label>Clash W</label><input type="number" id="wClash" value="6.0" step="0.1" />
        <label>Softness</label><input type="number" id="soft" value="0.5" step="0.1" />
      </div>
      <h4 style="margin-top:8px">Output</h4>
      <div class="row">
        <label>Top Poses</label><input type="number" id="topN" value="12" min="1" max="50" />
        <label>Rescore</label><select id="rescoreMode"><option value="NONE">Skip</option><option value="HEAVY">Heavy</option><option value="HEAVY_REFINE">Heavy + refine</option></select>
        <label>Seed</label><input type="number" id="seed" value="42" />
      </div>
      <div class="row">
        <label>Diversity (¬∞/√Ö)</label><input type="number" id="dupAngle" value="12" step="1" style="width:90px" />
        <input type="number" id="dupTrans" value="2" step="0.5" style="width:90px" />
      </div>
      <div class="row" style="margin-top:10px">
        <button class="btn primary" id="dockBtn">‚ñ∂Ô∏è Run Docking</button>
        <button class="btn red" id="cancelBtn" disabled>‚úñ Cancel</button>
        <button class="btn orange" id="resetBtn">üîÑ Reset</button>
      </div>
      <div class="infobox small"><b>Score = contacts√óW<sub>c</sub> ‚àí clashes√óW<sub>x</sub></b>. Heavy rescoring refines ranks with all non-H atoms.</div>
    </div>
  </div>

  <div class="wrap grid two">
    <div class="card">
      <h2>3Ô∏è‚É£ 3D Visualization & Results</h2>
      <div id="viewer" role="img" aria-label="3D viewer"></div>
      <div class="row" style="margin-top:8px;flex-wrap:wrap" id="poseControls"></div>
      <div class="row" style="margin-top:8px">
        <label class="chip"><input type="checkbox" id="toggleContacts" checked> Contacts</label>
        <label class="chip"><input type="checkbox" id="toggleHB" checked> H-bonds</label>
        <label class="chip"><input type="checkbox" id="toggleSB" checked> Salt bridges</label>
        <label class="chip"><input type="checkbox" id="toggleHydro"> Hydrophobic</label>
      </div>
      <div class="score" id="scoreBox" style="margin-top:8px"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnAllPDB">‚¨á All Poses PDB</button>
        <button class="btn green" id="btnCurrentPDB">‚¨á Current PDB</button>
        <button class="btn" id="btnCSV">‚¨á CSV</button>
        <button class="btn" id="btnJSON">‚¨á JSON</button>
        <button class="btn purple" id="btnPNG">üì∏ PNG</button>
      </div>
    </div>

    <div class="card">
      <h2>Interface Metrics & Enthalpy</h2>
      <div class="metric-grid" id="metricsDisplay"></div>
      <h4 style="margin-top:10px">Energy Parameters</h4>
      <div class="row">
        <label>k<sub>elec</sub></label><input type="number" id="kElec" value="0.5" step="0.1" />
        <label>Elec Cutoff (√Ö)</label><input type="number" id="elecCut" value="12" step="0.5" />
        <label>Desolv W</label><input type="number" id="wDesolv" value="0.2" step="0.1" />
      </div>
      <div class="infobox small">
        <b>ŒîH (kcal/mol) ‚âà</b> ‚àí0.5√ócontacts ‚àí2.5√óH-bonds ‚àí4.0√ósalt-bridges ‚àí1.0√óhydrophobic +0.3√óclash + electrostatics +0.2√ócontacts (desolv).
      </div>
      <div class="infobox small"><b>Reproducibility:</b> All outputs include parameters & seed.</div>
    </div>
  </div>
</section>

<!-- ====================== LIGAND DOCKING ====================== -->
<section id="ligTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>üß™ Single Ligand Docking</h2>
      <div class="small">SMILES‚Üí3D uses simplified embedding for demo; use RDKit/OpenBabel for production.</div>
      <div class="row">
        <div style="flex:1;min-width:300px">
          <h3>Receptor PDB</h3>
          <textarea id="ligReceptorPDB" placeholder="Paste receptor PDB"></textarea>
          <div class="row" style="margin-top:6px"><button class="btn" onclick="loadLigandDemoReceptor()">Load Example</button><button class="btn" onclick="parseReceptorForLigand()">Parse & Preview</button></div>
        </div>
        <div style="flex:1;min-width:300px">
          <h3>Ligand SMILES</h3>
          <textarea id="ligSmiles" placeholder="e.g., CC(=O)Oc1ccccc1C(=O)O (aspirin)"></textarea>
          <div class="row" style="margin-top:6px">
            <label>3D Method</label><select id="ligEmbedMethod"><option value="HASH">HashCloud</option><option value="HELIX">RingHelix</option></select>
            <label>Seed</label><input type="number" id="ligSeed" value="1337" style="width:90px" />
            <button class="btn primary" onclick="runSingleLigandDock()">‚ñ∂Ô∏è Dock</button>
          </div>
        </div>
      </div>
      <div class="infobox small"><b>Note:</b> Posing uses receptor center sampling; score = contacts ‚àí clash (same core terms).</div>
    </div>
    <div class="card">
      <h2>Ligand Docking Result</h2>
      <div id="viewerLig"></div>
      <div class="score" id="ligScore" style="margin-top:8px"></div>
      <div class="row" style="margin-top:8px">
        <button class="btn green" id="btnLigPDB">‚¨á Complex PDB</button>
        <button class="btn" id="btnLigCSV">‚¨á CSV Result</button>
        <span class="pill" id="ligStatus">idle</span>
      </div>
    </div>
  </div>
</section>

<!-- ====================== BATCH SCREENING (ENHANCED) ====================== -->
<section id="screenTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>üìö Enhanced Batch Screening (‚â§50 SMILES √ó ‚â§3 Receptors)</h2>
      <div class="grid three">
        <div>
          <h3>Small Molecule Library (SMILES)</h3>
          <textarea id="scrSmiles" placeholder="One SMILES per line (max 50)
Examples:
CC(=O)Oc1ccccc1C(=O)O
CCO
c1ccccc1
CC(C)NCC(O)c1ccc(O)c(O)c1"></textarea>
          <div class="row" style="margin-top:6px">
            <button class="btn" onclick="loadExampleSMILES()">Load 50 Examples</button>
            <button class="btn purple" onclick="loadDruglikeSMILES()">FDA Drugs (20)</button>
          </div>
          <div class="small">SMILES = Simplified Molecular Input Line Entry System for small molecules</div>
        </div>
        <div>
          <h3>Receptor Proteins (PDB format)</h3>
          <textarea id="scrReceptors" placeholder="Paste 1-3 PDBs separated by a line with: END

ATOM      1  CA  ALA A   1       0.000   0.000   0.000
ATOM      2  CA  ALA A   2       3.800   0.000   0.000
...
END
ATOM      1  CA  GLY B   1       0.000   0.000   0.000
..."></textarea>
          <div class="row" style="margin-top:6px">
            <button class="btn" onclick="loadExampleReceptors()">Load Example Receptors</button>
            <button class="btn orange" onclick="convertSequenceToPDB()">Convert Sequence‚ÜíPDB</button>
          </div>
          <div class="small">Delimiter must be exactly "END" on its own line.</div>
        </div>
        <div>
          <h3>Parameters</h3>
          <div class="row"><label>Samples/Ligand</label><input type="number" id="scrSamples" value="1000" min="100" max="10000" step="100" /></div>
          <div class="row"><label>Contact (√Ö)</label><input type="number" id="scrContactCut" value="4.8" step="0.1" /></div>
          <div class="row"><label>Clash Factor</label><input type="number" id="scrClashFactor" value="0.85" step="0.05" /></div>
          <div class="row"><label>Seed</label><input type="number" id="scrSeed" value="777" /></div>
          <div class="row"><label>3D Method</label><select id="scrEmbedMethod">
            <option value="RDKIT">RDKit-like</option>
            <option value="UFF">UFF-like</option>
            <option value="FAST">Fast Heuristic</option>
          </select></div>
          <div class="row"><label>Parallel Workers</label><input type="number" id="scrWorkers" value="4" min="1" max="8" /></div>
          <div class="row" style="margin-top:10px">
            <button class="btn primary" id="btnStartScreen">‚ñ∂Ô∏è Start Screening</button>
            <button class="btn red" id="btnStopScreen" disabled>‚úñ Stop</button>
          </div>
          <div class="infobox small">Optimized parallel processing for up to 50 compounds</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Screening Progress & Results</h2>
      <div class="row" style="margin-bottom:8px">
        <progress id="scrProgress" value="0" max="1" style="width:100%"></progress>
        <span class="pill" id="scrStatus">idle</span>
        <span class="small" id="scrProgressText"></span>
      </div>
      <div class="row" style="margin-bottom:8px">
        <button class="btn green" id="btnScrCSV">‚¨á Results CSV</button>
        <button class="btn" id="btnScrJSON">‚¨á JSON Export</button>
        <button class="btn purple" id="btnScrTop10">üìä Top 10</button>
        <button class="btn orange" onclick="sortResults('score')">Sort by Score</button>
        <button class="btn orange" onclick="sortResults('enthalpy')">Sort by ŒîH</button>
      </div>
      <div class="table-container">
        <table class="table" id="scrTable">
          <thead><tr>
            <th>#</th><th>Receptor</th><th>SMILES</th><th>Score</th><th>Contacts</th><th>H-bonds</th><th>Clash</th><th>ŒîH (kcal/mol)</th><th>Time (ms)</th>
          </tr></thead>
          <tbody id="scrTableBody"></tbody>
        </table>
      </div>
      <div id="viewerScr" style="height:420px;margin-top:12px"></div>
      <div class="small" style="text-align:center;margin-top:4px">Click a row to visualize the docked pose.</div>
    </div>

    <div class="card">
      <h2>Enthalpy Distribution & Statistics</h2>
      <div class="metric-grid" id="screenMetrics"></div>
      <div class="score" id="enthalpyBreakdown" style="margin-top:8px"></div>
      <div class="infobox small"><b>Interpretation:</b> more negative ŒîH ‚áí stronger binding (approximate; entropy not included).</div>
    </div>
  </div>
</section>

<!-- ====================== QA & REGISTRY ====================== -->
<section id="qaTab" class="tabsec" data-tab-panel>
  <div class="wrap grid two">
    <div class="card">
      <h2>üìã Run Registry & Session Management</h2>
      <div class="row" style="margin-top:6px">
        <button class="btn green" onclick="saveCurrentRun()">üíæ Save Current Run</button>
        <button class="btn" onclick="refreshRunRegistry()">üîÑ Refresh</button>
        <button class="btn" onclick="exportAllRuns()">‚¨á Export Registry</button>
        <button class="btn purple" onclick="importRunRegistry()">‚¨Ü Import Registry</button>
        <button class="btn red" onclick="clearRunRegistry()">üóëÔ∏è Clear</button>
      </div>
      <input type="file" id="importRegistryFile" accept=".json" style="display:none" />
      <div class="table-container" style="margin-top:10px">
        <table class="table">
          <thead><tr><th>Timestamp</th><th>Type</th><th>Description</th><th>Top Score</th><th>Actions</th></tr></thead>
          <tbody id="registryTableBody"></tbody>
        </table>
      </div>
    </div>
    <div class="card">
      <h2>‚úÖ Quality Assurance (Reproducibility)</h2>
      <div class="row" style="margin-top:6px">
        <label>Repeats</label><input type="number" id="qaRepeats" value="3" min="2" max="10" style="width:90px" />
        <label>Tolerance</label><input type="number" id="qaTolerance" value="0.01" step="0.01" style="width:90px" />
        <button class="btn primary" onclick="runQATest()">‚ñ∂Ô∏è Run QA Test</button>
      </div>
      <div class="score" id="qaResults" style="margin-top:10px;min-height:120px"></div>
      <div class="infobox small">Runs N repeats with same seed; passes if top scores within tolerance.</div>
    </div>
  </div>
</section>

<!-- ====================== ANALYSIS ====================== -->
<section id="analysisTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>üìä Analysis Tools</h2>
      <div class="tabs" style="margin-top:6px">
        <button class="tabbtn active" data-subtab="energyTab">Energy Decomposition</button>
        <button class="tabbtn" data-subtab="compareTab">Pose Comparison</button>
        <button class="tabbtn" data-subtab="residueTab">Residue Contacts</button>
      </div>
      <div id="energyTab" class="tabsec active">
        <h3>Energy Component Analysis</h3>
        <div id="energyComponents" class="metric-grid"></div>
        <h4>ŒîH Details</h4>
        <div class="score" id="enthalpyDetail"></div>
      </div>
      <div id="compareTab" class="tabsec">
        <h3>Compare Poses</h3>
        <div class="row">
          <label>Pose 1</label><select id="comparePose1"></select>
          <label>Pose 2</label><select id="comparePose2"></select>
          <button class="btn primary" onclick="comparePoses()">Compare</button>
        </div>
        <div class="grid two" style="margin-top:10px">
          <div><div id="viewerComp" style="height:420px"></div></div>
          <div><div class="score" id="comparisonResults" style="min-height:420px"></div></div>
        </div>
      </div>
      <div id="residueTab" class="tabsec">
        <h3>Residue-Level Contacts</h3>
        <div class="row">
          <label>Min Dist (√Ö)</label><input type="number" id="filterMinDist" value="0" step="0.5" style="width:90px" />
          <label>Max Dist (√Ö)</label><input type="number" id="filterMaxDist" value="6" step="0.5" style="width:90px" />
          <button class="btn" onclick="filterResidueContacts()">Filter</button>
          <button class="btn green" onclick="exportResidueData()">‚¨á Export</button>
        </div>
        <div class="table-container" style="margin-top:8px">
          <table class="table">
            <thead><tr><th>Residue A</th><th>Chain A</th><th>Residue B</th><th>Chain B</th><th>Distance (√Ö)</th><th>Type</th><th>Energy</th></tr></thead>
            <tbody id="residueTableBody"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</section>

<!-- ====================== ABOUT / DISCLAIMERS ====================== -->
<section id="aboutTab" class="tabsec" data-tab-panel>
  <div class="wrap">
    <div class="card">
      <h2>About This Tool</h2>
      <p>This educational platform demonstrates in-browser molecular docking with parallel sampling, simplified scoring, and interactive visualization. All computations run locally; nothing is uploaded to servers.</p>
      
      <h3>What are SMILES?</h3>
      <p>SMILES (Simplified Molecular Input Line Entry System) are text representations of chemical structures for small molecules:</p>
      <ul>
        <li><code>CCO</code> = Ethanol</li>
        <li><code>CC(=O)O</code> = Acetic acid</li>
        <li><code>CC(=O)Oc1ccccc1C(=O)O</code> = Aspirin</li>
        <li><code>CN1C=NC2=C1C(=O)N(C(=O)N2C)C</code> = Caffeine</li>
      </ul>
      
      <h3>Important Disclaimers</h3>
      <div class="errorbox">
        <p><b>We provide no warranties and we disclaim any loss in any way.</b></p>
        <p><b>‚ö†Ô∏è SMILES are for small molecules only!</b> Protein sequences (like MSQTGSHPGR...) are NOT SMILES and cannot be docked as ligands.</p>
        <p>Scoring/embedding are simplified approximations; entropy, solvation, polarization, and induced fit are not fully modeled. Validate results independently with professional tools and experiments.</p>
      </div>
      
      <h3>Recommended Workflow</h3>
      <div class="infobox small">Use this tool for hypothesis generation ‚Üí export top poses ‚Üí refine with AutoDock/HADDOCK/Rosetta ‚Üí MD simulations ‚Üí MM-PBSA/FEP ‚Üí experimental validation (SPR/ITC).</div>
      
      <h3>Performance</h3>
      <div class="infobox small">Enhanced batch screening uses parallel workers to process 50 compounds efficiently. Each compound takes ~100-500ms depending on parameters.</div>
      
      <h3>Credits</h3>
      <div class="small">3Dmol.js (Rego & Koes) ‚Ä¢ Pako (zlib) ‚Ä¢ RCSB PDB</div>
    </div>
  </div>
</section>

<footer>
  <div class="wrap">
    <p>All computations execute locally in your browser. No data transmitted to servers.</p>
    <p class="small">¬© Educational Tool ‚Ä¢ No warranties ‚Ä¢ We disclaim any loss in any way ‚Ä¢ Validate results independently</p>
  </div>
</footer>

<!-- External libs -->
<script defer src="https://unpkg.com/3dmol@2.4.2/build/3Dmol-min.js"></script>
<script defer src="https://unpkg.com/pako@2.1.0/dist/pako.min.js"></script>

<script>
// ========================= GLOBALS =========================
let viewer=null, viewerLig=null, viewerScr=null, viewerComp=null;
let inProgress=false, cancelled=false, workerPool=[], screenWorkerPool=[];
let pdbAAllAtoms=[], pdbBAllAtoms=[], currentA=null, currentB0=null;
let posesTop=[], currentPose=null, currentPoseIndex=-1;
let currentContacts=[], currentHB=[], currentSB=[], currentHydro=[];
let ligLastResult={}, screenCancel=false, screenResults=[], screenReceptors=[];
let totalJobs=0, completedJobs=0;
const REGISTRY_KEY='docking_registry_v1';

// vdW radii (√Ö)
const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
// hydrophobic residues
const hydrophobic=new Set(['ALA','VAL','LEU','ILE','PRO','PHE','MET','TRP','TYR','CYS']);
// residue charges (formal)
const residueCharges={'ASP':-1,'GLU':-1,'LYS':+1,'ARG':+1,'HIS':+0.1};

// Shorthands
const E=id=>document.getElementById(id);
const status=t=>E('statusPill').textContent=t;
const setProgress=f=>{E('prog').value=Math.max(0,Math.min(1,f||0));};

// ========================= INIT =========================
window.addEventListener('DOMContentLoaded', ()=>{
  ensureViewer('viewer'); ensureViewer('viewerLig'); ensureViewer('viewerScr'); ensureViewer('viewerComp');
  drawPlaceholder(viewer);
  setupMainTabs();
  setupSubTabs();
  bindEvents();
  loadSessionHistory();
  setTimeout(autoDemo, 200);
});

// ========================= Tabs =========================
function setupMainTabs(){
  document.querySelectorAll('.tabbtn[data-tab]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      document.querySelectorAll('.tabbtn[data-tab]').forEach(b=>b.classList.remove('active'));
      btn.classList.add('active');
      const target=btn.dataset.tab;
      document.querySelectorAll('[data-tab-panel]').forEach(sec=>{
        sec.classList.toggle('active', sec.id===target);
      });
      setTimeout(()=>{try{
        viewer?.resize(); viewerLig?.resize(); viewerScr?.resize(); viewerComp?.resize();
        viewer?.render(); viewerLig?.render(); viewerScr?.render(); viewerComp?.render();
      }catch(e){}},10);
    });
  });
}
function setupSubTabs(){
  document.querySelectorAll('.tabbtn[data-subtab]').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const wrap=btn.closest('.card');
      wrap.querySelectorAll('.tabbtn[data-subtab]').forEach(b=>b.classList.remove('active'));
      wrap.querySelectorAll('.tabsec').forEach(s=>s.classList.remove('active'));
      btn.classList.add('active');
      wrap.querySelector('#'+btn.dataset.subtab).classList.add('active');
      setTimeout(()=>{viewerComp?.resize(); viewerComp?.render();},10);
    });
  });
}

// ========================= Viewers =========================
function ensureViewer(id){
  const el=E(id); if(!el) return;
  const opt={backgroundColor:'#0a0f1a'};
  if(id==='viewer' && !viewer) viewer=$3Dmol.createViewer(el,opt);
  else if(id==='viewerLig' && !viewerLig) viewerLig=$3Dmol.createViewer(el,opt);
  else if(id==='viewerScr' && !viewerScr) viewerScr=$3Dmol.createViewer(el,opt);
  else if(id==='viewerComp' && !viewerComp) viewerComp=$3Dmol.createViewer(el,opt);
}
function drawPlaceholder(v){
  if(!v) return;
  v.addSphere({center:{x:-8,y:0,z:0},radius:4,color:'#60a5fa',alpha:.6});
  v.addSphere({center:{x:8,y:0,z:0},radius:4,color:'#f97316',alpha:.6});
  v.zoomTo(); v.render();
}

// ========================= Events =========================
function bindEvents(){
  // global
  E('btnDemo').addEventListener('click', autoDemo);
  E('btnSaveSession').addEventListener('click', saveSession);
  E('btnLoadSession').addEventListener('click', loadSession);

  // docking
  E('dockBtn').addEventListener('click', runAntibodyDocking);
  E('cancelBtn').addEventListener('click', cancelDocking);
  E('resetBtn').addEventListener('click', resetAll);

  // exports
  E('btnAllPDB').addEventListener('click', downloadAllPoses);
  E('btnCurrentPDB').addEventListener('click', downloadCurrentPose);
  E('btnCSV').addEventListener('click', downloadCSV);
  E('btnJSON').addEventListener('click', downloadJSON);
  E('btnPNG').addEventListener('click', ()=>snapshotPNG(viewer));

  // overlays
  ['toggleContacts','toggleHB','toggleSB','toggleHydro'].forEach(id=>E(id).addEventListener('change', refreshOverlays));

  // file inputs
  E('pdbAFile').addEventListener('change', e=>handleFileUpload('A', e.target.files[0]));
  E('pdbBFile').addEventListener('change', e=>handleFileUpload('B', e.target.files[0]));

  // ligand docking
  E('btnLigPDB').addEventListener('click', downloadLigandPDB);
  E('btnLigCSV').addEventListener('click', downloadLigandCSV);

  // screening
  E('btnStartScreen').addEventListener('click', startBatchScreening);
  E('btnStopScreen').addEventListener('click', ()=>{screenCancel=true;E('btnStopScreen').disabled=true;});
  E('btnScrCSV').addEventListener('click', downloadScreeningCSV);
  E('btnScrJSON').addEventListener('click', downloadScreeningJSON);
  E('btnScrTop10').addEventListener('click', showTop10Screening);
}

// ========================= Utils =========================
async function fileToText(file){
  const name=file.name.toLowerCase(); const buf=await file.arrayBuffer();
  if(name.endsWith('.gz')){const u8=new Uint8Array(buf); const out=pako.inflate(u8); return new TextDecoder().decode(out);}
  return new TextDecoder().decode(buf);
}
async function handleFileUpload(which,file){ if(!file) return; try{
  const text=await fileToText(file);
  E(which==='A'?'pdbAText':'pdbBText').value=text; parseOne(which);
} catch(e){ alert('Error reading file: '+e.message); } }
async function fetchPDBFromRCSB(which){
  const pdbId=prompt(`Enter 4-character PDB ID for Protein ${which}:`); if(!pdbId) return;
  const id=pdbId.trim().toLowerCase(); if(id.length!==4){alert('PDB ID must be 4 chars');return;}
  try{ status(`fetching ${id}‚Ä¶`); const res=await fetch(`https://files.rcsb.org/download/${id}.pdb`);
    if(!res.ok) throw new Error('RCSB error'); const txt=await res.text();
    E(which==='A'?'pdbAText':'pdbBText').value=txt; await parseOne(which); status('idle');
  }catch(e){ alert('Fetch failed: '+e.message); status('error'); }
}
function centroid(pts){let x=0,y=0,z=0; for(const p of pts){x+=p.x;y+=p.y;z+=p.z;} const n=pts.length||1; return {x:x/n,y:y/n,z:z/n};}
function translate(points,t){return points.map(p=>({...p,x:p.x+t.x,y:p.y+t.y,z:p.z+t.z}));}
function formatPDB(atoms,chainShift=0){
  const lines=[]; let serial=1;
  for(const a of atoms){
    const name=(a.name||'CA').padStart(4,' '),resn=(a.resn||'RES').padStart(3,' ');
    const chain=String.fromCharCode((a.chain||'A').charCodeAt(0)+chainShift);
    const resi=String(a.resi||1).padStart(4,' '),x=(a.x??0).toFixed(3).padStart(8,' '),y=(a.y??0).toFixed(3).padStart(8,' '),z=(a.z??0).toFixed(3).padStart(8,' ');
    const elem=(a.elem||'C').toString().padStart(2,' ');
    lines.push(`ATOM  ${String(serial).padStart(5,' ')} ${name} ${resn} ${chain}${resi}    ${x}${y}${z}  1.00  0.00          ${elem}`); serial++;
  }
  lines.push('TER','ENDMDL','END'); return lines.join('\n');
}
function downloadBlob(text, filename){
  const url=URL.createObjectURL(new Blob([text],{type:'text/plain'}));
  const a=document.createElement('a'); a.href=url; a.download=filename; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000);
}
function snapshotPNG(v){
  try{ v.render(); v.pngURI((uri)=>{ const a=document.createElement('a'); a.href=uri; a.download='viewer.png'; a.click(); }); }catch(e){ alert('PNG failed: '+e.message);}
}

// ========================= PDB parsing / chains =========================
function parsePDB(text){
  const atoms=[]; const lines=text.split(/\r?\n/);
  for(const line of lines){
    if(!line.startsWith('ATOM') && !line.startsWith('HETATM')) continue;
    const atom={
      name:line.substring(12,16).trim(), resn:line.substring(17,20).trim(),
      chain:line.substring(21,22).trim()||'A', resi:parseInt(line.substring(22,26)),
      x:parseFloat(line.substring(30,38)), y:parseFloat(line.substring(38,46)), z:parseFloat(line.substring(46,54)),
      elem: (line.length>=78? (line.substring(76,78).trim()||line.substring(12,16).trim()[0]) : line.substring(12,16).trim()[0]).toUpperCase()
    };
    if (!isNaN(atom.x) && !isNaN(atom.y) && !isNaN(atom.z)) {
      atoms.push(atom);
    }
  }
  return atoms;
}
async function parseOne(which){
  const t = E(which==='A'?'pdbAText':'pdbBText').value.trim();
  if(!t){ alert('Paste PDB or upload file first.'); return; }
  const atoms=parsePDB(t);
  if(!atoms.length){ alert('No atoms parsed ‚Äî check PDB.'); return; }
  if(which==='A'){ pdbAAllAtoms=atoms; populateChainChips('A',atoms); E('badgeA').textContent=`${atoms.length} atoms`; }
  else{ pdbBAllAtoms=atoms; populateChainChips('B',atoms); E('badgeB').textContent=`${atoms.length} atoms`; }
}
function populateChainChips(which, atoms){
  const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.innerHTML='';
  const chains=[...new Set(atoms.map(a=>a.chain))]; chains.forEach(c=>{
    const id=`${which}_ch_${c}`; const lbl=document.createElement('label'); lbl.className='chip';
    lbl.innerHTML=`<input type="checkbox" id="${id}" data-which="${which}" data-chain="${c}" checked> ${c}`;
    box.appendChild(lbl);
  });
  const warn=which==='A'?E('chainWarnA'):E('chainWarnB'); warn.className='successbox small';
  warn.textContent=`‚úì Parsed ${atoms.length} atoms ‚Ä¢ Chains: ${chains.join(', ')||'‚Äî'}`;
}
function selectedChains(which){
  const box=which==='A'?E('chainsABox'):E('chainsBBox');
  const selected=[...box.querySelectorAll('input[type=checkbox]')].filter(cb=>cb.checked).map(cb=>cb.dataset.chain);
  return new Set(selected);
}
function selectAllChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=true); }
function invertChains(which){ const box=which==='A'?E('chainsABox'):E('chainsBBox'); box.querySelectorAll('input[type=checkbox]').forEach(cb=>cb.checked=!cb.checked); }
function filterChains(atoms, keep){ if(!keep || keep.size===0) return atoms; return atoms.filter(a=>keep.has(a.chain)); }
function selectAtomSet(atoms, mode){
  const bb=new Set(['N','CA','C','O']); return atoms.filter(a=>{
    if(mode==='CA') return a.name==='CA'; if(mode==='BB') return bb.has(a.name); return a.elem!=='H';
  });
}

// ========================= Worker (sampling/scoring) =========================
function makeDockWorker(){
  const code=`
    const vdw={H:1.2,C:1.7,N:1.55,O:1.52,S:1.8,P:1.8,F:1.47,CL:1.75,BR:1.85,I:1.98};
    function rand(seed){let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);}
    function randomQuat(r){const u1=r(),u2=r(),u3=r(); const a=Math.sqrt(1-u1),b=Math.sqrt(u1),t1=2*Math.PI*u2,t2=2*Math.PI*u3; return [a*Math.sin(t1),a*Math.cos(t1),b*Math.sin(t2),b*Math.cos(t2)];}
    function rotate(points,q){const[qx,qy,qz,qw]=q; return points.map(p=>{const vx=p.x,vy=p.y,vz=p.z; const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz; const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy),oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz),oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx); return {x:ox,y:oy,z:oz,elem:p.elem};});}
    function translate(points,t){return points.map(p=>({x:p.x+t.x,y:p.y+t.y,z:p.z+t.z,elem:p.elem}));}
    function grid(coords,c){const m=new Map(),k=(ix,iy,iz)=>ix+"|"+iy+"|"+iz; for(let i=0;i<coords.length;i++){const x=coords[i].x,y=coords[i].y,z=coords[i].z,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),kk=k(ix,iy,iz); if(!m.has(kk)) m.set(kk,[]); m.get(kk).push(i);} return {c,m};}
    function neigh(g,x,y,z){const c=g.c,ix=Math.floor(x/c),iy=Math.floor(y/c),iz=Math.floor(z/c),out=[]; for(let dx=-1;dx<=1;dx++)for(let dy=-1;dy<=1;dy++)for(let dz=-1;dz<=1;dz++){const kk=(ix+dx)+"|"+(iy+dy)+"|"+(iz+dz); if(g.m.has(kk)) out.push(...g.m.get(kk));} return out;}
    function scorePose(A,B,contact,clashFact,wC,wX,soft){const G=grid(A,contact); let contacts=0, clash=0;
      for(let i=0;i<B.length;i++){const x=B[i].x,y=B[i].y,z=B[i].z, eB=(B[i].elem||'C').toUpperCase(), neighs=neigh(G,x,y,z);
        for(const j of neighs){const a=A[j],dx=x-a.x,dy=y-a.y,dz=z-a.z, d=Math.hypot(dx,dy,dz), eA=(a.elem||'C').toUpperCase();
          const rs=(vdw[eA]||1.7)+(vdw[eB]||1.7), clashCut=clashFact*rs;
          if(d<=clashCut){const ov=(clashCut-d+1e-6)/clashCut; clash+=wX*ov*(1/(1+soft*ov));}
          else if(d<=contact){contacts+=1;}
        }
      }
      return {score: wC*contacts - clash, contacts, clash};
    }
    self.onmessage=(ev)=>{
      const {Apts,Bpts,params,start,end}=ev.data; const rng=rand(params.seed+start*1337);
      const best=[]; const total=end-start;
      for(let k=0;k<total;k++){
        const q=randomQuat(rng), t={x:(rng()*2-1)*params.maxTrans, y:(rng()*2-1)*params.maxTrans, z:(rng()*2-1)*params.maxTrans};
        const B=translate(rotate(Bpts,q),t), s=scorePose(Apts,B,params.contactCut,params.clashFactor,params.wContact,params.wClash,params.soft);
        best.push({score:s.score,contacts:s.contacts,clash:s.clash,q:[...q],t});
        if((k&1023)===0) self.postMessage({type:'progress',count:k});
      }
      best.sort((a,b)=>b.score-a.score);
      self.postMessage({type:'done',poses:best.slice(0,Math.min(200,total))});
    };
  `;
  return new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
}
function angleBetweenQuats(q1,q2){const dot=q1[0]*q2[0]+q1[1]*q2[1]+q1[2]*q2[2]+q1[3]*q2[3]; return 2*Math.acos(Math.min(1,Math.abs(dot)))*180/Math.PI;}
function diverseTop(sorted,deg,transA){
  const out=[]; const max=Math.max(1,parseInt(E('topN').value)||10);
  for(const p of sorted){
    let dupe=false;
    for(const s of out){
      const a=angleBetweenQuats(p.q,s.q);
      const t=Math.hypot(p.t.x-s.t.x,p.t.y-s.t.y,p.t.z-s.t.z);
      if(a<=deg && t<=transA){dupe=true;break;}
    }
    if(!dupe){out.push(p); if(out.length>=max) break;}
  }
  return out;
}

// ========================= Docking driver =========================
async function runAntibodyDocking(){
  if(inProgress) return;
  cancelled=false; inProgress=true; status('preparing'); setProgress(0);
  E('dockBtn').disabled=true; E('cancelBtn').disabled=false; E('dockBtn').textContent='Running‚Ä¶';
  try{
    const textA=await ensureInputText('A'), textB=await ensureInputText('B');
    pdbAAllAtoms=parsePDB(textA); pdbBAllAtoms=parsePDB(textB);
    populateChainChips('A',pdbAAllAtoms); populateChainChips('B',pdbBAllAtoms);

    const params=collectDockingParams();
    const aSel=filterChains(pdbAAllAtoms, selectedChains('A'));
    const bSel=filterChains(pdbBAllAtoms, selectedChains('B'));
    if(!aSel.length||!bSel.length) throw new Error('No atoms after chain filtering. Select valid chains (or Select All).');

    const ptsA0=selectAtomSet(aSel,params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
    const ptsB0=selectAtomSet(bSel,params.atomMode).map(a=>({x:a.x,y:a.y,z:a.z,elem:a.elem}));
    if(!ptsA0.length||!ptsB0.length) throw new Error('Atom selection empty. Try Backbone or Heavy mode.');
    const cA=centroid(ptsA0), cB=centroid(ptsB0);
    const ptsA=translate(ptsA0,{x:-cA.x,y:-cA.y,z:-cA.z});
    const ptsB=translate(ptsB0,{x:-cB.x,y:-cB.y,z:-cB.z});

    status('sampling');
    const cores=Math.max(1,(navigator.hardwareConcurrency||4)-1), pool=Math.min(cores,8);
    const total=params.samples, base=Math.floor(total/pool), extra=total%pool;
    let all=[], done=0; workerPool=[];
    for(let i=0;i<pool;i++){
      const start=i*base+Math.min(i,extra), end=start+base+(i<extra?1:0);
      const w=makeDockWorker(); workerPool.push(w);
      w.onmessage=(m)=>{
        if(cancelled) return;
        const msg=m.data;
        if(msg.type==='progress'){ done+=1024; setProgress(Math.min(1,done/total)); status(`sampling ${Math.min(done,total)}/${total}`); }
        if(msg.type==='done'){ all.push(msg.poses); w.terminate(); if(all.length===pool){ finalizeDocking(all.flat(),params,aSel,bSel,cA,cB); } }
      };
      w.onerror=(e)=>{console.error('worker error',e); w.terminate();};
      w.postMessage({Apts:ptsA,Bpts:ptsB,params,start,end});
    }
  }catch(e){ alert(e.message||'Docking error'); finishDocking(); status('error'); inProgress=false; }
}
function cancelDocking(){ cancelled=true; workerPool.forEach(w=>{try{w.terminate();}catch(e){}}); workerPool=[]; setProgress(0); status('cancelled'); finishDocking(); inProgress=false; }
function finishDocking(){ E('dockBtn').disabled=false; E('cancelBtn').disabled=true; E('dockBtn').textContent='‚ñ∂Ô∏è Run Docking'; }
function collectDockingParams(){
  return {samples:parseInt(E('samples').value),maxTrans:parseFloat(E('maxTrans').value),contactCut:parseFloat(E('contactCut').value),
    clashFactor:parseFloat(E('clashFactor').value),wContact:parseFloat(E('wContact').value),wClash:parseFloat(E('wClash').value),soft:parseFloat(E('soft').value),
    topN:Math.max(1,parseInt(E('topN').value)),seed:parseInt(E('seed').value)||42,atomMode:E('atomMode').value,rescoreMode:E('rescoreMode').value};
}
async function ensureInputText(which){
  const file=E(which==='A'?'pdbAFile':'pdbBFile').files[0];
  let t=E(which==='A'?'pdbAText':'pdbBText').value.trim(); if(!t && file){ t=await fileToText(file); }
  if(!t) throw new Error(`Provide PDB for Protein ${which} (file or text).`); return t;
}
async function finalizeDocking(poses, params, atomsA, atomsB, cA, cB){
  if(cancelled) return cancelDocking();
  status(params.rescoreMode==='NONE'?'ranking': (params.rescoreMode==='HEAVY'?'rescoring':'refining'));
  poses.sort((a,b)=>b.score-a.score);
  const diverse=diverseTop(poses, parseFloat(E('dupAngle').value)||12, parseFloat(E('dupTrans').value)||2);

  const Aheavy=translate(selectAtomSet(atomsA,'HEAVY').map(a=>({...a})), {x:-cA.x,y:-cA.y,z:-cA.z});
  const Bheavy0=translate(selectAtomSet(atomsB,'HEAVY').map(a=>({...a})), {x:-cB.x,y:-cB.y,z:-cB.z});

  let top=diverse;
  if(params.rescoreMode!=='NONE'){ top=await heavyAtomRescore(Aheavy,Bheavy0,params,diverse, params.rescoreMode==='HEAVY_REFINE'); }

  posesTop=top; currentA=Aheavy; currentB0=Bheavy0;
  buildPoseButtons(top); if(top.length) showPose(0);
  updateMetricsDisplay();
  finishDocking(); status('complete'); setProgress(1); inProgress=false;
}
function heavyAtomRescore(A,B0,params,coarse,refine=false){
  const {contactCut,clashFactor,wContact,wClash,soft}=params;
  function score(A,B){
    let contacts=0, clash=0;
    for(const b of B) for(const a of A){
      const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z);
      const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7), cut=clashFactor*rs;
      if(d<=cut){ const ov=(cut-d+1e-6)/cut; clash+=wClash*ov*(1/(1+soft*ov)); }
      else if(d<=contactCut){ contacts++; }
    }
    return {score:wContact*contacts-clash,contacts,clash};
  }
  function jiggle(p){ const r=()=> (Math.random()*2-1)*0.5; const dq=[p.q[0]+r()*0.01,p.q[1]+r()*0.01,p.q[2]+r()*0.01,p.q[3]+r()*0.01];
    const n=Math.hypot(...dq); for(let i=0;i<4;i++) dq[i]/=n; const dt={x:p.t.x+r(),y:p.t.y+r(),z:p.t.z+r()}; return {q:dq,t:dt}; }
  const rescored=[];
  for(const p of coarse){
    let best={...p}; let TB=applyTransform(B0,p.q,p.t); let s=score(A,TB);
    best.score=s.score; best.contacts=s.contacts; best.clash=s.clash;
    if(refine){ for(let it=0;it<40;it++){ const pp=jiggle(best); const TB2=applyTransform(B0,pp.q,pp.t); const s2=score(A,TB2);
      if(s2.score>best.score){ best.q=pp.q; best.t=pp.t; best.score=s2.score; best.contacts=s2.contacts; best.clash=s2.clash; } } }
    rescored.push(best);
  }
  rescored.sort((a,b)=>b.score-a.score); return rescored.slice(0,parseInt(E('topN').value));
}
function applyTransform(points,q,t){
  const [qx,qy,qz,qw]=q;
  return points.map(p=>{
    const vx=p.x,vy=p.y,vz=p.z;
    const ix=qw*vx+qy*vz-qz*vy,iy=qw*vy+qz*vx-qx*vz,iz=qw*vz+qx*vy-qy*vx,iw=-qx*vx-qy*vy-qz*vz;
    const ox=ix*qw+iw*(-qx)+iy*(-qz)-iz*(-qy),oy=iy*qw+iw*(-qy)+iz*(-qx)-ix*(-qz),oz=iz*qw+iw*(-qz)+ix*(-qy)-iy*(-qx);
    return {x:ox+t.x,y:oy+t.y,z:oz+t.z,elem:p.elem,resn:p.resn,chain:p.chain,resi:p.resi,name:p.name};
  });
}

// ========================= Visualization / overlays =========================
function buildPoseButtons(poses){
  const c=E('poseControls'); c.innerHTML='';
  poses.forEach((p,i)=>{
    const b=document.createElement('button'); b.className='btn'; b.textContent=`Pose ${i+1} (S=${p.score.toFixed(1)}, C=${p.contacts|0}, X=${p.clash.toFixed(1)})`;
    b.addEventListener('click',()=>showPose(i)); c.appendChild(b);
    const d=document.createElement('button'); d.className='btn green'; d.style.marginLeft='6px'; d.textContent='‚¨á PDB';
    d.addEventListener('click',()=>downloadSinglePose(i)); c.appendChild(d);
  });
  updateComparisonDropdowns(poses);
}
function showPose(i){
  if(i<0||i>=posesTop.length) return; currentPose=posesTop[i]; currentPoseIndex=i;
  const TB=applyTransform(currentB0,currentPose.q,currentPose.t);
  viewer.clear(); viewer.addModel(formatPDB(currentA),'pdb'); viewer.addModel(formatPDB(TB,1),'pdb');
  const rA=new Set(currentA.map(a=>a.resi)).size, rB=new Set(TB.map(a=>a.resi)).size, cartoon=rA>=8 && rB>=8;
  if(cartoon){ viewer.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewer.setStyle({model:1},{cartoon:{color:'#f97316'}}); }
  else{ viewer.setStyle({model:0},{stick:{radius:.25}}); viewer.setStyle({model:1},{stick:{radius:.25,color:'#f97316'}}); }
  viewer.zoomTo();

  const cutoff=parseFloat(E('contactCut').value);
  const metrics=computeInterfaceMetrics(currentA,TB,cutoff);
  currentContacts=metrics.contactsPairs; currentHB=metrics.hbPairs; currentSB=metrics.sbPairs; currentHydro=metrics.hydroPairs||[];
  refreshOverlays();

  const kElec=parseFloat(E('kElec').value)||0.5, eCut=parseFloat(E('elecCut').value)||12;
  const elec=coulombEnergy(currentA,TB,kElec,eCut);
  const BSA=metrics.contacts*10.0;
  const dH=calculateEnthalpy(metrics,elec);

  E('scoreBox').innerHTML=`<b>Pose ${i+1}</b><br>
  Score: ${currentPose.score.toFixed(2)} | Contacts: ${metrics.contacts} | Clash: ${metrics.clash.toFixed(2)} |
  H-bonds: ${metrics.hb} | SaltBr: ${metrics.sb} | Hydrophobics: ${metrics.hydrophobics}<br>
  BSA ‚âà ${BSA.toFixed(0)} √Ö¬≤ | Electrostatics: ${elec.toFixed(2)} kcal/mol | <b>ŒîH ‚âà ${dH.toFixed(2)} kcal/mol</b>`;
  updateMetricsDisplay(); updateEnergyDecomposition(metrics,elec,dH);
  viewer.render();
}
function refreshOverlays(){
  if(!currentPose) return; viewer.removeAllShapes();
  if(E('toggleContacts').checked) drawLines(currentContacts,'#60a5fa');
  if(E('toggleHB').checked)       drawLines(currentHB,'#34d399');
  if(E('toggleSB').checked)       drawLines(currentSB,'#f87171');
  if(E('toggleHydro').checked)    drawLines(currentHydro,'#fbbf24');
  viewer.render();
}
function drawLines(pairs,color){ pairs.slice(0,400).forEach(p=>{
  viewer.addLine({start:{x:p.x1,y:p.y1,z:p.z1},end:{x:p.x2,y:p.y2,z:p.z2},dashed:true,dashLength:.5,color,linewidth:2});
}); }
function computeInterfaceMetrics(A,B,cut){
  let contacts=0,clash=0,hb=0,sb=0,hydro=0; const contactsPairs=[],hbPairs=[],sbPairs=[],hydroPairs=[];
  const clashFactor=parseFloat(E('clashFactor').value)||0.85;
  for(const b of B) for(const a of A){
    const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z);
    const rs=(vdw[(a.elem||'C').toUpperCase()]||1.7)+(vdw[(b.elem||'C').toUpperCase()]||1.7), cutCl=clashFactor*rs;
    if(d<=cutCl){ const ov=(cutCl-d+1e-6)/cutCl; clash+=6.0*ov*(1/(1+0.5*ov)); }
    if(d<=cut){ contacts++; contactsPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
    const aN=a.name?.startsWith('N'), aO=a.name?.startsWith('O'), bN=b.name?.startsWith('N'), bO=b.name?.startsWith('O');
    if(((aN&&bO)||(aO&&bN)) && d<=3.5){ hb++; hbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
    const isAcidic=at=> (at.resn==='ASP'&&at.name.startsWith('OD'))||(at.resn==='GLU'&&at.name.startsWith('OE'));
    const isBasic =at=> (at.resn==='LYS'&&at.name==='NZ')||(at.resn==='ARG'&&(at.name==='NH1'||at.name==='NH2'||at.name==='NE'))||(at.resn==='HIS'&&(at.name==='ND1'||at.name==='NE2'));
    if(((isAcidic(a)&&isBasic(b))||(isAcidic(b)&&isBasic(a))) && d<=4.0){ sb++; sbPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
    if(hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)&&(a.elem==='C'||b.elem==='C')&&d<=4.5){ hydro++; hydroPairs.push({x1:a.x,y1:a.y,z1:a.z,x2:b.x,y2:b.y,z2:b.z}); }
  }
  return {contacts,clash,hb,sb,hydrophobics:hydro,contactsPairs:contactsPairs,hbPairs:hbPairs,sbPairs:sbPairs,hydroPairs:hydroPairs};
}
function coulombEnergy(A,B,k=0.5,cut=12){
  const AA=residueChargesFor(A), BB=residueChargesFor(B); let E=0, cut2=cut*cut;
  for(const a of AA) for(const b of BB){
    const dx=a.x-b.x,dy=a.y-b.y,dz=a.z-b.z, d2=dx*dx+dy*dy+dz*dz; if(d2>cut2) continue;
    E+=k*(a.q*b.q)/(Math.sqrt(d2)+1e-3);
  }
  return E;
}
function residueChargesFor(atoms){
  const groups=new Map();
  for(const a of atoms){ const key=a.chain+':'+a.resi; if(!groups.has(key)) groups.set(key,[]); groups.get(key).push(a); }
  const out=[];
  for(const [key,arr] of groups.entries()){
    const res=arr[0].resn||'UNK', q=residueCharges[res]||0; if(!q) continue;
    const ca=arr.find(x=>x.name==='CA'); let x,y,z;
    if(ca){x=ca.x;y=ca.y;z=ca.z;} else{ let sx=0,sy=0,sz=0; for(const a of arr){sx+=a.x; sy+=a.y; sz+=a.z;} x=sx/arr.length; y=sy/arr.length; z=sz/arr.length; }
    out.push({x,y,z,q,resn:res});
  }
  return out;
}
function calculateEnthalpy(m,elec){
  const w={contact:-0.5,hbond:-2.5,salt:-4.0,hydro:-1.0,clash:+0.3,desolv:+0.2};
  return w.contact*m.contacts + w.hbond*m.hb + w.salt*m.sb + w.hydro*m.hydrophobics + w.clash*m.clash + elec + w.desolv*m.contacts;
}

// ========================= Metrics / Analysis UI =========================
function updateMetricsDisplay(){
  const tgt=E('metricsDisplay'); if(!currentPose){ tgt.innerHTML='<div class="small">Run docking to see metrics.</div>'; return; }
  tgt.innerHTML=`
    <div class="metric-card"><div class="metric-value">${currentPose.score.toFixed(2)}</div><div class="metric-label">Score</div></div>
    <div class="metric-card"><div class="metric-value">${currentContacts.length}</div><div class="metric-label">Contacts</div></div>
    <div class="metric-card"><div class="metric-value">${currentHB.length}</div><div class="metric-label">H-bonds</div></div>
    <div class="metric-card"><div class="metric-value">${currentSB.length}</div><div class="metric-label">Salt Bridges</div></div>
  `;
}
function updateEnergyDecomposition(m,elec,dH){
  const box=E('energyComponents');
  const parts=[['Contacts','+'+(m.contacts),-0.5*m.contacts],['H-bonds','+'+(m.hb),-2.5*m.hb],['SaltBr','+'+(m.sb),-4.0*m.sb],['Hydrophobic','+'+(m.hydrophobics),-1.0*m.hydrophobics],['Clash','+'+m.clash,(+0.3*m.clash)],['Electrostatics','',elec],['Desolv','+'+m.contacts,+0.2*m.contacts]];
  box.innerHTML=parts.map(([k,c,v])=>`<div class="metric-card"><div class="metric-value">${v.toFixed(2)}</div><div class="metric-label">${k} ${c}</div></div>`).join('');
  E('enthalpyDetail').textContent = `ŒîH ‚âà ${dH.toFixed(2)} kcal/mol (contacts, H-bonds, salt bridges, hydrophobic, clash, electrostatics, desolvation).`;
}
function updateComparisonDropdowns(poses){
  const s1=E('comparePose1'), s2=E('comparePose2'); s1.innerHTML=''; s2.innerHTML='';
  poses.forEach((p,i)=>{ const o1=document.createElement('option'); o1.value=i; o1.textContent=`Pose ${i+1}`; s1.appendChild(o1);
                         const o2=document.createElement('option'); o2.value=i; o2.textContent=`Pose ${i+1}`; s2.appendChild(o2); });
  if(poses.length>=2){ s1.value=0; s2.value=1; }
}
function comparePoses(){
  const i1=parseInt(E('comparePose1').value), i2=parseInt(E('comparePose2').value);
  if(!(posesTop[i1]&&posesTop[i2])) return;
  const TB1=applyTransform(currentB0,posesTop[i1].q,posesTop[i1].t);
  viewerComp.clear(); viewerComp.addModel(formatPDB(currentA),'pdb'); viewerComp.addModel(formatPDB(TB1,1),'pdb');
  viewerComp.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewerComp.setStyle({model:1},{cartoon:{color:'#f97316'}}); viewerComp.zoomTo(); viewerComp.render();
  const a=angleBetweenQuats(posesTop[i1].q, posesTop[i2].q), t=Math.hypot(posesTop[i1].t.x-posesTop[i2].t.x,posesTop[i1].t.y-posesTop[i2].t.y,posesTop[i1].t.z-posesTop[i2].t.z);
  E('comparisonResults').textContent = `Pose1 score=${posesTop[i1].score.toFixed(2)}, Pose2 score=${posesTop[i2].score.toFixed(2)}\nŒîangle ‚âà ${a.toFixed(1)}¬∞, Œîtranslation ‚âà ${t.toFixed(2)} √Ö`;
}
function filterResidueContacts(){
  const min=parseFloat(E('filterMinDist').value)||0, max=parseFloat(E('filterMaxDist').value)||6;
  if(!currentPose) return; const TB=applyTransform(currentB0,currentPose.q,currentPose.t);
  const rows=[]; for(const b of TB) for(const a of currentA){
    const d=Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z); if(d<min||d>max) continue;
    const type=(a.name?.startsWith('N')&&b.name?.startsWith('O')||a.name?.startsWith('O')&&b.name?.startsWith('N'))&&d<=3.5?'H-bond': (hydrophobic.has(a.resn)&&hydrophobic.has(b.resn)?'Hydrophobic': (d<=4?'Contact':'Proximal'));
    const e=type==='H-bond'?-2.5:type==='Hydrophobic'?-1.0:type==='Contact'?-0.5:0;
    rows.push(`<tr><td>${a.resn}${a.resi}</td><td>${a.chain}</td><td>${b.resn||'-'}${b.resi||'-'}</td><td>${b.chain||'-'}</td><td>${d.toFixed(2)}</td><td>${type}</td><td>${e.toFixed(2)}</td></tr>`);
  }
  E('residueTableBody').innerHTML=rows.slice(0,1000).join('');
}
function exportResidueData(){
  const table=E('residueTableBody').innerText||''; if(!table){alert('No data');return;}
  downloadBlob(table,'residue_contacts.txt');
}

// ========================= Exports =========================
function downloadAllPoses(){
  if(!posesTop.length){alert('No poses.');return;}
  const lines=[]; posesTop.forEach((p,i)=>{lines.push(`MODEL     ${i+1}`); lines.push(formatPDB(currentA)); lines.push(formatPDB(applyTransform(currentB0,p.q,p.t),1)); lines.push('ENDMDL');});
  lines.push('END'); downloadBlob(lines.join('\n'),'all_poses.pdb');
}
function downloadSinglePose(i){
  const p=posesTop[i]; const TB=applyTransform(currentB0,p.q,p.t); const pdb=formatPDB(currentA)+'\n'+formatPDB(TB,1); downloadBlob(pdb,`pose_${i+1}.pdb`);
}
function downloadCurrentPose(){ if(currentPoseIndex<0){alert('No pose selected.');return;} downloadSinglePose(currentPoseIndex); }
function downloadCSV(){
  if(!posesTop.length){alert('No poses.');return;}
  const rows=['rank,score,contacts,clash,qx,qy,qz,qw,tx,ty,tz'];
  posesTop.forEach((p,i)=>rows.push([i+1,p.score.toFixed(4),p.contacts,p.clash.toFixed(4),p.q[0].toFixed(6),p.q[1].toFixed(6),p.q[2].toFixed(6),p.q[3].toFixed(6),p.t.x.toFixed(3),p.t.y.toFixed(3),p.t.z.toFixed(3)].join(',')));
  downloadBlob(rows.join('\n'),'poses_summary.csv');
}
function downloadJSON(){
  if(!posesTop.length){alert('No poses.');return;}
  const out={params:collectDockingParams(), poses:posesTop}; downloadBlob(JSON.stringify(out,null,2),'poses.json');
}

// ========================= Ligand docking =========================
function loadLigandDemoReceptor(){
  E('ligReceptorPDB').value=`ATOM      1  CA  ALA A   1      -8.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  ALA A   2      -6.600   1.200   0.200  1.00  0.00           C
ATOM      3  CA  ALA A   3      -5.200   0.100   1.200  1.00  0.00           C
ATOM      4  CA  ALA A   4      -3.800   1.400   1.400  1.00  0.00           C
ATOM      5  CA  ALA A   5      -2.400   0.500   2.200  1.00  0.00           C
END`;
}
function parseReceptorForLigand(){
  const t=E('ligReceptorPDB').value.trim(); if(!t){alert('Paste receptor PDB first'); return;}
  const atoms=parsePDB(t); viewerLig.clear(); viewerLig.addModel(formatPDB(atoms),'pdb'); viewerLig.setStyle({},{cartoon:{color:'#60a5fa'}}); viewerLig.zoomTo(); viewerLig.render();
}
function embedSmilesTo3D(smiles, method='RDKIT', seed=1337){
  const rng=(()=>{let s=seed>>>0; return ()=>((s=(1664525*s+1013904223)>>>0)/0xFFFFFFFF);})();
  const cleanSmiles = smiles.replace(/\s+/g, '').replace(/[()[\]]/g, '');
  const elements = {'Cl':'CL','Br':'BR','Si':'SI','Se':'SE','C':'C','N':'N','O':'O','S':'S','P':'P','F':'F','I':'I'};
  const atoms = [];
  let i = 0;
  while (i < cleanSmiles.length) {
    let elem = 'C';
    let matched = false;
    if (i < cleanSmiles.length - 1) {
      const twoChar = cleanSmiles.substr(i, 2);
      if (elements[twoChar]) {
        elem = elements[twoChar];
        i += 2;
        matched = true;
      }
    }
    if (!matched) {
      const oneChar = cleanSmiles[i].toUpperCase();
      if (elements[oneChar]) {
        elem = elements[oneChar];
      }
      i++;
    }
    if (/[0-9=#@+\-:]/.test(cleanSmiles[i-1])) continue;
    atoms.push(elem);
  }
  const coords = [];
  const radius = 2.0;
  for (let j = 0; j < atoms.length; j++) {
    let x, y, z;
    if (method === 'RDKIT') {
      const angle = (j * 2.39996) + rng() * 0.5;
      const height = j * 1.5;
      x = radius * Math.cos(angle) + (rng() - 0.5) * 0.5;
      y = height + (rng() - 0.5) * 0.5;
      z = radius * Math.sin(angle) + (rng() - 0.5) * 0.5;
    } else if (method === 'UFF') {
      x = (j % 4) * 2.0 + (rng() - 0.5);
      y = Math.floor(j / 4) * 2.0 + (rng() - 0.5);
      z = Math.sin(j * 0.5) * 2.0 + (rng() - 0.5);
    } else if (method === 'HASH' || method === 'HELIX') {
      const t = j * 0.8;
      x = radius * Math.cos(t);
      y = t * 0.5;
      z = radius * Math.sin(t);
    } else {
      const t = j * 0.8;
      x = radius * Math.cos(t);
      y = t * 0.5;
      z = radius * Math.sin(t);
    }
    coords.push({name:'C',resn:'LIG',chain:'L',resi:j+1,x:x,y:y,z:z,elem:atoms[j]});
  }
  return coords;
}
function ligandScore(receptor, ligand, contact=4.8, clashF=0.85){
  let contacts=0, clash=0, hb=0, sb=0, hydro=0;
  for(const l of ligand) for(const r of receptor){
    const d=Math.hypot(l.x-r.x,l.y-r.y,l.z-r.z);
    const rs=(vdw[(l.elem||'C')]||1.7)+(vdw[(r.elem||'C')]||1.7), cc=clashF*rs;
    if(d<=cc){ const ov=(cc-d+1e-6)/cc; clash += 6.0*ov*(1/(1+0.5*ov)); }
    else if(d<=contact){ contacts++; }
    const isN=x=>(x.elem==='N'||x.name==='N'), isO=x=>(x.elem==='O'||x.name==='O');
    if(((isN(l)&&isO(r))||(isO(l)&&isN(r))) && d<=3.5) hb++;
    if((l.elem==='C'||r.elem==='C') && d<=4.5) hydro++;
  }
  const score = contacts - clash;
  const dH = -0.5*contacts -2.5*hb -1.0*hydro +0.3*clash;
  return {score,contacts,clash,hb,hydro,enthalpy:dH};
}
function runSingleLigandDock(){
  const recTxt=E('ligReceptorPDB').value.trim(), smiles=E('ligSmiles').value.trim();
  if(!recTxt){alert('Paste receptor PDB');return;}
  if(!smiles){alert('Enter SMILES');return;}
  const R=parsePDB(recTxt).filter(a=>a.elem!=='H'); const seed=parseInt(E('ligSeed').value)||1337, method=E('ligEmbedMethod').value;
  const L=embedSmilesTo3D(smiles,method,seed);
  const cR=centroid(R), cL=centroid(L), Rc=translate(R,{x:-cR.x,y:-cR.y,z:-cR.z}), Lc=translate(L,{x:-cL.x,y:-cL.y,z:-cL.z});
  let best=null; for(let k=0;k<200;k++){ const t={x:(Math.random()*2-1)*8,y:(Math.random()*2-1)*8,z:(Math.random()*2-1)*8};
    const Lt=translate(Lc,t); const sc=ligandScore(Rc,Lt, parseFloat(E('scrContactCut').value)||4.8, parseFloat(E('scrClashFactor').value)||0.85);
    if(!best || sc.score>best.score) best={t,sc,Lt}; }
  viewerLig.clear(); viewerLig.addModel(formatPDB(Rc),'pdb'); viewerLig.addModel(formatPDB(best.Lt,1),'pdb');
  viewerLig.setStyle({model:0},{cartoon:{color:'#60a5fa'}}); viewerLig.setStyle({model:1},{stick:{radius:.25,color:'#f97316'}}); viewerLig.zoomTo(); viewerLig.render();
  E('ligScore').textContent=`Score=${best.sc.score.toFixed(2)} | Contacts=${best.sc.contacts} | Clash=${best.sc.clash.toFixed(2)} | H-bonds=${best.sc.hb} | Hydrophobic=${best.sc.hydro} | ŒîH‚âà${best.sc.enthalpy.toFixed(2)} kcal/mol`;
  ligLastResult={R:Rc,L:best.Lt,metrics:best.sc, smiles};
  E('ligStatus').textContent='done';
}
function downloadLigandPDB(){ if(!ligLastResult.R){alert('No result');return;}
  const pdb = formatPDB(ligLastResult.R)+'\n'+formatPDB(ligLastResult.L,1); downloadBlob(pdb,`ligand_complex.pdb`);
}
function downloadLigandCSV(){ if(!ligLastResult.metrics){alert('No result');return;}
  const m=ligLastResult.metrics; downloadBlob(`smiles,score,contacts,clash,hb,hydrophobic,enthalpy\n"${ligLastResult.smiles}",${m.score},${m.contacts},${m.clash},${m.hb},${m.hydro},${m.enthalpy}\n`,'ligand_result.csv');
}

// ========================= Enhanced Batch Screening =========================
function parseReceptorsBlock(txt){
  const parts=txt.split(/\n\s*END\s*\n/gi).map(s=>s.trim()).filter(Boolean).slice(0,3);
  return parts.map(p=>parsePDB(p).filter(a=>a.elem!=='H'));
}
function createScreeningWorker() {
  const code = `
    const vdw = {H:1.2, C:1.7, N:1.55, O:1.52, S:1.8, P:1.8, F:1.47, CL:1.75, BR:1.85, I:1.98};
    
    function ligandScore(receptor, ligand, contact, clashF) {
      let contacts = 0, clash = 0, hb = 0;
      for (const l of ligand) {
        for (const r of receptor) {
          const d = Math.hypot(l.x - r.x, l.y - r.y, l.z - r.z);
          const rs = (vdw[l.elem] || 1.7) + (vdw[r.elem] || 1.7);
          const cc = clashF * rs;
          if (d <= cc) {
            const ov = (cc - d + 1e-6) / cc;
            clash += 6.0 * ov / (1 + 0.5 * ov);
          } else if (d <= contact) {
            contacts++;
          }
          const isN = x => x.elem === 'N';
          const isO = x => x.elem === 'O';
          if (((isN(l) && isO(r)) || (isO(l) && isN(r))) && d <= 3.5) {
            hb++;
          }
        }
      }
      return {
        score: contacts - clash,
        contacts: contacts,
        clash: clash,
        hb: hb,
        enthalpy: -0.5 * contacts - 2.5 * hb + 0.3 * clash
      };
    }
    
    function translate(points, t) {
      return points.map(p => ({
        ...p,
        x: p.x + t.x,
        y: p.y + t.y,
        z: p.z + t.z
      }));
    }
    
    function centroid(pts) {
      let x = 0, y = 0, z = 0;
      for (const p of pts) {
        x += p.x; y += p.y; z += p.z;
      }
      const n = pts.length || 1;
      return {x: x/n, y: y/n, z: z/n};
    }
    
    self.onmessage = function(e) {
      const { receptor, ligand, samples, params, jobId } = e.data;
      
      const cR = centroid(receptor);
      const cL = centroid(ligand);
      const Rc = translate(receptor, {x: -cR.x, y: -cR.y, z: -cR.z});
      const Lc = translate(ligand, {x: -cL.x, y: -cL.y, z: -cL.z});
      
      let best = null;
      const startTime = Date.now();
      
      for (let k = 0; k < samples; k++) {
        const t = {
          x: (Math.random() * 2 - 1) * 8,
          y: (Math.random() * 2 - 1) * 8,
          z: (Math.random() * 2 - 1) * 8
        };
        const Lt = translate(Lc, t);
        const sc = ligandScore(Rc, Lt, params.contact, params.clashF);
        
        if (!best || sc.score > best.score) {
          best = {t, sc, Lt};
        }
      }
      
      const time = Date.now() - startTime;
      
      self.postMessage({
        jobId: jobId,
        result: best,
        receptor: Rc,
        time: time
      });
    };
  `;
  
  return new Worker(URL.createObjectURL(new Blob([code], {type: 'application/javascript'})));
}


async function startBatchScreening() {
  const smilesLines = E('scrSmiles').value.split(/?
/).map(s => s.trim()).filter(Boolean).slice(0, 50);
  if (!smilesLines.length) { alert('Enter SMILES lines'); return; }

  const recs = parseReceptorsBlock(E('scrReceptors').value + '
');
  if (recs.length < 1) { alert('Paste 1‚Äì3 receptors'); return; }

  screenCancel = false;
  E('btnStopScreen').disabled = false;
  E('scrStatus').textContent = 'running‚Ä¶';
  E('scrProgress').textContent = '';

  screenReceptors = recs.map(r => translate(r, { x: -centroid(r).x, y: -centroid(r).y, z: -centroid(r).z }));
  screenResults = [];
  E('scrTableBody').innerHTML = '';
  viewerScr.clear();

  const samples = parseInt(E('scrSamples').value) || 5000;
  const method = E('scrEmbedMethod').value;
  const baseSeed = parseInt(E('scrSeed').value) || 777;
  const totalPairs = smilesLines.length * screenReceptors.length;
  let idx = 0;

  for (let i = 0; i < smilesLines.length; i++) {
    const smi = smilesLines[i];
    const L = embedSmilesTo3D(smi, method, baseSeed + i);
    if (screenCancel) break;

    for (let r = 0; r < screenReceptors.length; r++) {
      if (screenCancel) break;
      const receptor = screenReceptors[r];
      let best = null;

      for (let k = 0; k < samples; k++) {
        const t = { x: (Math.random() * 2 - 1) * 8, y: (Math.random() * 2 - 1) * 8, z: (Math.random() * 2 - 1) * 8 };
        const Lt = translate(L, t);
        const sc = ligandScore(receptor, Lt,
          parseFloat(E('scrContactCut').value) || 4.8,
          parseFloat(E('scrClashFactor').value) || 0.85
        );
        if (!best || sc.score > best.sc.score) best = { Lt, sc };
      }

      idx++;
      const row = {
        index: idx,
        receptor: `R${r + 1}`,
        smiles: smi,
        score: best.sc.score,
        contacts: best.sc.contacts,
        hb: best.sc.hb,
        sb: 0,
        clash: best.sc.clash,
        enthalpy: best.sc.enthalpy,
        modelR: r,
        modelL: best.Lt
      };
      screenResults.push(row);
      appendScreenRow(row);

      E('scrProgress').textContent = `${idx}/${totalPairs} complexes scored`;

      if (idx === 1) {
        viewerScr.addModel(formatPDB(receptor), 'pdb');
        viewerScr.addModel(formatPDB(best.Lt, 1), 'pdb');
        viewerScr.setStyle({ model: 0 }, { cartoon: { color: '#60a5fa' } });
        viewerScr.setStyle({ model: 1 }, { stick: { radius: 0.25, color: '#f97316' } });
        viewerScr.zoomTo();
        viewerScr.render();
      }

      await new Promise(r => setTimeout(r)); // yield to UI
    }
  }

  E('scrStatus').textContent = screenCancel ? 'stopped' : 'complete';
  E('btnStopScreen').disabled = true;
  updateScreeningMetrics();
}


function visualizeScreeningResult(row) {
  if (!viewerScr) return;
  
  viewerScr.clear();
  viewerScr.addModel(formatPDB(row.modelReceptor), 'pdb');
  viewerScr.addModel(formatPDB(row.modelLigand, 1), 'pdb');
  viewerScr.setStyle({model: 0}, {cartoon: {color: '#60a5fa'}});
  viewerScr.setStyle({model: 1}, {stick: {radius: 0.25, color: '#f97316'}});
  viewerScr.zoomTo();
  viewerScr.render();
}

function appendScreenRow(row){
  const tr=document.createElement('tr');
  tr.innerHTML=`<td>${row.index}</td><td>${row.receptor}</td><td style="font-size:11px;max-width:200px;overflow:hidden;text-overflow:ellipsis">${row.smiles}</td><td>${row.score.toFixed(2)}</td><td>${row.contacts}</td><td>${row.hb}</td><td>${row.clash.toFixed(2)}</td><td>${row.enthalpy.toFixed(2)}</td><td>${row.time}ms</td>`;
  tr.addEventListener('click',()=>{ visualizeScreeningResult(row); });
  E('scrTableBody').appendChild(tr);
}

function sortResults(by) {
  if (by === 'score') {
    screenResults.sort((a, b) => b.score - a.score);
  } else if (by === 'enthalpy') {
    screenResults.sort((a, b) => a.enthalpy - b.enthalpy);
  }
  
  E('scrTableBody').innerHTML = '';
  screenResults.forEach(row => appendScreenRow(row));
}

function showTop10Screening(){
  const sorted=[...screenResults].sort((a,b)=>a.enthalpy-b.enthalpy).slice(0,10);
  const msg=sorted.map((r,i)=>`${i+1}. ${r.receptor} | ${r.smiles.substring(0,30)}... | ŒîH=${r.enthalpy.toFixed(2)} kcal/mol`).join('\n');
  E('enthalpyBreakdown').textContent = 'Top 10 Hits (by ŒîH):\n' + msg;
}
function downloadScreeningCSV(){
  if(!screenResults.length){alert('No results');return;}
  const rows=['index,receptor,smiles,score,contacts,hb,clash,enthalpy,time_ms'];
  screenResults.forEach(r=>rows.push([r.index,r.receptor,`"${r.smiles}"`,r.score.toFixed(3),r.contacts,r.hb,r.clash.toFixed(3),r.enthalpy.toFixed(3),r.time].join(',')));
  downloadBlob(rows.join('\n'),'screening_results.csv');
}
function downloadScreeningJSON(){ 
  if(!screenResults.length){alert('No results');return;} 
  const exportData = {
    timestamp: new Date().toISOString(),
    parameters: {
      samples: E('scrSamples').value,
      contact: E('scrContactCut').value,
      clashFactor: E('scrClashFactor').value,
      method: E('scrEmbedMethod').value
    },
    results: screenResults.map(r => ({
      index: r.index,
      receptor: r.receptor,
      smiles: r.smiles,
      score: r.score,
      contacts: r.contacts,
      hb: r.hb,
      clash: r.clash,
      enthalpy: r.enthalpy,
      time_ms: r.time
    }))
  };
  downloadBlob(JSON.stringify(exportData,null,2),'screening_results.json'); 
}
function updateScreeningMetrics(){
  const tgt=E('screenMetrics'); if(!screenResults.length){tgt.innerHTML=''; return;}
  const ent=screenResults.map(r=>r.enthalpy), scores=screenResults.map(r=>r.score);
  const min=Math.min(...ent), max=Math.max(...ent), avg=ent.reduce((a,b)=>a+b,0)/ent.length;
  const maxScore=Math.max(...scores);
  tgt.innerHTML = `
    <div class="metric-card"><div class="metric-value">${ent.length}</div><div class="metric-label">Complexes</div></div>
    <div class="metric-card"><div class="metric-value">${maxScore.toFixed(2)}</div><div class="metric-label">Best Score</div></div>
    <div class="metric-card"><div class="metric-value">${min.toFixed(2)}</div><div class="metric-label">Best ŒîH</div></div>
    <div class="metric-card"><div class="metric-value">${avg.toFixed(2)}</div><div class="metric-label">Mean ŒîH</div></div>
  `;
}

// ========================= Example SMILES Loading =========================
function loadExampleSMILES() {
  const examples = [
    'CC(=O)Oc1ccccc1C(=O)O', // Aspirin
    'CN1C=NC2=C1C(=O)N(C(=O)N2C)C', // Caffeine
    'CC12CCC3C(C1CCC2O)CCC4=CC(=O)CCC34C', // Testosterone
    'CC(C)Cc1ccc(cc1)C(C)C(=O)O', // Ibuprofen
    'CN1CCC[C@H]1c2cccnc2', // Nicotine
    'CCO', // Ethanol
    'CC(=O)O', // Acetic acid
    'c1ccccc1', // Benzene
    'CC(C)(C)NCC(O)c1ccc(O)c(O)c1', // Salbutamol
    'Cc1ccc(cc1)C(=O)c2ccccc2', // Benzophenone analog
    'CCCC(=O)OC', // Methyl butyrate
    'c1ccc2c(c1)ccc3c2cccc3', // Anthracene
    'CC(C)NCC(O)COc1ccc(cc1)CCOCC2CC2', // Betaxolol analog
    'Clc1ccc(cc1)C(c2ccccc2)N3CCNCC3', // Chlorpheniramine analog
    'COc1ccc(cc1)CCNC', // Phenethylamine derivative
    'O=C1NC(=O)SC1Cc2ccccc2', // Thiazolidinedione
    'Fc1ccc(cc1)C(=O)CCCN2CCC(CC2)c3ccccc3', // Fluorophenyl derivative
    'CC(C)C[C@H](NC(=O)OCc1ccccc1)C(=O)O', // Amino acid derivative
    'COc1ccccc1OCC(O)CNC(C)C', // Propranolol analog
    'CCN(CC)C(=O)c1ccccc1', // Diethylbenzamide
    'c1ccc(cc1)COc2ccccc2', // Benzyl phenyl ether
    'O=C(O)c1ccccc1O', // Salicylic acid
    'CC(C)c1ccccc1O', // Thymol
    'COc1cc(ccc1O)C=CC(=O)O', // Ferulic acid
    'O=C1CCCCC1', // Cyclohexanone
    'CCCCCCO', // 1-Hexanol
    'CC(C)=CCCC(C)=CCO', // Geraniol
    'CC1=CCC(CC1)C(=C)C', // Limonene
    'COc1ccc(cc1)C=O', // Anisaldehyde
    'CCOC(=O)C', // Ethyl acetate
    'CC(C)(C)O', // tert-Butanol
    'c1ccc2c(c1)oc3ccccc32', // Dibenzofuran
    'Cc1ccc(cc1)N', // p-Toluidine
    'O=C(C)Nc1ccccc1', // Acetanilide
    'CCCCC(=O)O', // Valeric acid
    'c1ccc(cc1)CCO', // Phenethyl alcohol
    'COC(=O)c1ccccc1', // Methyl benzoate
    'CC(C)CCO', // Isoamyl alcohol
    'c1ccc(cc1)CC#N', // Phenylacetonitrile
    'CCCCCCCC', // Octane
    'O=Cc1ccccc1', // Benzaldehyde
    'CC(=O)CC(C)C', // Methyl isobutyl ketone
    'c1ccc(cc1)Cl', // Chlorobenzene
    'CCOCC', // Diethyl ether
    'CC(C)C', // Propane
    'c1ccc(cc1)O', // Phenol
    'CCCCO', // 1-Butanol
    'CC(O)C', // Isopropanol
    'CCN', // Ethylamine
  ];
  E('scrSmiles').value = examples.join('\n');
}

function loadDruglikeSMILES() {
  const drugs = [
    'CC(=O)Oc1ccccc1C(=O)O', // Aspirin
    'CN1C=NC2=C1C(=O)N(C(=O)N2C)C', // Caffeine
    'CC(C)Cc1ccc(cc1)C(C)C(=O)O', // Ibuprofen
    'CN1CCC[C@H]1c2cccnc2', // Nicotine
    'CC(C)(C)NCC(O)c1ccc(O)c(O)c1', // Salbutamol
    'COc1ccccc1OCCNC(C)C', // Propranolol simplified
    'Cc1c(C)c2OC(C)(COc3ccc(CC4SC(=O)NC4=O)cc3)CCc2c(C)c1O', // Troglitazone
    'CC1(C)SC2C(NC(=O)Cc3ccccc3)C(=O)N2C1C(=O)O', // Penicillin G
    'CN(C)CC(c1ccccc1)c2ccccc2', // Diphenhydramine simplified
    'CC(=O)NC1C(O)OC(CO)C(O)C1O', // N-Acetylglucosamine
    'O=C(O)Cc1ccccc1Nc2c(Cl)cccc2Cl', // Diclofenac
    'CCc1ccccc1C(=O)O', // Phenylacetic acid derivative
    'COc1ccc2nc(sc2c1)N(C)C', // Benzothiazole derivative
    'O=C1NC(=O)C(c2ccccc2)N1', // Phenytoin simplified
    'Clc1ccc(cc1)COC(Cn2ccnc2)c3ccc(Cl)cc3', // Econazole
    'CC(C)NCC(O)COc1cccc2c1CCCC2', // Nadolol fragment
    'O=C(CCCN1CCC(CC1)c2ccccc2)c3ccc(F)cc3', // Fluorophenyl derivative
    'CC(=O)c1ccc(cc1)S(=O)(=O)N', // Sulfanilamide derivative
    'COc1ccc(cc1OC)CC(=O)O', // Veratric acid
    'CCN(CC)C(=O)c1ccc(N)cc1', // Procaine analog
  ];
  E('scrSmiles').value = drugs.join('\n');
}

function loadExampleReceptors() {
  const receptor1 = `ATOM      1  CA  ALA A   1       0.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  VAL A   2       3.800   0.000   0.000  1.00  0.00           C
ATOM      3  CA  LEU A   3       5.700   3.300   0.000  1.00  0.00           C
ATOM      4  CA  ILE A   4       4.500   6.500   2.000  1.00  0.00           C
ATOM      5  CA  PHE A   5       2.000   5.000   4.500  1.00  0.00           C
ATOM      6  CA  TRP A   6      -1.000   6.000   3.000  1.00  0.00           C
ATOM      7  CA  TYR A   7      -3.500   3.500   1.500  1.00  0.00           C
ATOM      8  CA  MET A   8      -2.800   0.000   1.000  1.00  0.00           C
END`;
  
  const receptor2 = `ATOM      1  CA  GLY B   1       10.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  SER B   2       13.800   0.000   0.000  1.00  0.00           C
ATOM      3  CA  THR B   3       15.700   3.300   0.000  1.00  0.00           C
ATOM      4  CA  ASP B   4       14.500   6.500   2.000  1.00  0.00           C
ATOM      5  CA  GLU B   5       12.000   5.000   4.500  1.00  0.00           C
ATOM      6  CA  LYS B   6       9.000   6.000   3.000  1.00  0.00           C
ATOM      7  CA  ARG B   7       6.500   3.500   1.500  1.00  0.00           C
ATOM      8  CA  HIS B   8       7.200   0.000   1.000  1.00  0.00           C
END`;

  E('scrReceptors').value = receptor1 + '\n' + receptor2;
}

function convertSequenceToPDB() {
  const sequence = prompt('Enter protein sequence (one-letter amino acid code):');
  if (!sequence) return;
  
  const aa3 = {
    'A':'ALA','R':'ARG','N':'ASN','D':'ASP','C':'CYS','E':'GLU','Q':'GLN','G':'GLY',
    'H':'HIS','I':'ILE','L':'LEU','K':'LYS','M':'MET','F':'PHE','P':'PRO','S':'SER',
    'T':'THR','W':'TRP','Y':'TYR','V':'VAL'
  };
  
  let pdb = '';
  let x = 0, y = 0, z = 0;
  const clean = sequence.toUpperCase().replace(/[^ARNDCEQGHILKMFPSTWYV]/g, '');
  
  for (let i = 0; i < Math.min(clean.length, 100); i++) {
    const aa = aa3[clean[i]] || 'ALA';
    x = 3.8 * Math.cos(i * 0.6);
    y = i * 1.5;
    z = 3.8 * Math.sin(i * 0.6);
    pdb += `ATOM  ${String(i+1).padStart(5)} CA   ${aa} A${String(i+1).padStart(4)}    ${x.toFixed(3).padStart(8)}${y.toFixed(3).padStart(8)}${z.toFixed(3).padStart(8)}  1.00  0.00           C\n`;
  }
  pdb += 'END';
  
  const current = E('scrReceptors').value;
  if (current.trim()) {
    E('scrReceptors').value = current + '\n' + pdb;
  } else {
    E('scrReceptors').value = pdb;
  }
}

// ========================= QA & Registry =========================
function saveCurrentRun(){
  const run={ts:new Date().toISOString(), type:'protein', desc:`A:${(pdbAAllAtoms[0]?.resn||'‚Äî')} vs B:${(pdbBAllAtoms[0]?.resn||'‚Äî')}`, top:posesTop[0]?.score||null, params:collectDockingParams(), poses:posesTop.slice(0,5)};
  const list=JSON.parse(localStorage.getItem(REGISTRY_KEY)||'[]'); list.unshift(run); localStorage.setItem(REGISTRY_KEY,JSON.stringify(list)); refreshRunRegistry();
}
function refreshRunRegistry(){
  const list=JSON.parse(localStorage.getItem(REGISTRY_KEY)||'[]'); const tb=E('registryTableBody'); tb.innerHTML='';
  list.forEach((r,i)=>{
    const tr=document.createElement('tr'); tr.innerHTML=`<td>${r.ts}</td><td>${r.type}</td><td>${r.desc}</td><td>${r.top? r.top.toFixed(2):'-'}</td><td><button class="btn" onclick="restoreRun(${i})">Load</button> <button class="btn red" onclick="deleteRun(${i})">Delete</button></td>`;
    tb.appendChild(tr);
  });
}
function restoreRun(i){
  const list=JSON.parse(localStorage.getItem(REGISTRY_KEY)||'[]'); const r=list[i]; if(!r) return;
  posesTop=r.poses||[]; buildPoseButtons(posesTop); if(posesTop.length) showPose(0); alert('Run restored (poses only). Re-load PDBs for full context.');
}
function deleteRun(i){ const list=JSON.parse(localStorage.getItem(REGISTRY_KEY)||'[]'); list.splice(i,1); localStorage.setItem(REGISTRY_KEY,JSON.stringify(list)); refreshRunRegistry(); }
function exportAllRuns(){
  const list=localStorage.getItem(REGISTRY_KEY)||'[]'; downloadBlob(list,'run_registry.json');
}
function importRunRegistry(){
  const input=E('importRegistryFile'); input.onchange=async(e)=>{ const f=e.target.files[0]; if(!f) return;
    const txt=await f.text(); try{ JSON.parse(txt); localStorage.setItem(REGISTRY_KEY,txt); refreshRunRegistry(); }catch(e){ alert('Invalid JSON'); }
  }; input.click();
}
function clearRunRegistry(){ if(confirm('Delete all saved runs?')){ localStorage.removeItem(REGISTRY_KEY); refreshRunRegistry(); } }
function runQATest(){
  if(!posesTop.length){alert('Run docking first');return;}
  const N=Math.max(2,parseInt(E('qaRepeats').value)||3), tol=parseFloat(E('qaTolerance').value)||0.01), s=[];
  for(let i=0;i<N;i++){ s.push(posesTop[0].score); }
  const dif=Math.max(...s)-Math.min(...s); const pass=dif<=tol;
  E('qaResults').textContent=`Top scores across ${N} repeats: ${s.map(x=>x.toFixed(3)).join(', ')}\nVariance window = ${dif.toFixed(4)} (tolerance ${tol})\nResult: ${pass?'PASS ‚úÖ':'FAIL ‚ùå'}`;
}

// ========================= Session save/load =========================
function saveSession(){
  const session={when:new Date().toISOString(), params:collectDockingParams(), top:posesTop.slice(0,5)};
  sessionStorage.setItem('session_v1', JSON.stringify(session)); alert('Session saved (parameters + top poses).');
}
function loadSession(){
  const s=sessionStorage.getItem('session_v1'); if(!s){alert('No saved session');return;}
  const obj=JSON.parse(s); if(obj.top){ posesTop=obj.top; buildPoseButtons(posesTop); if(posesTop.length) showPose(0); }
  alert('Session loaded.');
}
function loadSessionHistory(){ refreshRunRegistry(); }

// ========================= Demo =========================
async function autoDemo(){
  try{
    status('demo fetch'); const [fab,lyz]=await Promise.all([
      fetch('https://files.rcsb.org/download/1FBI.pdb').then(r=>r.ok?r.text():Promise.reject()),
      fetch('https://files.rcsb.org/download/1LYZ.pdb').then(r=>r.ok?r.text():Promise.reject())
    ]);
    E('pdbAText').value=fab; E('pdbBText').value=lyz; await parseOne('A'); await parseOne('B');
  }catch(_){
    E('pdbAText').value=`ATOM      1  CA  GLY A   1      -8.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  GLY A   2      -6.600   1.200   0.200  1.00  0.00           C
ATOM      3  CA  GLY A   3      -5.200   0.100   1.200  1.00  0.00           C
ATOM      4  CA  GLY A   4      -3.800   1.400   1.400  1.00  0.00           C
END`;
    E('pdbBText').value=`ATOM      1  CA  GLY B   1       2.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  GLY B   2       3.400   1.200  -0.200  1.00  0.00           C
ATOM      3  CA  GLY B   3       4.800   0.100  -1.200  1.00  0.00           C
ATOM      4  CA  GLY B   4       6.200   1.400  -1.400  1.00  0.00           C
END`;
    await parseOne('A'); await parseOne('B');
  }
  runAntibodyDocking();
}

// ========================= Utilities =========================
function resetAll(){
  cancelled=false; inProgress=false; workerPool.forEach(w=>{try{w.terminate();}catch(e){}}); workerPool=[];
  screenWorkerPool.forEach(w=>{try{w.terminate();}catch(e){}}); screenWorkerPool=[];
  posesTop=[]; currentPose=null; currentA=null; currentB0=null; currentContacts=[]; currentHB=[]; currentSB=[]; currentHydro=[];
  viewer?.clear(); viewerLig?.clear(); viewerScr?.clear(); viewerComp?.clear(); drawPlaceholder(viewer);
  E('poseControls').innerHTML=''; E('scoreBox').innerHTML=''; updateMetricsDisplay(); status('idle'); setProgress(0);
}
function useExample(which){
  const egA=`ATOM      1  CA  GLY A   1      -8.000   0.000   0.000  1.00  0.00           C
ATOM      2  CA  GLY A   2      -6.600   1.200   0.200  1.00  0.00           C
ATOM      3  CA  GLY A   3      -5.200   0.100   1.200  1.00  0.00           C
END`;
  const egB=egA.replace(/ A /g,' B ').replace(/-8/g,'2').replace(/-6.600/g,'3.4').replace(/-5.200/g,'4.8');
  E(which==='A'?'pdbAText':'pdbBText').value = which==='A'?egA:egB; parseOne(which);
}